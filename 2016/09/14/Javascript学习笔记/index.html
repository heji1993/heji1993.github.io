

<!DOCTYPE html>
<html lang="zh-Hans">
<head>
    
    <meta name="author" content="何机">
    
    <meta name="description" content="Javascript入门教程。">
    
    

    
    <link rel="alternative" href="atom.xml" title="何机的博客" type="application/atom+xml">
    
    
    

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>JS学习笔记 | 何机的博客 · No pains,no gains</title>

    <!-- Bootstrap -->
    <link rel="stylesheet" href="/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="/css/style.css">

    <!-- Javascript -->
    <script src="/js/jquery-2.1.0.min.js"></script>
    <script src="/js/jquery.backstretch.min.js"></script>
    <script src="/bootstrap/js/bootstrap.min.js"></script>
    <script src="/js/headroom.min.js"></script>
    <script src="/js/jquery.headroom.min.js"></script>
    <script src="/js/common.js"></script>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    
    <meta name="baidu-site-verification" content="SzJ3MGdmeo" />


    <meta name="360-site-verification" content="afe5dc96bbb8d111b618f78493b95bb8" />


    <!--<meta name="baidu-site-verification" content="SzJ3MGdmeo" />-->
    <!--<meta name="360-site-verification" content="afe5dc96bbb8d111b618f78493b95bb8" />-->

</head>
<body>
    <nav class="navbar navbar-default navbar-fixed-top navbar-inverse" role="banner">
        <div class="container">
            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="https://heji1993.github.io" title="何机的博客">何机的博客</a>
            </div>

            <div role="navigation" class="collapse navbar-collapse bs-navbar-collapse">
                
                <ul class="nav navbar-nav pull-right">
                    <li>
                        <!--<a class="max-width max-w300" title="No pains,no gains" href="/feelings">No pains,no gains</a>-->
						<a class="max-width max-w300" title="No pains,no gains">No pains,no gains</a>
                    </li>
                </ul>
                

                <ul class="nav navbar-nav">
                    
                    <li id="nav-index">
                        <a href="/" target="">首页</a>
                    </li>
                    
                    <li id="nav-archives">
                        <a href="/archives" target="">归档</a>
                    </li>
                    
                    <li id="nav-categories">
                        <a href="/categories" target="">分类</a>
                    </li>
                    
                    <li id="nav-tags">
                        <a href="/tags" target="">标签</a>
                    </li>
                    
                    <li id="nav-about">
                        <a href="/about" target="">关于</a>
                    </li>
                    

                    <li id="nav-github"><a href="https://github.com/heji1993" target="_blank">GitHub</a></li>
                    <!--<li id="nav-rss"><a href="/atom.xml" target="_blank">Rss</a></li>-->
                    <li id="nav-search"><input type="text" id="search" placeholder="search" /></li>
                </ul>
            </div>
        </div>
    </nav>

    <script>
    var bgRoot = "http://7xkwt1.com1.z0.glb.clouddn.com/background-";
    var bgLength = "74";
    var bgRandom = false;
    var bgImage = "/images/bg.jpg";

    $(function() {
        // page-id...
        var pageId = "2016/09/14/Javascript学习笔记/";
        pageId = pageId.substr(0, pageId.indexOf("/"));
        if(pageId === "") pageId = "index";

        $("#nav-" + pageId).addClass("active");
    });
    </script>

    <article class="post container">
    <div class="well post-body first-post last-post">
        <h1>JS学习笔记</h1>

        <div class="time-info">
            
<span class="article-tags">
    
    Tags: <a href="/tags/Javascript/">Javascript</a>&nbsp;<a href="/tags/前端/">前端</a>&nbsp;
</span>



<span class="article-categories">
    Category:
    <a class="article-category-link" href="/categories/Web前端/">Web前端</a>
</span>


        </div>
        <div class="time-info">
            发表: <time datetime="2016-09-14T03:08:22.125Z"
                       itemprop="datePublished">2016-09-14</time>
            
            更新: <time datetime="2016-12-12T03:03:38.434Z"
                       itemprop="dateModified">2016-12-12</time>
            
        </div>

        <div class="post-body-inner">
            
                <div id="toc" class="toc-article well">
                    <strong class="toc-title">大纲</strong>
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#常用技巧-推荐学习工具：javascripting"><span class="toc-number">1.</span> <span class="toc-text">常用技巧(推荐学习工具：javascripting)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript简介"><span class="toc-number">2.</span> <span class="toc-text">JavaScript简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#快速入门"><span class="toc-number">3.</span> <span class="toc-text">快速入门</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#基本语法"><span class="toc-number">3.1.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据类型和变量"><span class="toc-number">3.2.</span> <span class="toc-text">数据类型和变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#字符串"><span class="toc-number">3.3.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">3.4.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象"><span class="toc-number">3.5.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#条件判断"><span class="toc-number">3.6.</span> <span class="toc-text">条件判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循环"><span class="toc-number">3.7.</span> <span class="toc-text">循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Map和Set（ES6规范引入）"><span class="toc-number">3.8.</span> <span class="toc-text">Map和Set（ES6规范引入）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iterable"><span class="toc-number">3.9.</span> <span class="toc-text">iterable</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#函数"><span class="toc-number">4.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#函数的定义和调用"><span class="toc-number">4.1.</span> <span class="toc-text">函数的定义和调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#变量作用域"><span class="toc-number">4.2.</span> <span class="toc-text">变量作用域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法"><span class="toc-number">4.3.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#高阶函数"><span class="toc-number">4.4.</span> <span class="toc-text">高阶函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#map-reduce"><span class="toc-number">4.4.1.</span> <span class="toc-text">map/reduce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Filter"><span class="toc-number">4.4.2.</span> <span class="toc-text">Filter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sort"><span class="toc-number">4.4.3.</span> <span class="toc-text">sort</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#闭包"><span class="toc-number">4.5.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#箭头函数-ES6新增"><span class="toc-number">4.6.</span> <span class="toc-text">箭头函数(ES6新增)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#标准对象"><span class="toc-number">5.</span> <span class="toc-text">标准对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#包装对象"><span class="toc-number">5.1.</span> <span class="toc-text">包装对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Date对象"><span class="toc-number">5.2.</span> <span class="toc-text">Date对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RegExp：正则表达式"><span class="toc-number">5.3.</span> <span class="toc-text">RegExp：正则表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSON对象"><span class="toc-number">5.4.</span> <span class="toc-text">JSON对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#面向对象编程"><span class="toc-number">6.</span> <span class="toc-text">面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#创建对象"><span class="toc-number">6.1.</span> <span class="toc-text">创建对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原型继承"><span class="toc-number">6.2.</span> <span class="toc-text">原型继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#class继承-ES6引入"><span class="toc-number">6.3.</span> <span class="toc-text">class继承(ES6引入)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#浏览器"><span class="toc-number">7.</span> <span class="toc-text">浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器对象"><span class="toc-number">7.1.</span> <span class="toc-text">浏览器对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作DOM"><span class="toc-number">7.2.</span> <span class="toc-text">操作DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建元素"><span class="toc-number">7.2.1.</span> <span class="toc-text">创建元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#节点关系"><span class="toc-number">7.2.2.</span> <span class="toc-text">节点关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#节点元素关系"><span class="toc-number">7.2.3.</span> <span class="toc-text">节点元素关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#节点操作"><span class="toc-number">7.2.4.</span> <span class="toc-text">节点操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元素选择"><span class="toc-number">7.2.5.</span> <span class="toc-text">元素选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性操作"><span class="toc-number">7.2.6.</span> <span class="toc-text">属性操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#操作文件"><span class="toc-number">7.3.</span> <span class="toc-text">操作文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ajax"><span class="toc-number">7.4.</span> <span class="toc-text">Ajax</span></a></li></ol></li></ol>
                </div>
            

            <p>Javascript入门教程。</p>
<a id="more"></a>
<h1 id="常用技巧-推荐学习工具：javascripting"><a href="#常用技巧-推荐学习工具：javascripting" class="headerlink" title="常用技巧(推荐学习工具：javascripting)"></a>常用技巧(推荐学习工具：javascripting)</h1><hr>
<ul>
<li><strong> 本教程使用chrome的console演示。chrome的console可以按住Ctrl和+加大字体，使用Ctrl+0复原 </strong></li>
<li><p><strong> js中获取iframe的元素或者调用iframe的方法 </strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">     iframeObj.contentWindow.document</div><div class="line">     iframeObj.contentWindow.functionName();</div></pre></td></tr></table></figure>
</li>
<li><p>高级for循环</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> index <span class="keyword">in</span> object)</div></pre></td></tr></table></figure>
<p>当用于数组时，index表示数组元素的索引<br>当用于对象时，index表示对象属性的key</p>
</li>
<li>javascript灵活性之一：<br>可以通过传递回调函数避免过度嵌套</li>
<li><p>javascript灵活性之二：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> tasks = [<span class="string">"init"</span>,<span class="string">"start"</span>,<span class="string">"stop"</span>,<span class="string">"destory"</span>];</div><div class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> index <span class="keyword">in</span> tasks)&#123;</div><div class="line">          <span class="comment">//相当于调用init();start();...</span></div><div class="line">          tasks[index]();</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>数组的map方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">//Array.map(callback(item,index))返回由数组中每个元素调用回调函数之后的新元素组成的数组。join方法把数组转换为字符串,参数表示分隔符</span></div><div class="line">     <span class="keyword">var</span> body = items.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,i</span>)</span>&#123;</div><div class="line">          <span class="keyword">return</span> i+<span class="string">")"</span>+item;</div><div class="line">     &#125;).join(<span class="string">'\n'</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>substring(start,[end])和slice(start,[end])<br>substring方法所有参数必须为正数，否则返回空<br>slice方法如果参数start为负数，end为空，表示从尾部开始算起。比如’hello’.slice(-2)—&gt;lo<br>如果参数start为负数，end也必须为负数，且要比start大，否则返回空</p>
</li>
<li><p>splice()方法再论（数组是以0作为首元素的下标，splice()方法返回删除的元素）<br>当只有一个参数时，以参数为起始位置删除后面所有元素例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> items = [<span class="string">'Bob'</span>,<span class="string">'Jack'</span>,<span class="string">'Lily'</span>,<span class="string">'Sam'</span>];</div><div class="line">     <span class="keyword">var</span> array = items.splice(<span class="number">2</span>);</div><div class="line">     <span class="built_in">console</span>.log(array);  <span class="comment">//['Lily','Sam']</span></div></pre></td></tr></table></figure>
<p>当有两个参数时例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> items = [<span class="string">'Bob'</span>,<span class="string">'Jack'</span>,<span class="string">'Lily'</span>,<span class="string">'Sam'</span>];</div><div class="line">     <span class="keyword">var</span> array = items.splice(<span class="number">2</span>，<span class="number">1</span>);</div><div class="line">     <span class="built_in">console</span>.log(array);  <span class="comment">//['Lily']</span></div><div class="line">     <span class="built_in">console</span>.log(items); <span class="comment">//['Bob','Jack','Sam']</span></div></pre></td></tr></table></figure>
<p>当有多个参数时：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> items = [<span class="string">'Bob'</span>,<span class="string">'Jack'</span>,<span class="string">'Lily'</span>,<span class="string">'Sam'</span>];</div><div class="line">     <span class="keyword">var</span> array = items.splice(<span class="number">2</span>，<span class="number">1</span>，<span class="string">'Tom'</span>，<span class="string">'Lucy'</span>);</div><div class="line">     <span class="built_in">console</span>.log(array);  <span class="comment">//['Lily']</span></div><div class="line">     <span class="built_in">console</span>.log(items); <span class="comment">//['Bob','Jack','Tom','Lucy','Sam']</span></div></pre></td></tr></table></figure>
</li>
<li><p>JSON.parse(str)和JSON. stringify(jsonObj)<br>JSON.parse(str)用于把字符串转化为JSON对象<br>JSON.stringify(obj)用于把JSON对象转化为字符串</p>
</li>
<li><p>父页面获取iframe子页面的元素<br>JS版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">      <span class="keyword">var</span> frameDoc=<span class="built_in">document</span>.getElementById(<span class="string">'iframeId'</span>).contentWindow.document  <span class="comment">//document对象</span></div><div class="line">       <span class="keyword">var</span> frameBody=<span class="built_in">document</span>.getElementById(<span class="string">'iframeId'</span>).contentWindow.document.body   <span class="comment">//body对象</span></div></pre></td></tr></table></figure>
<p>JQ版本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">     $(<span class="string">"#iframe的ID"</span>).contents().find(<span class="string">"#iframe中的控件ID"</span>).click();<span class="comment">//jquery 方法1 必须在iframe加载完后才有效</span></div></pre></td></tr></table></figure>
</li>
<li><p>在iframe中获取父页面的id元素<br>JS版本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> obj=<span class="built_in">window</span>.parent.document.getElementById(<span class="string">'objId'</span>)</div></pre></td></tr></table></figure>
<p>JQ版本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">     $(<span class="string">'#父级窗口的objId'</span>, <span class="built_in">window</span>.parent.document).css(<span class="string">'height'</span>:<span class="string">'height);  // window可省略不写</span></div></pre></td></tr></table></figure>
</li>
<li><p>iframe高度自适应</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     $(<span class="string">'#iframeId'</span>).load(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">          <span class="keyword">var</span> iframeHeight=$(<span class="keyword">this</span>).contents().height(); </div><div class="line">          $(<span class="keyword">this</span>).height(iframeHeight+<span class="string">'px'</span>);  </div><div class="line">     &#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>JS字符串中的方法传参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> html=<span class="string">"&lt;a onclick='selecthoods(\" "</span>+a + <span class="string">"\"); &gt;AAA&lt;/a&gt;"</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>JS实现模拟安卓端连续点击返回键退出应用的demo</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">//监听返回键</span></div><div class="line">                app.initialize(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                    <span class="built_in">document</span>.addEventListener(<span class="string">"backbutton"</span>, shutDown, <span class="literal">false</span>);</div><div class="line">                &#125;);</div><div class="line">                <span class="keyword">var</span> beginDate;          <span class="comment">// 两次点击退出按钮开始时间 </span></div><div class="line">                <span class="keyword">var</span> isToast = <span class="literal">false</span>;    <span class="comment">// 是否弹出弹框 </span></div><div class="line">                <span class="function"><span class="keyword">function</span> <span class="title">shutDown</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                     <span class="keyword">var</span> endDate = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(); <span class="comment">// 两次点击退出按钮结束时间 </span></div><div class="line">                     <span class="comment">// 提示过Toast并且两次点击时间小于2S </span></div><div class="line">                     <span class="keyword">if</span> ( isToast &amp;&amp; endDate - beginDate &lt; <span class="number">2000</span> ) &#123; </div><div class="line">                         beginDate = endDate; </div><div class="line">                         isToast = <span class="literal">false</span>; </div><div class="line">                         powerdata.router.exit(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;&#125;);</div><div class="line">                     &#125; <span class="keyword">else</span></div><div class="line">                         Toast(<span class="string">'再次点击退出程序'</span>,<span class="number">2000</span>);  </div><div class="line">                &#125;</div><div class="line"> </div><div class="line">                <span class="comment">//自定义弹框 2s消失 </span></div><div class="line">                 <span class="function"><span class="keyword">function</span> <span class="title">Toast</span>(<span class="params">msg,duration</span>)</span>&#123; </div><div class="line">                     isToast = <span class="literal">true</span>; </div><div class="line">                     beginDate = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(); </div><div class="line">                     duration=<span class="built_in">isNaN</span>(duration)?<span class="number">3000</span>:duration; <span class="comment">// duration是不是一个数字     </span></div><div class="line">                     <span class="keyword">var</span> m = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>); </div><div class="line">                     m.innerHTML = msg; </div><div class="line">                     m.style.cssText=<span class="string">"width:60%; min-width:150px; background:#000; opacity:0.5; height:40px; color:#fff; line-height:40px; text-align:center; border-radius:5px; position:fixed; top:80%; left:20%; z-index:999999; font-weight:bold;"</span>; </div><div class="line">                     <span class="built_in">document</span>.body.appendChild(m); </div><div class="line">                     setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">                         <span class="keyword">var</span> d = <span class="number">0.5</span>; </div><div class="line">                         m.style.webkitTransition = <span class="string">'-webkit-transform '</span> + d + <span class="string">'s ease-in, opacity '</span> + d + <span class="string">'s ease-in'</span>; </div><div class="line">                         m.style.opacity = <span class="string">'0'</span>; </div><div class="line">                         setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">document</span>.body.removeChild(m) &#125;, d * <span class="number">1000</span>); </div><div class="line">                     &#125;, duration); </div><div class="line">                 &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>JS实现动态时间</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">               <span class="comment">//时间</span></div><div class="line">            <span class="function"><span class="keyword">function</span> <span class="title">getCurDate</span>(<span class="params"></span>)</span>&#123; </div><div class="line">                 <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); </div><div class="line">                 <span class="keyword">var</span> week; </div><div class="line">                 <span class="keyword">switch</span> (d.getDay())&#123; </div><div class="line">                     <span class="keyword">case</span> <span class="number">1</span>: week=<span class="string">"星期一"</span>; <span class="keyword">break</span>; </div><div class="line">                     <span class="keyword">case</span> <span class="number">2</span>: week=<span class="string">"星期二"</span>; <span class="keyword">break</span>; </div><div class="line">                     <span class="keyword">case</span> <span class="number">3</span>: week=<span class="string">"星期三"</span>; <span class="keyword">break</span>; </div><div class="line">                     <span class="keyword">case</span> <span class="number">4</span>: week=<span class="string">"星期四"</span>; <span class="keyword">break</span>; </div><div class="line">                     <span class="keyword">case</span> <span class="number">5</span>: week=<span class="string">"星期五"</span>; <span class="keyword">break</span>; </div><div class="line">                     <span class="keyword">case</span> <span class="number">6</span>: week=<span class="string">"星期六"</span>; <span class="keyword">break</span>; </div><div class="line">                     <span class="keyword">default</span>: week=<span class="string">"星期天"</span>; </div><div class="line">                 &#125; </div><div class="line">                 <span class="keyword">var</span> years = d.getFullYear(); </div><div class="line">                 <span class="keyword">var</span> month = add_zero(d.getMonth()+<span class="number">1</span>); </div><div class="line">                 <span class="keyword">var</span> days = add_zero(d.getDate()); </div><div class="line">                 <span class="keyword">var</span> hours = add_zero(d.getHours()); </div><div class="line">                 <span class="keyword">var</span> minutes = add_zero(d.getMinutes()); </div><div class="line">                 <span class="keyword">var</span> seconds=add_zero(d.getSeconds()); </div><div class="line">                 <span class="keyword">var</span> ndate = years+<span class="string">"年"</span>+month+<span class="string">"月"</span>+days+<span class="string">"日 "</span>+hours+<span class="string">":"</span>+minutes+<span class="string">":"</span>+seconds+<span class="string">" "</span>+week; </div><div class="line">                 $(<span class="string">'.nowTime'</span>).html(ndate)</div><div class="line">            &#125; </div><div class="line">            <span class="function"><span class="keyword">function</span> <span class="title">add_zero</span>(<span class="params">temp</span>)</span>&#123; </div><div class="line">                 <span class="keyword">if</span>(temp&lt;<span class="number">10</span>) <span class="keyword">return</span> <span class="string">"0"</span>+temp; </div><div class="line">                 <span class="keyword">else</span> <span class="keyword">return</span> temp; </div><div class="line">            &#125;  </div><div class="line">               setInterval(getCurDate,<span class="number">100</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h1><hr>
<ul>
<li>JavaScript历史<br>   在上个世纪的1995年，当时的网景公司正凭借其Navigator浏览器成为Web时代开启时最著名的第一代互联网公司。由于网景公司希望能在静态HTML页面上添加一些动态效果，于是叫Brendan Eich这哥们在两周之内设计出了JavaScript语言。你没看错，这哥们只用了10天时间。为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。</li>
<li>ECMAScript<br>   因为网景开发了JavaScript，一年后微软又模仿JavaScript开发了JScript，为了让JavaScript成为全球标准，几个公司联合ECMA（European Computer Manufacturers Association）组织定制了JavaScript语言的标准，被称为ECMAScript标准。 所以简单说来就是，ECMAScript是一种语言标准，而JavaScript是网景公司对ECMAScript标准的一种实现。<br>   那为什么不直接把JavaScript定为标准呢？因为JavaScript是网景的注册商标。</li>
<li>JavaScript版本<br>  由于JavaScript的标准——ECMAScript在不断发展，最新版ECMAScript 6标准（简称ES6）已经在2015年6月正式发布了，所以，讲到JavaScript的版本，实际上就是说它实现了ECMAScript标准的哪个版本。由于浏览器在发布时就确定了JavaScript的版本，加上很多用户还在使用IE6这种古老的浏览器，这就导致你在写JavaScript的时候，要照顾一下老用户，不能一上来就用最新的ES6标准写，否则，老用户的浏览器是无法运行新版本的JavaScript代码的。</li>
</ul>
<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><hr>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul>
<li>语法<br>JavaScript的语法和Java语言类似，每个语句以<code>;</code>结束，语句块用<code>{...}</code>。但是，JavaScript并不强制要求在每个语句的结尾加<code>;</code>，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上<code>;</code>。</li>
<li><p>注释<br>  以//开头直到行末的字符被视为行注释，注释是给开发人员看到，JavaScript引擎会自动忽略：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="comment">// 这是一行注释</span></div><div class="line">          alert(<span class="string">'hello'</span>); <span class="comment">// 这也是注释</span></div></pre></td></tr></table></figure>
<p>  另一种块注释是用/<em>…</em>/把多行字符包裹起来，把一大“块”视为一个注释：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="comment">/* 从这里开始是块注释</span></div><div class="line">          仍然是注释</div><div class="line">          仍然是注释</div><div class="line">          注释结束 */</div></pre></td></tr></table></figure>
</li>
<li><p>大小写<br>  请注意，JavaScript严格区分大小写，如果弄错了大小写，程序将报错或者运行不正常。</p>
</li>
</ul>
<h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><ul>
<li><p>Number<br>  JavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          <span class="number">123</span>; <span class="comment">// 整数123</span></div><div class="line">          <span class="number">0.456</span>; <span class="comment">// 浮点数0.456</span></div><div class="line">          <span class="number">1.2345e3</span>; <span class="comment">// 科学计数法表示1.2345x1000，等同于1234.5</span></div><div class="line">          <span class="number">-99</span>; <span class="comment">// 负数</span></div><div class="line">          <span class="literal">NaN</span>; <span class="comment">// NaN表示Not a Number，当无法计算结果时用NaN表示</span></div><div class="line">          <span class="literal">Infinity</span>; <span class="comment">// Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span></div></pre></td></tr></table></figure>
<p>  Number可以直接做四则运算，规则和数学一致：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">          <span class="number">1</span> + <span class="number">2</span>; <span class="comment">// 3</span></div><div class="line">          (<span class="number">1</span> + <span class="number">2</span>) * <span class="number">5</span> / <span class="number">2</span>; <span class="comment">// 7.5</span></div><div class="line">          <span class="number">2</span> / <span class="number">0</span>; <span class="comment">// Infinity</span></div><div class="line">          <span class="number">0</span> / <span class="number">0</span>; <span class="comment">// NaN</span></div><div class="line">         <span class="comment">// 注意%是求余运算。</span></div><div class="line">          <span class="number">10</span> % <span class="number">3</span>; <span class="comment">// 1</span></div><div class="line">          <span class="number">10.5</span> % <span class="number">3</span>; <span class="comment">// 1.5</span></div></pre></td></tr></table></figure>
</li>
<li><p>字符串<br>  字符串是以单引号’或双引号”括起来的任意文本，比如<code>&#39;abc&#39;</code>，<code>&quot;xyz&quot;</code>等等。请注意，<code>&#39;&#39;</code>或<code>&quot;&quot;</code>本身只是一种表示方式，不是字符串的一部分，因此，字符串<code>&#39;abc&#39;</code>只有<code>a，b，c</code>这3个字符。</p>
</li>
<li><p>布尔值<br>  布尔值和布尔代数的表示完全一致，一个布尔值只有true、false两种值，要么是true，要么是false，可以直接用true、false表示布尔值，也可以通过布尔运算计算出来：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="literal">true</span>; <span class="comment">// 这是一个true值</span></div><div class="line">          <span class="literal">false</span>; <span class="comment">// 这是一个false值</span></div><div class="line">          <span class="number">2</span> &gt; <span class="number">1</span>; <span class="comment">// 这是一个true值</span></div><div class="line">          <span class="number">2</span> &gt;= <span class="number">3</span>; <span class="comment">// 这是一个false值</span></div></pre></td></tr></table></figure>
<p>  <code>&amp;&amp;</code>运算是与运算，只有所有都为<code>true</code>，<code>&amp;&amp;</code>运算结果才是<code>true</code>：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">          <span class="literal">true</span> &amp;&amp; <span class="literal">true</span>; <span class="comment">// 这个&amp;&amp;语句计算结果为true</span></div><div class="line">          <span class="literal">true</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// 这个&amp;&amp;语句计算结果为false</span></div><div class="line">          <span class="literal">false</span> &amp;&amp; <span class="literal">true</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// 这个&amp;&amp;语句计算结果为false</span></div></pre></td></tr></table></figure>
<p>  <code>||</code>运算是或运算，只要其中有一个为<code>true</code>，<code>||</code>运算结果就是<code>true</code><br>  <code>!</code>运算是非运算，它是一个单目运算符，把<code>true</code>变成<code>false</code>，<code>false</code>变成<code>true</code>：</p>
</li>
<li><p>比较运算符<br>  当我们对Number做比较时，可以通过比较运算符得到一个布尔值：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          <span class="number">2</span> &gt; <span class="number">5</span>; <span class="comment">// false</span></div><div class="line">          <span class="number">5</span> &gt;= <span class="number">2</span>; <span class="comment">// true</span></div><div class="line">          <span class="number">7</span> == <span class="number">7</span>; <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>  实际上，JavaScript允许对任意数据类型做比较：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="literal">false</span> == <span class="number">0</span>; <span class="comment">// true</span></div><div class="line">          <span class="literal">false</span> === <span class="number">0</span>; <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>  要特别注意相等运算符==。JavaScript在设计时，有两种比较运算符：<br>  第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；<br>  第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。<br>  由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。<br>  另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          <span class="literal">NaN</span> === <span class="literal">NaN</span>; <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>  唯一能判断NaN的方法是通过isNaN()函数：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          <span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>  最后要注意浮点数的相等比较：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          <span class="number">1</span> / <span class="number">3</span> === (<span class="number">1</span> - <span class="number">2</span> / <span class="number">3</span>); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>  这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          <span class="built_in">Math</span>.abs(<span class="number">1</span> / <span class="number">3</span> - (<span class="number">1</span> - <span class="number">2</span> / <span class="number">3</span>)) &lt; <span class="number">0.0000001</span>; <span class="comment">// true</span></div></pre></td></tr></table></figure>
</li>
<li><p>null 和 undefined<br>  null表示一个“空”的值，它和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而null表示“空”。<br>  JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。</p>
</li>
<li><p>数组<br>  数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">'Hello'</span>, <span class="literal">null</span>, <span class="literal">true</span>];</div></pre></td></tr></table></figure>
<p>  上述数组包含6个元素。数组用[]表示，元素之间用,分隔。另一种创建数组的方法是通过Array()函数实现：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 创建了数组[1, 2, 3]</span></div></pre></td></tr></table></figure>
<p>  然而，出于代码的可读性考虑，强烈建议直接使用<code>[]</code>。<br>  数组的元素可以通过索引来访问。请注意，索引的起始值为<code>0</code>：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">'Hello'</span>, <span class="literal">null</span>, <span class="literal">true</span>];</div><div class="line">          arr[<span class="number">0</span>]; <span class="comment">// 返回索引为0的元素，即1</span></div><div class="line">          arr[<span class="number">5</span>]; <span class="comment">// 返回索引为5的元素，即true</span></div><div class="line">          arr[<span class="number">6</span>]; <span class="comment">// 索引超出了范围，返回undefined</span></div></pre></td></tr></table></figure>
</li>
<li><p>对象<br>  JavaScript的对象是一组由键-值组成的无序集合，例如：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> person = &#123;</div><div class="line">               name: <span class="string">'Bob'</span>,</div><div class="line">               age: <span class="number">20</span>,</div><div class="line">               tags: [<span class="string">'js'</span>, <span class="string">'web'</span>, <span class="string">'mobile'</span>],</div><div class="line">               city: <span class="string">'Beijing'</span>,</div><div class="line">               hasCar: <span class="literal">true</span>,</div><div class="line">               zipcode: <span class="literal">null</span></div><div class="line">          &#125;;</div></pre></td></tr></table></figure>
<p>  JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述person对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，person的name属性为’Bob’，zipcode属性为null。<br>  要获取一个对象的属性，我们用对象变量.属性名的方式：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          person.name; <span class="comment">// 'Bob'</span></div><div class="line">          person.zipcode; <span class="comment">// null</span></div></pre></td></tr></table></figure>
</li>
<li><p>变量<br>  变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。申明一个变量用var语句，比如：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> a; <span class="comment">// 申明了变量a，此时a的值为undefined</span></div><div class="line">          <span class="keyword">var</span> $b = <span class="number">1</span>; <span class="comment">// 申明了变量$b，同时给$b赋值，此时$b的值为1</span></div><div class="line">          <span class="keyword">var</span> s_007 = <span class="string">'007'</span>; <span class="comment">// s_007是一个字符串</span></div><div class="line">          <span class="keyword">var</span> Answer = <span class="literal">true</span>; <span class="comment">// Answer是一个布尔值true</span></div><div class="line">          <span class="keyword">var</span> t = <span class="literal">null</span>; <span class="comment">// t的值是null</span></div></pre></td></tr></table></figure>
<p>  变量名也可以用中文，但是，请不要给自己找麻烦。<br>  在JavaScript中，使用等号<code>=</code>对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用<code>var</code>申明一次，例如：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> a = <span class="number">123</span>; <span class="comment">// a的值是整数123</span></div><div class="line">          a = <span class="string">'ABC'</span>; <span class="comment">// a变为字符串</span></div></pre></td></tr></table></figure>
<p>  这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错，例如java。<br>  和静态语言相比，动态语言更灵活，就是这个原因。</p>
</li>
<li><p>strict模式<br>  JavaScript在设计之初，为了方便初学者学习，并不强制要求用var申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          i = <span class="number">10</span>; <span class="comment">// i现在是全局变量</span></div></pre></td></tr></table></figure>
<p>  在同一个页面的不同的JavaScript文件中，如果都不用<code>var</code>申明，恰好都使用了变量<code>i</code>，将造成变量<code>i</code>互相影响，产生难以调试的错误结果。<br>  使用var申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。<br>   为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误。<br>   启用strict模式的方法是在JavaScript代码的第一行写上：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;</div><div class="line">          <span class="comment">// 如果浏览器支持strict模式，</span></div><div class="line">          <span class="comment">// 下面的代码将报ReferenceError错误:</span></div><div class="line">          abc = <span class="string">'Hello, world'</span>;</div><div class="line">          alert(abc);</div></pre></td></tr></table></figure>
<p>  这是一个字符串，不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。<br>  运行代码，如果浏览器报错，请修复后再运行。如果浏览器不报错，说明你的浏览器太古老了，需要尽快升级。<br>  不用var申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict模式。我们在后面编写的JavaScript代码将全部采用strict模式。</p>
</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Javascript的字符串就是用<code>&#39;&#39;</code>或<code>&quot;&quot;</code>括起来的字符表示。<br>如果<code>&#39;</code>本身也是一个字符，那就可以用<code>&quot;&quot;</code>括起来，比如<code>&quot;I&#39;m OK&quot;</code>包含的字符是<code>I</code>，<code>&#39;</code>，<code>m</code>，空格，<code>O</code>，<code>K</code>这6个字符。<br>如果字符串内部既包含<code>&#39;</code>又包含<code>&quot;</code>怎么办？可以用转义字符<code>\</code>来标识，比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> str = <span class="string">'I\'m \"OK\"!'</span>;</div></pre></td></tr></table></figure></p>
<p>转义字符<code>\</code>可以转义很多字符，比如<code>\n</code>表示换行，<code>\t</code>表示制表符，字符<code>\</code>本身也要转义，所以<code>\\</code>表示的字符就是<code>\</code>。<br><b style="color:red;">由于多行字符串用<code>\n</code>写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法：</b></p>
<ul>
<li><p>字符串常见操作<br>  1、获取长度</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> s = <span class="string">'Hello, world!'</span>;</div><div class="line">          s.length; <span class="comment">// 13</span></div></pre></td></tr></table></figure>
<p>  2、获取指定位置的字符</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> s = <span class="string">'Hello, world!'</span>;</div><div class="line">          s[<span class="number">0</span>]; <span class="comment">// 'H'</span></div><div class="line">          s[<span class="number">6</span>]; <span class="comment">// ' '</span></div><div class="line">          s[<span class="number">7</span>]; <span class="comment">// 'w'</span></div><div class="line">          s[<span class="number">12</span>]; <span class="comment">// '!'</span></div><div class="line">          s[<span class="number">13</span>]; <span class="comment">// undefined 超出范围的索引不会报错，但一律返回undefined</span></div></pre></td></tr></table></figure>
<p>  3、需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> s = <span class="string">'Test'</span>;</div><div class="line">          s[<span class="number">0</span>] = <span class="string">'X'</span>;</div><div class="line">          alert(s); <span class="comment">// s仍然为'Test'</span></div></pre></td></tr></table></figure>
<p>  JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串：<br>  4、toUpperCase</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> s = <span class="string">'Hello'</span>;</div><div class="line">         <span class="comment">// toUpperCase()把一个字符串全部变为大写</span></div><div class="line">          s.toUpperCase(); <span class="comment">// 返回'HELLO'</span></div></pre></td></tr></table></figure>
<p>  5、indexOf</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> s = <span class="string">'hello, world'</span>;</div><div class="line">          s.indexOf(<span class="string">'world'</span>); <span class="comment">// 返回7</span></div><div class="line">          s.indexOf(<span class="string">'World'</span>); <span class="comment">// 没有找到指定的子串，返回-1</span></div></pre></td></tr></table></figure>
<p>  6、substring</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> s = <span class="string">'hello, world'</span></div><div class="line">         <span class="comment">// substring()返回指定索引区间的子串</span></div><div class="line">          s.substring(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 从索引0开始到5（不包括5），返回'hello'</span></div><div class="line">          s.substring(<span class="number">7</span>); <span class="comment">// 从索引7开始到结束，返回'world'</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p>基本知识<br>JavaScript的Array可以包含任意数据类型，并通过索引来访问每个元素。<br>要取得Array的长度，直接访问length属性：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">'Hello'</span>, <span class="literal">null</span>, <span class="literal">true</span>];</div><div class="line">          arr.length; <span class="comment">// 6</span></div></pre></td></tr></table></figure>
<p>  <b style="color:red;">请注意，直接给Array的length赋一个新的值会导致Array大小的变化：</b></p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">          arr.length; <span class="comment">// 3</span></div><div class="line">          arr.length = <span class="number">6</span>;</div><div class="line">          arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, undefined]</span></div><div class="line">          arr.length = <span class="number">2</span>;</div><div class="line">          arr; <span class="comment">// arr变为[1, 2]</span></div></pre></td></tr></table></figure>
<p>  Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">          arr[<span class="number">1</span>] = <span class="number">99</span>;</div><div class="line">          arr; <span class="comment">// arr现在变为['A', 99, 'C']</span></div></pre></td></tr></table></figure>
<p>  <b style="color:red">请注意，如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化：</b></p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">          arr[<span class="number">5</span>] = <span class="string">'x'</span>;</div><div class="line">          arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, 'x']</span></div></pre></td></tr></table></figure>
<p>  大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。</p>
</li>
<li><p>常用方法</p>
<ul>
<li><p>indexOf<br>与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="string">'30'</span>, <span class="string">'xyz'</span>];</div><div class="line">               arr.indexOf(<span class="number">10</span>); <span class="comment">// 元素10的索引为0</span></div><div class="line">               arr.indexOf(<span class="number">20</span>); <span class="comment">// 元素20的索引为1</span></div><div class="line">               arr.indexOf(<span class="number">30</span>); <span class="comment">// 元素30没有找到，返回-1</span></div><div class="line">               arr.indexOf(<span class="string">'30'</span>); <span class="comment">// 元素'30'的索引为2</span></div></pre></td></tr></table></figure>
</li>
<li><p>slice (不会改变原数组)<br>slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>];</div><div class="line">               arr.slice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']</span></div><div class="line">               arr.slice(<span class="number">3</span>); <span class="comment">// 从索引3开始到结束: ['D', 'E', 'F', 'G']</span></div></pre></td></tr></table></figure>
<p>如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>];</div><div class="line">               <span class="keyword">var</span> aCopy = arr.slice();</div><div class="line">               aCopy; <span class="comment">// ['A', 'B', 'C', 'D', 'E', 'F', 'G']</span></div><div class="line">               aCopy === arr; <span class="comment">// false</span></div></pre></td></tr></table></figure>
</li>
<li><p>push和pop(改变原数组)<br>push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</div><div class="line">               arr.push(<span class="string">'A'</span>, <span class="string">'B'</span>); <span class="comment">// 返回Array新的长度: 4</span></div><div class="line">               arr; <span class="comment">// [1, 2, 'A', 'B']</span></div><div class="line">               arr.pop(); <span class="comment">// pop()返回'B'</span></div><div class="line">               arr; <span class="comment">// [1, 2, 'A']</span></div><div class="line">               arr.pop(); arr.pop(); arr.pop(); <span class="comment">// 连续pop 3次</span></div><div class="line">               arr; <span class="comment">// []</span></div><div class="line">               arr.pop(); <span class="comment">// 空数组继续pop不会报错，而是返回undefined</span></div><div class="line">               arr; <span class="comment">// []</span></div></pre></td></tr></table></figure>
</li>
<li><p>unshift和shift(改变原数组)<br>如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</div><div class="line">               arr.unshift(<span class="string">'A'</span>, <span class="string">'B'</span>); <span class="comment">// 返回Array新的长度: 4</span></div><div class="line">               arr; <span class="comment">// ['A', 'B', 1, 2]</span></div><div class="line">               arr.shift(); <span class="comment">// 'A'</span></div><div class="line">               arr; <span class="comment">// ['B', 1, 2]</span></div><div class="line">               arr.shift(); arr.shift(); arr.shift(); <span class="comment">// 连续shift 3次</span></div><div class="line">               arr; <span class="comment">// []</span></div><div class="line">               arr.shift(); <span class="comment">// 空数组继续shift不会报错，而是返回undefined</span></div><div class="line">               arr; <span class="comment">// []</span></div></pre></td></tr></table></figure>
</li>
<li><p>sort(改变原数组)<br>sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>];</div><div class="line">               arr.sort();</div><div class="line">               arr; <span class="comment">// ['A', 'B', 'C']</span></div></pre></td></tr></table></figure>
<p>能否按照我们自己指定的顺序排序呢？完全可以，我们将在后面的函数中讲到。</p>
</li>
<li><p>reverse(改变原数组)<br>reverse()把整个Array的元素给掉个个，也就是反转：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>];</div><div class="line">               arr.reverse();</div><div class="line">               arr; <span class="comment">// ['three', 'two', 'one']</span></div></pre></td></tr></table></figure>
</li>
<li><p>splice(改变原数组)<br>splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="string">'Microsoft'</span>, <span class="string">'Apple'</span>, <span class="string">'Yahoo'</span>, <span class="string">'AOL'</span>, <span class="string">'Excite'</span>, <span class="string">'Oracle'</span>];</div><div class="line">               <span class="comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span></div><div class="line">               arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回删除的元素 ['Yahoo', 'AOL', 'Excite']</span></div><div class="line">               arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></div><div class="line">               <span class="comment">// 只删除,不添加:</span></div><div class="line">               arr.splice(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// ['Google', 'Facebook']</span></div><div class="line">               arr; <span class="comment">// ['Microsoft', 'Apple', 'Oracle']</span></div><div class="line">               <span class="comment">// 只添加,不删除:</span></div><div class="line">               arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></div><div class="line">               arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></div></pre></td></tr></table></figure>
</li>
<li><p>concat(改变原数组)<br>concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">               <span class="keyword">var</span> added = arr.concat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line">               added; <span class="comment">// ['A', 'B', 'C', 1, 2, 3]</span></div><div class="line">               arr; <span class="comment">// ['A', 'B', 'C']</span></div></pre></td></tr></table></figure>
<p>请注意，concat()方法并没有修改当前Array，而是返回了一个新的Array。<br>实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">               arr.concat(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// ['A', 'B', 'C', 1, 2, 3, 4]</span></div></pre></td></tr></table></figure>
</li>
<li><p>join(不会改变原数组)<br>join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">               arr.join(<span class="string">'-'</span>); <span class="comment">// 'A-B-C-1-2-3'</span></div></pre></td></tr></table></figure>
<p>如果Array的元素不是字符串，将自动转换为字符串后再连接。</p>
</li>
<li>多维数组</li>
</ul>
</li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul>
<li><p>基础知识<br>  JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成。<br>JavaScript的对象用于描述现实世界中的某个对象。例如，为了描述“小明”这个淘气的小朋友，我们可以用若干键值对来描述他：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">               name: <span class="string">'小明'</span>,</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               school: <span class="string">'No.1 Middle School'</span>,</div><div class="line">               height: <span class="number">1.70</span>,</div><div class="line">               weight: <span class="number">65</span>,</div><div class="line">               score: <span class="literal">null</span></div><div class="line">          &#125;;</div></pre></td></tr></table></figure>
<p>  JavaScript用一个{…}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,，如果加了，有的浏览器（如低版本的IE）将报错。<br>访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用’’括起来：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> xiaohong = &#123;</div><div class="line">               name: <span class="string">'小红'</span>,</div><div class="line">               <span class="string">'middle-school'</span>: <span class="string">'No.1 Middle School'</span></div><div class="line">          &#125;;</div></pre></td></tr></table></figure>
<p>  xiaohong的属性名middle-school不是一个有效的变量，就需要用’’括起来。访问这个属性也无法使用.操作符，必须用[‘xxx’]来访问：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          xiaohong[<span class="string">'middle-school'</span>]; <span class="comment">// 'No.1 Middle School'</span></div><div class="line">          xiaohong[<span class="string">'name'</span>]; <span class="comment">// '小红'</span></div><div class="line">          xiaohong.name; <span class="comment">// '小红'(推荐写法)</span></div></pre></td></tr></table></figure>
<p>  如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回undefined：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">               name: <span class="string">'小明'</span></div><div class="line">          &#125;;</div><div class="line">          xiaoming.age; <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
</li>
<li><p>对象属性的增删改查<br>  由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">               name: <span class="string">'小明'</span></div><div class="line">          &#125;;</div><div class="line">          xiaoming.age; <span class="comment">// undefined</span></div><div class="line">          xiaoming.age = <span class="number">18</span>; <span class="comment">// 新增一个age属性</span></div><div class="line">          xiaoming.age; <span class="comment">// 18</span></div><div class="line">          <span class="keyword">delete</span> xiaoming.age; <span class="comment">// 删除age属性</span></div><div class="line">          xiaoming.age; <span class="comment">// undefined</span></div><div class="line">          <span class="keyword">delete</span> xiaoming[<span class="string">'name'</span>]; <span class="comment">// 删除name属性</span></div><div class="line">          xiaoming.name; <span class="comment">// undefined</span></div><div class="line">          <span class="keyword">delete</span> xiaoming.school; <span class="comment">// 删除一个不存在的school属性也不会报错</span></div></pre></td></tr></table></figure>
<p>  如果我们要检测xiaoming是否拥有某一属性，可以用in操作符：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">               name: <span class="string">'小明'</span>,</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               school: <span class="string">'No.1 Middle School'</span>,</div><div class="line">               height: <span class="number">1.70</span>,</div><div class="line">               weight: <span class="number">65</span>,</div><div class="line">               score: <span class="literal">null</span></div><div class="line">          &#125;;</div><div class="line">          <span class="string">'name'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></div><div class="line">          <span class="string">'grade'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>  不过要小心，如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">         <span class="comment">// 因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性。</span></div><div class="line">          <span class="string">'toString'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>  要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">               name: <span class="string">'小明'</span></div><div class="line">          &#125;;</div><div class="line">          xiaoming.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// true</span></div><div class="line">          xiaoming.hasOwnProperty(<span class="string">'toString'</span>); <span class="comment">// false</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>JavaScript使用<code>if () { ... } else { ... }</code>来进行条件判断。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> age = <span class="number">20</span>;</div><div class="line">          <span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123; <span class="comment">// 如果age &gt;= 18为true，则执行if语句块</span></div><div class="line">               alert(<span class="string">'adult'</span>);</div><div class="line">          &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则执行else语句块</span></div><div class="line">               alert(<span class="string">'teenager'</span>);</div><div class="line">          &#125;</div></pre></td></tr></table></figure></p>
<p>其中else语句是可选的。如果语句块只包含一条语句，那么可以省略<code>{}</code>（最好不要这样做，容易引发错误）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> age = <span class="number">20</span>;</div><div class="line">          <span class="keyword">if</span> (age &gt;= <span class="number">18</span>)</div><div class="line">               alert(<span class="string">'adult'</span>);</div><div class="line">          <span class="keyword">else</span></div><div class="line">               alert(<span class="string">'teenager'</span>);</div></pre></td></tr></table></figure></p>
<p>如果还要更细致地判断条件，可以使用多个<code>if...else...</code>的组合：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> age = <span class="number">3</span>;</div><div class="line">          <span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</div><div class="line">               alert(<span class="string">'adult'</span>);</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &gt;= <span class="number">6</span>) &#123;</div><div class="line">               alert(<span class="string">'teenager'</span>);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">               alert(<span class="string">'kid'</span>);</div><div class="line">          &#125;</div></pre></td></tr></table></figure></p>
<p>如果if的条件判断语句结果不是true或false怎么办？例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> s = <span class="string">'123'</span>;</div><div class="line">          <span class="keyword">if</span> (s.length) &#123; <span class="comment">// 条件计算结果为3</span></div><div class="line">               <span class="comment">// JavaScript把null、undefined、0、NaN和空字符串''视为false，其他值一概视为true，因此上述代码条件判断的结果是true。</span></div><div class="line">          &#125;</div></pre></td></tr></table></figure></p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>JavaScript的循环有两种，一种是for循环，通过初始条件、结束条件和递增条件来循环执行语句块：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> x = <span class="number">0</span>;</div><div class="line">     <span class="keyword">var</span> i;</div><div class="line">     <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=<span class="number">10000</span>; i++) &#123;</div><div class="line">          x = x + i;</div><div class="line">     &#125;</div><div class="line">     x; <span class="comment">// 50005000</span></div></pre></td></tr></table></figure></p>
<p>for循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用break语句退出循环，否则就是死循环：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> x = <span class="number">0</span>;</div><div class="line">     <span class="keyword">for</span> (;;) &#123; <span class="comment">// 将无限循环下去</span></div><div class="line">          <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</div><div class="line">              <span class="keyword">break</span>; <span class="comment">// 通过if判断来退出循环</span></div><div class="line">          &#125;</div><div class="line">          x ++;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p><code>for ... in</code>循环</p>
<p>for循环的一个变体是for … in循环，它可以把一个对象的所有属性依次循环出来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> o = &#123;</div><div class="line">          name: <span class="string">'Jack'</span>,</div><div class="line">          age: <span class="number">20</span>,</div><div class="line">          city: <span class="string">'Beijing'</span></div><div class="line">     &#125;;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</div><div class="line">          alert(key); <span class="comment">// 'name', 'age', 'city'</span></div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>要过滤掉对象继承的属性，用hasOwnProperty()来实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> o = &#123;</div><div class="line">          name: <span class="string">'Jack'</span>,</div><div class="line">          age: <span class="number">20</span>,</div><div class="line">          city: <span class="string">'Beijing'</span></div><div class="line">     &#125;;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</div><div class="line">          <span class="keyword">if</span> (o.hasOwnProperty(key)) &#123;</div><div class="line">              alert(key); <span class="comment">// 'name', 'age', 'city'</span></div><div class="line">          &#125;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>while循环(比较简单，这里不介绍)</p>
<h2 id="Map和Set（ES6规范引入）"><a href="#Map和Set（ES6规范引入）" class="headerlink" title="Map和Set（ES6规范引入）"></a>Map和Set（ES6规范引入）</h2><p>JavaScript的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。为了解决这个问题，最新的ES6规范引入了新的数据类型Map。要测试你的浏览器是否支持ES6规范，请执行以下代码，如果浏览器报ReferenceError错误，那么你需要换一个支持ES6的浏览器：</p>
<ul>
<li><p>Map<br>  Map是一组键值对的结构，具有极快的查找速度。<br>  用JavaScript写一个Map如下：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'Michael'</span>, <span class="number">95</span>], [<span class="string">'Bob'</span>, <span class="number">75</span>], [<span class="string">'Tracy'</span>, <span class="number">85</span>]]);</div><div class="line">          m.get(<span class="string">'Michael'</span>); <span class="comment">// 95</span></div></pre></td></tr></table></figure>
<p>  初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 空Map</span></div><div class="line">          m.set(<span class="string">'Adam'</span>, <span class="number">67</span>); <span class="comment">// 添加新的key-value</span></div><div class="line">          m.set(<span class="string">'Bob'</span>, <span class="number">59</span>);</div><div class="line">          m.has(<span class="string">'Adam'</span>); <span class="comment">// 是否存在key 'Adam': true</span></div><div class="line">          m.get(<span class="string">'Adam'</span>); <span class="comment">// 67</span></div><div class="line">          m.delete(<span class="string">'Adam'</span>); <span class="comment">// 删除key 'Adam'</span></div><div class="line">          m.get(<span class="string">'Adam'</span>); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>  由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">          m.set(<span class="string">'Adam'</span>, <span class="number">67</span>);</div><div class="line">          m.set(<span class="string">'Adam'</span>, <span class="number">88</span>);</div><div class="line">          m.get(<span class="string">'Adam'</span>); <span class="comment">// 88</span></div></pre></td></tr></table></figure>
</li>
<li><p>Set<br>  <code>Set</code>和<code>Map</code>类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。<br>要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// 空Set</span></div><div class="line">          <span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 含1, 2, 3</span></div></pre></td></tr></table></figure>
<p>  重复元素在Set中自动被过滤：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">'3'</span>]);</div><div class="line">          s; <span class="comment">// Set &#123;1, 2, 3, "3"&#125;</span></div></pre></td></tr></table></figure>
<p>  通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          &gt;&gt;&gt; s.add(<span class="number">4</span>)</div><div class="line">          &gt;&gt;&gt; s</div><div class="line">          &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</div><div class="line">          &gt;&gt;&gt; s.add(<span class="number">4</span>)</div><div class="line">          &gt;&gt;&gt; s</div><div class="line">          &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</div></pre></td></tr></table></figure>
<p>  通过delete(key)方法可以删除元素：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line">          s; <span class="comment">// Set &#123;1, 2, 3&#125;</span></div><div class="line">          s.delete(<span class="number">3</span>);</div><div class="line">          s; <span class="comment">// Set &#123;1, 2&#125;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h2><p>遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的<code>for ... of</code>循环来遍历。<br><b style="color:red;"><code>for ... of</code>循环是ES6引入的新的语法</b>，请测试你的浏览器是否支持：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     <span class="string">'use strict'</span>;</div><div class="line">     <span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123;</div><div class="line">     &#125;</div><div class="line">     alert(<span class="string">'你的浏览器支持for ... of'</span>);</div></pre></td></tr></table></figure></p>
<p>用for … of循环遍历集合，用法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">     <span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</div><div class="line">     <span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123; <span class="comment">// 遍历Array</span></div><div class="line">          alert(x);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> s) &#123; <span class="comment">// 遍历Set</span></div><div class="line">          alert(x);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> m) &#123; <span class="comment">// 遍历Map</span></div><div class="line">          alert(x[<span class="number">0</span>] + <span class="string">'='</span> + x[<span class="number">1</span>]);<span class="comment">//1=x，2=y，3=z</span></div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>你可能会有疑问，<code>for ... of</code>循环和<code>for ... in</code>循环有何区别？<br><code>for ... in</code>循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。当我们手动给Array对象添加了额外的属性后，<code>for ... in</code>循环将带来意想不到的意外效果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">     a.name = <span class="string">'Hello'</span>;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> a) &#123;</div><div class="line">          alert(x); <span class="comment">// '0', '1', '2', 'name'，x是属性的名称，对于数组来说，它每个元素的索引被视为属性名称</span></div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p><code>for ... in</code>循环将把name包括在内，但Array的length属性却不包括在内。<code>for ... of</code>循环则完全修复了这些问题，它只循环集合本身的元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">     a.name = <span class="string">'Hello'</span>;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123;</div><div class="line">         <span class="comment">//只循环集合本身的元素</span></div><div class="line"></div><div class="line">          alert(x); <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span></div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>然而，更好的方式是直接使用<code>iterable</code>内置的<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数。以<code>Array</code>为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">     a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, array</span>) </span>&#123;</div><div class="line">          <span class="comment">// element: 指向当前元素的值</span></div><div class="line">          <span class="comment">// index: 指向当前索引</span></div><div class="line">          <span class="comment">// array: 指向Array对象本身</span></div><div class="line">          alert(element);</div><div class="line">     &#125;);</div></pre></td></tr></table></figure>
<p><b style="color:red;">注意，forEach()方法是ES5.1标准引入的，你需要测试浏览器是否支持。</b><br>Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</div><div class="line">     s.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, sameElement, set</span>) </span>&#123;</div><div class="line">          alert(element);</div><div class="line">     &#125;);</div></pre></td></tr></table></figure></p>
<p>Map的回调函数参数依次为value、key和map本身：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</div><div class="line">     m.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key, map</span>) </span>&#123;</div><div class="line">          alert(value);</div><div class="line">     &#125;);</div></pre></td></tr></table></figure></p>
<p>如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得Array的element：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">     a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</div><div class="line">          alert(element);</div><div class="line">     &#125;);</div></pre></td></tr></table></figure></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><hr>
<h2 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h2><ul>
<li><p>定义函数<br>   在JavaScript中，定义函数的方式如下：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">               <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</div><div class="line">                   <span class="keyword">return</span> x;</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   <span class="keyword">return</span> -x;</div><div class="line">               &#125;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
<p>   上述<code>abs()</code>函数的定义如下：</p>
<ul>
<li><code>function</code>指出这是一个函数定义；</li>
<li><code>abs</code>是函数的名称；</li>
<li><code>(x)</code>括号内列出函数的参数，多个参数以<code>,</code>分隔；</li>
<li><p><code>{ ... }</code>之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。<br>请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。 如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined。<br>第二种定义函数的方式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">               <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</div><div class="line">                   <span class="keyword">return</span> x;</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   <span class="keyword">return</span> -x;</div><div class="line">               &#125;</div><div class="line">          &#125;;</div></pre></td></tr></table></figure>
<p>在这种方式下，<code>function (x) { ... }</code>是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量<code>abs</code>，所以，通过变量<code>abs</code>就可以调用该函数。<br><b style="color:red;">上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。</b></p>
</li>
</ul>
</li>
<li><p>调用函数<br>  调用函数时，按顺序传入参数即可：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          abs(<span class="number">10</span>); <span class="comment">// 返回10</span></div><div class="line">          abs(<span class="number">-9</span>); <span class="comment">// 返回9</span></div></pre></td></tr></table></figure>
<p>  由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          abs(<span class="number">10</span>, <span class="string">'blablabla'</span>); <span class="comment">// 返回10</span></div><div class="line">          abs(<span class="number">-9</span>, <span class="string">'haha'</span>, <span class="string">'hehe'</span>, <span class="literal">null</span>); <span class="comment">// 返回9</span></div></pre></td></tr></table></figure>
<p>  传入的参数比定义的少也没有问题：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          abs(); <span class="comment">// 返回NaN</span></div></pre></td></tr></table></figure>
<p>  此时<code>abs(x)</code>函数的参数<code>x</code>将收到<code>undefined</code>，计算结果为<code>NaN</code>。<br>  要避免收到<code>undefined</code>，可以对参数进行检查：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">               <span class="keyword">if</span> (<span class="keyword">typeof</span> x !== <span class="string">'number'</span>) &#123;</div><div class="line">                   <span class="keyword">throw</span> <span class="string">'Not a number'</span>;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</div><div class="line">                   <span class="keyword">return</span> x;</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   <span class="keyword">return</span> -x;</div><div class="line">               &#125;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>arguments<br>  JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">               alert(x); <span class="comment">// 10</span></div><div class="line">               <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</div><div class="line">                   alert(<span class="built_in">arguments</span>[i]); <span class="comment">// 10, 20, 30</span></div><div class="line">               &#125;</div><div class="line">          &#125;</div><div class="line">          foo(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</div></pre></td></tr></table></figure>
<p>  利用arguments，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</div><div class="line">                   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">var</span> x = <span class="built_in">arguments</span>[<span class="number">0</span>];</div><div class="line">               <span class="keyword">return</span> x &gt;= <span class="number">0</span> ? x : -x;</div><div class="line">          &#125;</div><div class="line">          abs(); <span class="comment">// 0</span></div><div class="line">          abs(<span class="number">10</span>); <span class="comment">// 10</span></div><div class="line">          abs(<span class="number">-9</span>); <span class="comment">// 9</span></div></pre></td></tr></table></figure>
<p>  <b style="color:red;">利用arguments参数实现可选参数的函数：</b></p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">          <span class="comment">// foo(a[, b], c)</span></div><div class="line">          <span class="comment">// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：</span></div><div class="line">         <span class="comment">// 要把中间的参数b变为“可选”参数，就只能通过arguments判断，然后重新调整参数并赋值。</span></div><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">               <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</div><div class="line">                   <span class="comment">// 实际拿到的参数是a和b，c为undefined</span></div><div class="line">                   c = b; <span class="comment">// 把b赋给c</span></div><div class="line">                   b = <span class="literal">null</span>; <span class="comment">// b变为默认值</span></div><div class="line">               &#125;</div><div class="line">               <span class="comment">// ...</span></div><div class="line">          &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>rest参数（<b style="color:red;">ES6引入</b>）<br>  ES6标准引入了rest参数，可以获取除已定义的其他传入参数组成的数组：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</div><div class="line">               <span class="built_in">console</span>.log(<span class="string">'a = '</span> + a);</div><div class="line">               <span class="built_in">console</span>.log(<span class="string">'b = '</span> + b);</div><div class="line">               <span class="built_in">console</span>.log(rest);</div><div class="line">          &#125;  </div><div class="line">          foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</div><div class="line">          <span class="comment">// 结果:</span></div><div class="line">          <span class="comment">// a = 1</span></div><div class="line">          <span class="comment">// b = 2</span></div><div class="line">          <span class="comment">// Array [ 3, 4, 5 ]</span></div><div class="line">          foo(<span class="number">1</span>);</div><div class="line">          <span class="comment">// 结果:</span></div><div class="line">          <span class="comment">// a = 1</span></div><div class="line">          <span class="comment">// b = undefined</span></div><div class="line">          <span class="comment">// Array []</span></div></pre></td></tr></table></figure>
<p>  用<code>rest</code>参数编写一个<code>sum()</code>函数，接收任意个参数并返回它们的和：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...rest</span>) </span>&#123;</div><div class="line">             <span class="keyword">var</span> sum = <span class="number">0</span>;</div><div class="line">             <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> rest) &#123;</div><div class="line">               sum += i;     </div><div class="line">             &#125;</div><div class="line">             <span class="keyword">return</span> sum;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>小心你的return语句<br> 前面我们讲到了JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> &#123; name: <span class="string">'foo'</span> &#125;;</div><div class="line">          &#125;</div><div class="line">          foo(); <span class="comment">// &#123; name: 'foo' &#125;</span></div></pre></td></tr></table></figure>
<p> 如果把return语句拆成两行：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span>         <span class="regexp">/ /</span> 自动添加了分号，相当于<span class="keyword">return</span> <span class="literal">undefined</span>;</div><div class="line">                   &#123; name: <span class="string">'foo'</span> &#125;;   <span class="comment">// 这行语句已经没法执行到了</span></div><div class="line">          &#125;</div><div class="line">          foo(); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p> 所以正确的多行写法是：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> &#123; <span class="comment">// 这里不会自动加分号，因为&#123;表示语句尚未结束</span></div><div class="line">                   name: <span class="string">'foo'</span></div><div class="line">               &#125;;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><ul>
<li>基础知识<br>在JavaScript中，用var申明的变量实际上是有作用域的。<br>1、如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量：<br>2、如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响：<br>3、由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行：<br>4、JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。</li>
<li><p>变量提升<br>   JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;</div><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> x = <span class="string">'Hello, '</span> + y;</div><div class="line">               a lert(x);</div><div class="line">               <span class="keyword">var</span> y = <span class="string">'Bob'</span>;</div><div class="line">          &#125;</div><div class="line">          foo();</div></pre></td></tr></table></figure>
<p>   虽然是strict模式，但语句var x = ‘Hello, ‘ + y;并不报错，原因是变量y在稍后申明了。但是alert显示Hello, undefined，说明变量y的值为undefined。这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。<br>对于上述foo()函数，JavaScript引擎看到的代码相当于：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> y; <span class="comment">// 提升变量y的申明</span></div><div class="line">               <span class="keyword">var</span> x = <span class="string">'Hello, '</span> + y;</div><div class="line">               alert(x);</div><div class="line">               y = <span class="string">'Bob'</span>;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
<p>   由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个var申明函数内部用到的所有变量：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="comment">//JS引擎在认为可以加分号的地方自动加分号，这里不会自动加分号</span></div><div class="line">               <span class="keyword">var</span></div><div class="line">                   x = <span class="number">1</span>, <span class="comment">// x初始化为1</span></div><div class="line">                   y = x + <span class="number">1</span>, <span class="comment">// y初始化为2</span></div><div class="line">                   z, i; <span class="comment">// z和i为undefined</span></div><div class="line">               <span class="comment">// 其他语句:</span></div><div class="line">               f or (i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;      </div><div class="line">               &#125;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>全局作用域<br>   不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;  </div><div class="line">          <span class="keyword">var</span> course = <span class="string">'Learn JavaScript'</span>;</div><div class="line">          alert(course); <span class="comment">// 'Learn JavaScript'</span></div><div class="line">          alert(<span class="built_in">window</span>.course); <span class="comment">// 'Learn JavaScript'</span></div></pre></td></tr></table></figure>
<p>   因此，直接访问全局变量course和访问window.course是完全一样的。同理，全局定义的函数也可以通过<code>window.functionName()</code>方式调用。<br>进一步大胆地猜测，我们每次直接调用的alert()函数其实也是window的一个变量：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;  </div><div class="line">          <span class="built_in">window</span>.alert(<span class="string">'调用window.alert()'</span>);</div><div class="line">          <span class="comment">// 把alert保存到另一个变量:</span></div><div class="line">          <span class="keyword">var</span> old_alert = <span class="built_in">window</span>.alert;</div><div class="line">          <span class="comment">// 给alert赋一个新函数:</span></div><div class="line">          <span class="built_in">window</span>.alert = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line">          alert(<span class="string">'无法用alert()显示了!'</span>);</div><div class="line">          <span class="comment">// 恢复alert:</span></div><div class="line">          <span class="built_in">window</span>.alert = old_alert;</div><div class="line">          alert(<span class="string">'又可以用alert()了!'</span>);</div></pre></td></tr></table></figure>
<p>   这说明JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。</p>
</li>
<li><p>名字空间<br>   全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。 减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">          <span class="comment">// 唯一的全局变量MYAPP:</span></div><div class="line">          <span class="keyword">var</span> MYAPP = &#123;&#125;;  </div><div class="line">          <span class="comment">// 其他变量:</span></div><div class="line">          MYAPP.name = <span class="string">'myapp'</span>;</div><div class="line">          MYAPP.version = <span class="number">1.0</span>;</div><div class="line">          <span class="comment">// 其他函数:</span></div><div class="line">          MYAPP.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> <span class="string">'foo'</span>;</div><div class="line">          &#125;;</div></pre></td></tr></table></figure>
<p>   把自己的代码全部放入唯一的名字空间MYAPP中，会大大减少全局变量冲突的可能。 许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。</p>
</li>
<li><p>局部作用域<br>   由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;</div><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</div><div class="line">                   <span class="comment">//</span></div><div class="line">               &#125;</div><div class="line">               i += <span class="number">100</span>; <span class="comment">// 仍然可以引用变量i</span></div><div class="line">          &#125;</div></pre></td></tr></table></figure>
<p>   为了解决块级作用域，<b style="color:red;">ES6引入了新的关键字let</b>，用let替代var可以申明一个块级作用域的变量：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;  </div><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> sum = <span class="number">0</span>;</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</div><div class="line">                   sum += i;</div><div class="line">               &#125;</div><div class="line">               i += <span class="number">1</span>; <span class="comment">// SyntaxError</span></div><div class="line">          &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>常量<br>  由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> PI = <span class="number">3.14</span>;</div></pre></td></tr></table></figure>
<p>  <b style="color:red;">ES6标准引入了新的关键字const来定义常量</b>，const与let都具有块级作用域：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;</div><div class="line">          <span class="keyword">const</span> PI = <span class="number">3.14</span>;</div><div class="line">          PI = <span class="number">3</span>; <span class="comment">// 某些浏览器不报错，但是无效果！</span></div><div class="line">          PI; <span class="comment">// 3.14</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li><p>方法与<code>this</code><br>  在一个对象中绑定函数，称为这个对象的方法。<br>  如果我们给xiaoming绑定一个函数，就可以做更多的事情。比如，写个age()方法，返回xiaoming的年龄：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">               name: <span class="string">'小明'</span>,</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">                   <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">               &#125;</div><div class="line">          &#125;;</div><div class="line">          xiaoming.age; <span class="comment">// function xiaoming.age()，this指向xiaoming这个对象，即指向函数所属对象，即指向函数的调用者</span></div><div class="line">          xiaoming.age(); <span class="comment">// 今年调用是25,明年调用就变成26了</span></div></pre></td></tr></table></figure>
<p>  在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。<br>  让我们拆开写：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">               <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">                name: <span class="string">'小明'</span>,</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               age: getAge</div><div class="line">          &#125;;  </div><div class="line">          xiaoming.age(); <span class="comment">// 25, 正常结果</span></div><div class="line">          getAge(); <span class="comment">// NaN</span></div></pre></td></tr></table></figure>
<p>  单独调用函数getAge()怎么返回了<code>NaN</code>？上面说了，<code>this</code>即指向函数的调用者，<code>getAge()</code>等价于<code>window.getAge()</code>，所以当调 用<code>getAge()</code>方法时，<code>this</code>指向window对象。<br>  由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在strict模式下让函数的this指向undefined，因此，在strict模式下，你会得到一个错误：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;  </div><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">               name: <span class="string">'小明'</span>,</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">                   <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">               &#125;</div><div class="line">          &#125;;</div><div class="line">          <span class="keyword">var</span> fn = xiaoming.age;</div><div class="line">          fn(); <span class="comment">// Uncaught TypeError: Cannot read property 'birth' of undefined</span></div></pre></td></tr></table></figure>
<p>  有些时候，喜欢重构的你把方法重构了一下：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;</div><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">               name: <span class="string">'小明'</span>,</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                       <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">                       <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">                   &#125;</div><div class="line">                   <span class="keyword">return</span> getAgeFromBirth();</div><div class="line">               &#125;</div><div class="line">          &#125;;  </div><div class="line">          xiaoming.age(); <span class="comment">// Uncaught TypeError: Cannot read property 'birth' of undefined</span></div></pre></td></tr></table></figure>
<p>  结果又报错了！原因是this指针只在age方法的函数内指向xiaoming，在函数内部定义的函数，this又指向undefined了！（在非strict模式下，它重新指向全局对象window！）<br>  修复的方法，我们用一个that变量首先捕获this：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;  </div><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">               name: <span class="string">'小明'</span>,</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   <span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">// 在方法内部一开始就捕获this</span></div><div class="line">                   <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                       <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">                       <span class="keyword">return</span> y - that.birth; <span class="comment">// 用that而不是this</span></div><div class="line">                   &#125;</div><div class="line">                   <span class="keyword">return</span> getAgeFromBirth();</div><div class="line">               &#125;</div><div class="line">          &#125;;</div><div class="line">          xiaoming.age(); <span class="comment">// 25</span></div></pre></td></tr></table></figure>
</li>
<li><p>apply<br>  虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！<br>  要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。<br>  用<code>apply</code>修复<code>getAge()</code>调用：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">               <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">               name: <span class="string">'小明'</span>,</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               age: getAge</div><div class="line">          &#125;;  </div><div class="line">          xiaoming.age(); <span class="comment">// 25</span></div><div class="line">          getAge.apply(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></div></pre></td></tr></table></figure>
<p>  另一个与<code>apply()</code>类似的方法是<code>call()</code>，唯一区别是：</p>
<ul>
<li><code>apply()</code>把参数打包成<code>Array</code>再传入；</li>
<li><p><code>call()</code>把参数按顺序传入。<br>比如调用<code>Math.max(3, 5, 4)</code>，分别用<code>apply()</code>和<code>call()</code>实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]); <span class="comment">// 5</span></div><div class="line">          <span class="built_in">Math</span>.max.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p>对普通函数调用，我们通常把<code>this</code>绑定为<code>null</code>。</p>
</li>
</ul>
</li>
<li>装饰器<br>  利用<code>apply()</code>，我们还可以动态改变函数的行为。<br>  JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。<br>  现在假定我们想统计一下代码一共调用了多少次<code>parseInt()</code>，可以把所有的调用都找出来，然后手动加上<code>count += 1</code>，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的<code>parseInt()</code>：  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line">          <span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>; <span class="comment">// 保存原函数</span></div><div class="line">          <span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">               count += <span class="number">1</span>;</div><div class="line">               <span class="keyword">return</span> oldParseInt.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用原函数</span></div><div class="line">          &#125;;</div><div class="line">          <span class="comment">// 测试:</span></div><div class="line">          <span class="built_in">parseInt</span>(<span class="string">'10'</span>);</div><div class="line">          <span class="built_in">parseInt</span>(<span class="string">'20'</span>);</div><div class="line">          <span class="built_in">parseInt</span>(<span class="string">'30'</span>);</div><div class="line">          count; <span class="comment">// 3</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。<br>一个最简单的高阶函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">     <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, f</span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> f(x) + f(y);</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>当我们调用<code>add(-5, 6, Math.abs)</code>时，参数<code>x</code>，<code>y</code>和<code>f</code>分别接收<code>-5</code>，<code>6</code>和函数<code>Math.abs</code>，根据函数定义，我们可以推导计算过程为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     x = <span class="number">-5</span>;</div><div class="line">     y = <span class="number">6</span>;</div><div class="line">     f = <span class="built_in">Math</span>.abs;</div><div class="line">     f(x) + f(y) ==&gt; <span class="built_in">Math</span>.abs(<span class="number">-5</span>) + <span class="built_in">Math</span>.abs(<span class="number">6</span>) ==&gt; <span class="number">11</span>;</div><div class="line">     <span class="keyword">return</span> <span class="number">11</span>;</div></pre></td></tr></table></figure></p>
<h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h3><ul>
<li><p>map<br>  举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个数组[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map实现如下：<br>  由于<code>map()</code>方法定义在JavaScript的<code>Array</code>中，我们调用<code>Array</code>的<code>map()</code>方法，传入我们自己的函数，就得到了一个新的<code>Array</code>作为结果：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> x * x;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</div><div class="line">          arr.map(pow); <span class="comment">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></div></pre></td></tr></table></figure>
<p>  <code>map()</code>传入的参数是<code>pow</code>，即函数对象本身。<br>  map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把Array的所有数字转为字符串：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</div><div class="line">          arr.map(<span class="built_in">String</span>); <span class="comment">// ['1', '2', '3', '4', '5', '6', '7', '8', '9']</span></div></pre></td></tr></table></figure>
</li>
<li><p>reduce<br>  Array的reduce()把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          [x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4);</div></pre></td></tr></table></figure>
<p>  比方说对一个Array求和，就可以用reduce实现：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</div><div class="line">         <span class="keyword">var</span> sum =  arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> x + y;</div><div class="line">          &#125;); <span class="comment">// 25</span></div><div class="line">         <span class="keyword">return</span> sum;</div></pre></td></tr></table></figure>
<p>  要把[1, 3, 5, 7, 9]变换成整数13579，reduce()也能派上用场：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</div><div class="line">          arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> x * <span class="number">10</span> + y;</div><div class="line">          &#125;); <span class="comment">// 13579</span></div></pre></td></tr></table></figure>
<p>  <b>请把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[‘adam’, ‘LISA’, ‘barT’]，输出：[‘Adam’, ‘Lisa’, ‘Bart’]。</b></p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;</div><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">normalize</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</div><div class="line">                   <span class="keyword">return</span>  s.slice(<span class="number">0</span>,<span class="number">1</span>).toUpperCase() + s.slice(<span class="number">1</span>).toLowerCase();</div><div class="line">               &#125;);</div><div class="line">          &#125;</div><div class="line">            <span class="comment">// 测试:</span></div><div class="line">          <span class="keyword">if</span> (normalize([<span class="string">'adam'</span>, <span class="string">'LISA'</span>, <span class="string">'barT'</span>]).toString() === [<span class="string">'Adam'</span>, <span class="string">'Lisa'</span>, <span class="string">'Bart'</span>].toString()) &#123;</div><div class="line">               alert(<span class="string">'测试通过!'</span>);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">               alert(<span class="string">'测试失败!'</span>);</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p><code>filter</code>也是一个常用的操作，它用于把<code>Array</code>的某些元素过滤掉，然后返回剩下的元素。 和<code>map()</code>类似，<code>Array</code>的<code>filter()</code>也接收一个函数。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>true</code>还是<code>false</code>决定保留还是丢弃该元素。<br>例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>];</div><div class="line">     <span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> x % <span class="number">2</span> !== <span class="number">0</span>;</div><div class="line">     &#125;);</div><div class="line">     r; <span class="comment">// [1, 5, 9, 15]</span></div></pre></td></tr></table></figure></p>
<p>把一个<code>Array</code>中的空字符串删掉，可以这么写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">''</span>, <span class="string">'B'</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="string">'C'</span>, <span class="string">'  '</span>];</div><div class="line">     <span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> s &amp;&amp; s.trim(); <span class="comment">// 注意：IE9以下的版本没有trim()方法</span></div><div class="line">     &#125;);</div><div class="line">     r; <span class="comment">// ['A', 'B', 'C']</span></div></pre></td></tr></table></figure></p>
<p><b>练习：请尝试用filter()筛选出素数：</b><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">     <span class="string">'use strict'</span>;</div><div class="line">     <span class="function"><span class="keyword">function</span> <span class="title">get_primes</span>(<span class="params">arr</span>) </span>&#123;  </div><div class="line">          <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">             <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">2</span> ; i &lt; x ; i++)&#123;</div><div class="line">                 <span class="keyword">if</span>(x % i === <span class="number">0</span>)&#123;</div><div class="line">                      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">return</span> x === <span class="number">1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</div><div class="line">          &#125;);</div><div class="line">     &#125;</div><div class="line">     <span class="comment">// 测试:</span></div><div class="line">     <span class="keyword">var</span></div><div class="line">          x,</div><div class="line">          r,</div><div class="line">          arr = [];</div><div class="line">     <span class="keyword">for</span> (x = <span class="number">1</span>; x &lt; <span class="number">100</span>; x++) &#123;</div><div class="line">          arr.push(x);</div><div class="line">     &#125;</div><div class="line">     r = get_primes(arr);</div><div class="line">     <span class="keyword">if</span> (r.toString() === [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>].toString()) &#123;</div><div class="line">          alert(<span class="string">'测试通过!'</span>);</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">          alert(<span class="string">'测试失败: '</span> + r.toString());</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个对象呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。<br>JavaScript的<code>Array</code>的<code>sort()</code>方法就是用于排序的，但是排序结果可能让你大吃一惊：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">// 看上去正常的结果:</span></div><div class="line">     [<span class="string">'Google'</span>, <span class="string">'Apple'</span>, <span class="string">'Microsoft'</span>].sort(); <span class="comment">// ['Apple', 'Google', 'Microsoft'];</span></div><div class="line">     <span class="comment">// apple排在了最后:</span></div><div class="line">     [<span class="string">'Google'</span>, <span class="string">'apple'</span>, <span class="string">'Microsoft'</span>].sort(); <span class="comment">// ['Google', 'Microsoft", 'apple']  </span></div><div class="line">     <span class="comment">// 无法理解的结果:</span></div><div class="line">     [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>].sort(); <span class="comment">// [1, 10, 2, 20]</span></div></pre></td></tr></table></figure></p>
<p>第二个排序把apple排在了最后，是因为字符串根据ASCII码进行排序，而小写字母a的ASCII码在大写字母之后。<br>第三个排序因为<code>Array</code>的<code>sort()</code>方法默认把所有元素先转换为String再排序，结果<code>&#39;10&#39;</code>排在了<code>&#39;2&#39;</code>的前面，因为字符<code>&#39;1&#39;</code>比字符<code>&#39;2&#39;</code>的ASCII码小。<br>如果不知道sort()方法的默认排序规则，直接对数字排序，绝对栽进坑里！幸运的是，sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。<br>要按数字大小排序，我们可以这么写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</div><div class="line">     arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">          <span class="keyword">if</span> (x &lt; y) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span> (x &gt; y) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">     &#125;); <span class="comment">// [1, 2, 10, 20]</span></div></pre></td></tr></table></figure></p>
<p>默认情况下，对字符串排序，是按照ASCII的大小比较的，现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> arr = [<span class="string">'Google'</span>, <span class="string">'apple'</span>, <span class="string">'Microsoft'</span>];</div><div class="line">     arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">s1, s2</span>) </span>&#123;</div><div class="line">          x1 = s1.toUpperCase();</div><div class="line">          x2 = s2.toUpperCase();</div><div class="line">          <span class="keyword">if</span> (x1 &lt; x2) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span> (x1 &gt; x2) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">     &#125;); <span class="comment">// ['apple', 'Google', 'Microsoft']</span></div></pre></td></tr></table></figure></p>
<p>最后友情提示，sort()方法会直接对Array进行修改，它返回的结果仍是当前Array：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> a1 = [<span class="string">'B'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>];</div><div class="line">     <span class="keyword">var</span> a2 = a1.sort();</div><div class="line">     a1; <span class="comment">// ['A', 'B', 'C']</span></div><div class="line">     a2; <span class="comment">// ['A', 'B', 'C']</span></div><div class="line">     a1 === a2; <span class="comment">// true, a1和a2是同一对象</span></div></pre></td></tr></table></figure></p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li><p>函数作为返回值<br>  高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。我们来实现一个对<code>Array</code>的求和，不返回求和的结果，而是返回求和的函数！</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">lazy_sum</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">                       <span class="keyword">return</span> x + y;</div><div class="line">                   &#125;);</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">return</span> sum;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
<p>  当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> f = lazy_sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// function sum()</span></div></pre></td></tr></table></figure>
<p>  调用函数<code>f</code>时，才真正计算求和的结果：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          f(); <span class="comment">// 15</span></div></pre></td></tr></table></figure>
<p>  在这个例子中，我们在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。<br>  请再注意一点，当我们调用<code>lazy_sum()</code>时，每次调用都会返回一个新的函数，即使传入相同的参数：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> f1 = lazy_sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</div><div class="line">          <span class="keyword">var</span> f2 = lazy_sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</div><div class="line">          f1 === f2; <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>  <code>f1()</code>和<code>f2()</code>的调用结果互不影响。</p>
</li>
<li><p>闭包<br>  注意到返回的函数在其定义内部引用了局部变量arr，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。<br>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> arr = [];</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</div><div class="line">                    <span class="comment">// 每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了。</span></div><div class="line">                   arr.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                       <span class="keyword">return</span> i * i;</div><div class="line">                   &#125;);</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">return</span> arr;</div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">var</span> results = count();</div><div class="line">          <span class="keyword">var</span> f1 = results[<span class="number">0</span>];</div><div class="line">          <span class="keyword">var</span> f2 = results[<span class="number">1</span>];</div><div class="line">          <span class="keyword">var</span> f3 = results[<span class="number">2</span>];</div><div class="line">          <span class="comment">//原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了4，因此最终结果为16。</span></div><div class="line">          f1(); <span class="comment">// 16</span></div><div class="line">          f2(); <span class="comment">// 16</span></div><div class="line">          f3(); <span class="comment">// 16</span></div></pre></td></tr></table></figure>
<p>  <b>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</b><br>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> arr = [];</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</div><div class="line">                   arr.push((<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">                       <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                           <span class="keyword">return</span> n * n;</div><div class="line">                       &#125;</div><div class="line">                   &#125;)(i));</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">return</span> arr;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">var</span> results = count();</div><div class="line">          <span class="keyword">var</span> f1 = results[<span class="number">0</span>];</div><div class="line">          <span class="keyword">var</span> f2 = results[<span class="number">1</span>];</div><div class="line">          <span class="keyword">var</span> f3 = results[<span class="number">2</span>];  </div><div class="line">          f1(); <span class="comment">// 1</span></div><div class="line">          f2(); <span class="comment">// 4</span></div><div class="line">          f3(); <span class="comment">// 9</span></div></pre></td></tr></table></figure>
<p>  注意这里用了一个“创建一个匿名函数并立刻执行”的语法：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          (<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> x * x;</div><div class="line">          &#125;)(<span class="number">3</span>); <span class="comment">// 9</span></div></pre></td></tr></table></figure>
<p>  理论上讲，创建一个匿名函数并立刻执行可以这么写：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x * x &#125; (<span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>  但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          (<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x * x &#125;) (<span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>  闭包的实际运用:<br>  在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用<code>private</code>修饰一个成员变量。在没有<code>class</code>机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;  </div><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">create_counter</span>(<span class="params">initial</span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> x = initial || <span class="number">0</span>;</div><div class="line">               <span class="keyword">return</span> &#123;</div><div class="line">                   inc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                       x += <span class="number">1</span>;</div><div class="line">                       <span class="keyword">return</span> x;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
<p>  它用起来像这样：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> c1 = create_counter();</div><div class="line">          c1.inc(); <span class="comment">// 1</span></div><div class="line">          c1.inc(); <span class="comment">// 2</span></div><div class="line">          c1.inc(); <span class="comment">// 3</span></div><div class="line">          <span class="keyword">var</span> c2 = create_counter(<span class="number">10</span>);</div><div class="line">          c2.inc(); <span class="comment">// 11</span></div><div class="line">          c2.inc(); <span class="comment">// 12</span></div><div class="line">          c2.inc(); <span class="comment">// 13</span></div></pre></td></tr></table></figure>
<p>  在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。<br>闭包还可以把多参数的函数变成单参数的函数。例如，要计算xy可以用<code>Math.pow(x, y)</code>函数，不过考虑到经常计算x2或x3，我们可以利用闭包创建新的函数<code>pow2</code>和<code>pow3</code>：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">make_pow</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">                   <span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, n);</div><div class="line">               &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// 创建两个新函数:</span></div><div class="line">          <span class="keyword">var</span> pow2 = make_pow(<span class="number">2</span>);</div><div class="line">          <span class="keyword">var</span> pow3 = make_pow(<span class="number">3</span>);  </div><div class="line">          pow2(<span class="number">5</span>); <span class="comment">// 25</span></div><div class="line">          pow3(<span class="number">7</span>); <span class="comment">// 343</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="箭头函数-ES6新增"><a href="#箭头函数-ES6新增" class="headerlink" title="箭头函数(ES6新增)"></a>箭头函数(ES6新增)</h2><p>ES6标准新增了一种新的函数：Arrow Function（箭头函数）。<br>为什么叫Arrow Function？因为它的定义用的就是一个箭头：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">    x =&gt; x * x</div></pre></td></tr></table></figure></p>
<p>上面的箭头函数相当于：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">     <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> x * x;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>在继续学习箭头函数之前，请测试你的浏览器是否支持ES6的Arrow Function：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    <span class="string">'use strict'</span>;</div><div class="line">    <span class="keyword">var</span> fn = x =&gt; x * x;</div><div class="line">    alert(<span class="string">'你的浏览器支持ES6的Arrow Function!'</span>);</div></pre></td></tr></table></figure></p>
<p>箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连<code>{ ... }</code>和<code>return</code>都省略掉了。还有一种可以包含多条语句，这时候就不能省略<code>{ ... }</code>和<code>return</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">     x =&gt; &#123;</div><div class="line">          <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</div><div class="line">              <span class="keyword">return</span> x * x;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">else</span> &#123;</div><div class="line">              <span class="keyword">return</span> - x * x;</div><div class="line">          &#125;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>如果参数不是一个，就需要用括号()括起来：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">// 两个参数:</span></div><div class="line">     (x, y) =&gt; x * x + y * y</div><div class="line">    <span class="comment">//上例相当于</span></div><div class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>)</span>&#123;</div><div class="line">         <span class="keyword">return</span> x * x + y * y;</div><div class="line">     &#125;  </div><div class="line">     <span class="comment">// 无参数:</span></div><div class="line">     () =&gt; <span class="number">3.14</span></div><div class="line">    <span class="comment">//上例相当于</span></div><div class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">         <span class="keyword">return</span> <span class="number">3.14</span>;</div><div class="line">     &#125;  </div><div class="line">     <span class="comment">// 可变参数:</span></div><div class="line">     (x, y, ...rest) =&gt; &#123;</div><div class="line">          <span class="keyword">var</span> i, sum = x + y;</div><div class="line">          <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;rest.length; i++) &#123;</div><div class="line">              sum += rest[i];</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> sum;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">// SyntaxError:</span></div><div class="line">     x =&gt; &#123; foo: x &#125;</div></pre></td></tr></table></figure></p>
<p>因为和函数体的<code>{ ... }</code>有语法冲突，所以要改为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">// ok:</span></div><div class="line">     x =&gt; (&#123; foo: x &#125;)</div></pre></td></tr></table></figure></p>
<ul>
<li><p>this<br>   箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。 回顾前面的例子，由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> obj = &#123;</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></div><div class="line">                   <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                       <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向window或undefined</span></div><div class="line">                   &#125;;</div><div class="line">                   <span class="keyword">return</span> fn();</div><div class="line">               &#125;</div><div class="line">          &#125;;</div></pre></td></tr></table></figure>
<p>  现在，箭头函数完全修复了<code>this</code>的指向，<code>this</code>总是指向词法作用域，也就是外层调用者<code>obj</code>：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> obj = &#123;</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></div><div class="line">                   <span class="keyword">var</span> fn = () =&gt; <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向obj对象</span></div><div class="line">                   <span class="keyword">return</span> fn();</div><div class="line">               &#125;</div><div class="line">          &#125;;</div><div class="line">          obj.getAge(); <span class="comment">// 25</span></div></pre></td></tr></table></figure>
<p>  如果使用箭头函数，以前的那种hack写法：<code>var that = this;</code> 就不再需要了。<br>  由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> obj = &#123;</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               getAge: <span class="function"><span class="keyword">function</span> (<span class="params">year</span>) </span>&#123;</div><div class="line">                   <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></div><div class="line">                   <span class="keyword">var</span> fn = (y) =&gt; y - <span class="keyword">this</span>.birth; <span class="comment">// this.birth仍是1990</span></div><div class="line">                   <span class="keyword">return</span> fn.call(&#123;birth:<span class="number">2000</span>&#125;, year); <span class="comment">//第一个参数被忽略</span></div><div class="line">               &#125;</div><div class="line">          &#125;;</div><div class="line">          obj.getAge(<span class="number">2015</span>); <span class="comment">// 25</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h1><hr>
<p>在JavaScript的世界里，一切都是对象。<br>但是某些对象还是和其他对象不太一样。为了区分对象的类型，我们用typeof操作符获取对象的类型，它总是返回一个字符串：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// 'number'</span></div><div class="line">     <span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// 'number'</span></div><div class="line">     <span class="keyword">typeof</span> <span class="string">'str'</span>; <span class="comment">// 'string'</span></div><div class="line">     <span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// 'boolean'</span></div><div class="line">     <span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// 'undefined'</span></div><div class="line">     <span class="keyword">typeof</span> <span class="built_in">Math</span>.abs; <span class="comment">// 'function'</span></div><div class="line">     <span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// 'object'</span></div><div class="line">     <span class="keyword">typeof</span> []; <span class="comment">// 'object'</span></div><div class="line">     <span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// 'object'</span></div></pre></td></tr></table></figure></p>
<p>可见，<code>number</code>、<code>string</code>、<code>boolean</code>、<code>function</code>和<code>undefined</code>有别于其他类型。特别注意<code>null</code>的类型是<code>object</code>，<code>Array</code>的类型也是<code>object</code>，如果我们用<code>typeof</code>将无法区分出<code>null</code>、<code>Array</code>和通常意义上的object——<code>{}</code>。</p>
<h2 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h2><p><code>number</code>、<code>boolean</code>和<code>string</code>都有包装对象。没错，在JavaScript中，字符串也区分<code>string</code>类型和它的包装类型。包装对象用<code>new</code>创建：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// 123,生成了新的包装类型</span></div><div class="line">          <span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// true,生成了新的包装类型</span></div><div class="line">          <span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>); <span class="comment">// 'str',生成了新的包装类型</span></div></pre></td></tr></table></figure></p>
<p>虽然包装对象看上去和原来的值一模一样，显示出来也是一模一样，但他们的类型已经变为object了！所以，包装对象和原始值用===比较会返回false：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// 'object'</span></div><div class="line">          <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) === <span class="number">123</span>; <span class="comment">// false</span></div><div class="line">          <span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// 'object'</span></div><div class="line">          <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) === <span class="literal">true</span>; <span class="comment">// false  </span></div><div class="line">          <span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>); <span class="comment">// 'object'</span></div><div class="line">          <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>) === <span class="string">'str'</span>; <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>所以闲的蛋疼也不要使用包装对象！尤其是针对string类型！！！<br>如果没有写<code>new</code>关键字，那么<code>Number()</code>、<code>Boolean()</code>和<code>String()</code>被当做普通函数，把任何类型的数据转换为<code>number</code>、<code>boolean</code>和<code>string</code>类型（注意不是其包装类型）。<br>总结一下，有这么几条规则需要遵守：</p>
<ul>
<li>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</li>
<li>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；</li>
<li>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法；</li>
<li>通常不必把任意类型转换为<code>boolean</code>再判断，因为可以直接写<code>if (myVar) {...}</code>；</li>
<li><code>typeof</code>操作符可以判断出<code>number</code>、<code>boolean</code>、<code>string</code>、<code>function</code>和<code>undefined</code>；</li>
<li>判断<code>Array</code>要使用<code>Array.isArray(arr)</code>；</li>
<li>判断<code>null</code>请使用<code>myVar === null</code>；</li>
<li>判断某个全局变量是否存在用<code>typeof window.myVar === &#39;undefined&#39;</code>；</li>
<li>函数内部判断某个变量是否存在用<code>typeof myVar === &#39;undefined&#39;</code>。</li>
</ul>
<h2 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h2><p>在JavaScript中，Date对象用来表示日期和时间。<br>要获取系统当前时间，用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">          now; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></div><div class="line">          now.getFullYear(); <span class="comment">// 2015, 年份</span></div><div class="line">          now.getMonth(); <span class="comment">// 5, 月份，注意月份范围是0~11，5表示六月</span></div><div class="line">          now.getDate(); <span class="comment">// 24, 表示24号</span></div><div class="line">          now.getDay(); <span class="comment">// 3, 表示星期三</span></div><div class="line">          now.getHours(); <span class="comment">// 19, 24小时制</span></div><div class="line">          now.getMinutes(); <span class="comment">// 49, 分钟</span></div><div class="line">          now.getSeconds(); <span class="comment">// 22, 秒</span></div><div class="line">          now.getMilliseconds(); <span class="comment">// 875, 毫秒数</span></div><div class="line">          now.getTime(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></div></pre></td></tr></table></figure></p>
<h2 id="RegExp：正则表达式"><a href="#RegExp：正则表达式" class="headerlink" title="RegExp：正则表达式"></a>RegExp：正则表达式</h2><ul>
<li><p>基本用法</p>
<ul>
<li>在正则表达式中，如果直接给出字符，就是精确匹配。用<code>\d</code>可以匹配一个数字，<code>\w</code>可以匹配一个字母或数字，所以：<code>&#39;00\d&#39;</code>可以匹配<code>&#39;007&#39;</code>，但无法匹配<code>&#39;00A&#39;</code>；<code>&#39;\d\d\d&#39;</code>可以匹配<code>&#39;010&#39;</code></li>
<li><code>.</code>可以匹配任意字符，所以：<code>&#39;js.&#39;</code>可以匹配<code>&#39;jsp&#39;</code>、<code>&#39;jss&#39;</code>、<code>&#39;js!&#39;</code>等等。</li>
<li>要匹配变长的字符，在正则表达式中，用<code>*</code>表示任意个字符（包括0个），用<code>+</code>表示至少一个字符，用<code>?</code>表示0个或1个字符，用<code>{n}</code>表示n个字符，用<code>{n,m}</code>表示n-m个字符：<br> 来看一个复杂的例子：<code>\d{3}\s+\d{3,8}</code>。<br> 1、<code>\d{3}</code>表示匹配3个数字，例如<code>&#39;010&#39;</code>；<br> 2、<code>\s</code>可以匹配一个空格（也包括Tab等空白符），所以<code>\s+</code>表示至少有一个空格，例如匹配<code>&#39; &#39;</code>，<code>&#39;\t\t&#39;</code>等；<br> 3、<code>\d{3,8}</code>表示3-8个数字，例如<code>&#39;1234567&#39;</code>。<br> 综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。<br> 如果要匹配<code>&#39;010-12345&#39;</code>这样的号码呢？由于<code>&#39;-&#39;</code>是特殊字符，在正则表达式中，要用<code>&#39;\&#39;</code>转义，所以，上面的正则是<code>\d{3}\-\d{3,8}</code>。</li>
<li>要做更精确地匹配，可以用<code>[]</code>表示范围，比如：<br> 1、<code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线；<br> 2、<code>[0-9a-zA-Z\_]+</code>可以匹配至少由一个数字、字母或者下划线组成的字符串，比如<code>&#39;a100&#39;</code>，<code>&#39;0_Z&#39;</code>，<code>&#39;js2015&#39;</code>等等；<br> 3、<code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]*</code>可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名；<br> 4、<code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]{0, 19}</code>更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</li>
<li><code>A|B</code>可以匹配A或B，所以<code>[J|j]ava[S|s]cript</code>可以匹配<code>&#39;JavaScript&#39;</code>、<code>&#39;Javascript&#39;</code>、<code>&#39;javaScript&#39;</code>或者<code>&#39;javascript&#39;</code></li>
<li><code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头。</li>
<li><code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结束。</li>
</ul>
</li>
<li><p>在JS中使用正则表达式</p>
<ul>
<li><p>定义与使用<br>第一种方式是直接通过<code>/正则表达式/</code>写出来，第二种方式是通过<code>new RegExp(&#39;正则表达式&#39;)</code>创建一个RegExp对象。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> re1 = <span class="regexp">/ABC\-001/</span>;</div><div class="line">          <span class="keyword">var</span> re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ABC\\-001'</span>);</div></pre></td></tr></table></figure>
<p>简单使用：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> re = <span class="regexp">/^\d&#123;3&#125;\-\d&#123;3,8&#125;$/</span>;</div><div class="line">          re.test(<span class="string">'010-12345'</span>); <span class="comment">// true</span></div><div class="line">          re.test(<span class="string">'010-1234x'</span>); <span class="comment">// false</span></div><div class="line">          re.test(<span class="string">'010 12345'</span>); <span class="comment">// false</span></div></pre></td></tr></table></figure>
</li>
<li><p>切分字符串</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'a b   c'</span>.split(<span class="string">' '</span>); <span class="comment">// ['a', 'b', '', '', 'c']</span></div><div class="line">          <span class="string">'a b   c'</span>.split(<span class="regexp">/\s+/</span>); <span class="comment">// ['a', 'b', 'c']   /\s+/表示一个或多个空格</span></div><div class="line">          <span class="string">'a,b, c  d'</span>.split(<span class="regexp">/[\s\,]+/</span>); <span class="comment">// ['a', 'b', 'c', 'd']  /[\s\,]+/表示一个或多个空格或者逗号</span></div><div class="line">          <span class="string">'a,b;; c  d'</span>.split(<span class="regexp">/[\s\,\;]+/</span>); <span class="comment">// ['a', 'b', 'c', 'd']</span></div></pre></td></tr></table></figure>
</li>
<li><p>分组<br> 除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用<code>()</code>表示的就是要提取的分组（Group）。比如：<br> <code>^(\d{3})-(\d{3,8})$</code>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">            <span class="keyword">var</span> re = <span class="regexp">/^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/</span>;</div><div class="line">            re.exec(<span class="string">'010-12345'</span>); <span class="comment">// ['010-12345', '010', '12345']</span></div><div class="line">            re.exec(<span class="string">'010 12345'</span>); <span class="comment">// null</span></div></pre></td></tr></table></figure>
<p> 如果正则表达式中定义了组，就可以在<code>RegExp</code>对象上用<code>exec()</code>方法提取出子串来。<br> <code>exec()</code>方法在匹配成功后，会返回一个<code>Array</code>，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。<code>exec()</code>方法在匹配失败时返回<code>null</code>。<br> 提取子串非常有用。来看一个更凶残的例子：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">            <span class="keyword">var</span> re = <span class="regexp">/^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/</span>;</div><div class="line">            re.exec(<span class="string">'19:05:30'</span>); <span class="comment">// ['19:05:30', '19', '05', '30']</span></div></pre></td></tr></table></figure>
</li>
<li><p>贪婪匹配<br>需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">        <span class="keyword">var</span> re = <span class="regexp">/^(\d+)(0*)$/</span>;</div><div class="line">        re.exec(<span class="string">'102300'</span>); <span class="comment">// ['102300', '102300', '']</span></div></pre></td></tr></table></figure>
<p>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。<br>必须让<code>\d+</code>采用非贪婪匹配（也就是尽可能少匹配），才能把后面的<code>0</code>匹配出来，加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">        <span class="keyword">var</span> re = <span class="regexp">/^(\d+?)(0*)$/</span>;</div><div class="line">        re.exec(<span class="string">'102300'</span>); <span class="comment">// ['102300', '1023', '00']</span></div></pre></td></tr></table></figure>
</li>
<li><p>全局搜索<br>JavaScript的正则表达式还有几个特殊的标志，最常用的是<code>g</code>，表示全局匹配<br>全局匹配可以多次执行<code>exec()</code>方法来搜索一个匹配的字符串。当我们指定<code>g</code>标志后，每次运行<code>exec()</code>，正则表达式本身会更新<code>lastIndex</code>属性，表示上次匹配到的最后索引：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">        <span class="keyword">var</span> s = <span class="string">'JavaScript, VBScript, JScript and ECMAScript'</span>;</div><div class="line">        <span class="keyword">var</span> re=<span class="regexp">/[a-zA-Z]+Script/g</span>;</div><div class="line">        <span class="comment">// 使用全局匹配:</span></div><div class="line">        re.exec(s); <span class="comment">// ['JavaScript']</span></div><div class="line">        re.lastIndex; <span class="comment">// 10 </span></div><div class="line">        re.exec(s); <span class="comment">// ['VBScript']</span></div><div class="line">        re.lastIndex; <span class="comment">// 20</span></div><div class="line">        re.exec(s); <span class="comment">// ['JScript']</span></div><div class="line">        re.lastIndex; <span class="comment">// 29 </span></div><div class="line">        re.exec(s); <span class="comment">// ['ECMAScript']</span></div><div class="line">        re.lastIndex; <span class="comment">// 44 </span></div><div class="line">        re.exec(s); <span class="comment">// null，直到结束仍没有匹配到</span></div></pre></td></tr></table></figure>
<p>正则表达式还可以指定i标志，表示忽略大小写，m标志，表示执行多行匹配。</p>
</li>
</ul>
</li>
</ul>
<h2 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h2><ul>
<li><p>序列化</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">            <span class="keyword">var</span> xiaoming = &#123;                name: <span class="string">'小明'</span>,</div><div class="line">               age: <span class="number">14</span>,</div><div class="line">                 gender: <span class="literal">true</span>,</div><div class="line">                 height: <span class="number">1.65</span>,</div><div class="line">                 grade: <span class="literal">null</span>,</div><div class="line">                <span class="string">'middle-school'</span>: <span class="string">'\"W3C\" Middle School'</span>,</div><div class="line">                 skills: [<span class="string">'JavaScript'</span>, <span class="string">'Java'</span>, <span class="string">'Python'</span>, <span class="string">'Lisp'</span>]</div><div class="line">             &#125;; </div><div class="line">            <span class="built_in">JSON</span>.stringify(xiaoming); <span class="comment">// '&#123;"name":"小明","age":14,"gender":true,"height":1.65,"grade":null,"middle-school":"\"W3C\" Middle School","skills":["JavaScript","Java","Python","Lisp"]&#125;'</span></div></pre></td></tr></table></figure>
<p>要输出得好看一些，可以加上参数，按缩进输出：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">            <span class="built_in">JSON</span>.stringify(xiaoming, <span class="literal">null</span>, <span class="string">'  '</span>);</div></pre></td></tr></table></figure>
<p>第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入Array：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">            <span class="built_in">JSON</span>.stringify(xiaoming, [<span class="string">'name'</span>, <span class="string">'skills'</span>], <span class="string">'  '</span>);</div></pre></td></tr></table></figure>
<p>还可以传入一个函数，这样对象的每个键值对都会被函数先处理：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">             <span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">key, value</span>) </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'string'</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> value.toUpperCase();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">return</span> value;</div><div class="line">               &#125;</div><div class="line">               <span class="built_in">JSON</span>.stringify(xiaoming, convert, <span class="string">'  '</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>反序列化<br>拿到一个JSON格式的字符串，我们直接用JSON.parse()把它变成一个JavaScript对象：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">               <span class="built_in">JSON</span>.parse(<span class="string">'[1,2,3,true]'</span>); <span class="comment">// [1, 2, 3, true]</span></div><div class="line">               <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"name":"小明","age":14&#125;'</span>); <span class="comment">// Object &#123;name: '小明', age: 14&#125;</span></div><div class="line">               <span class="built_in">JSON</span>.parse(<span class="string">'true'</span>); <span class="comment">// true</span></div><div class="line">               <span class="built_in">JSON</span>.parse(<span class="string">'123.45'</span>); <span class="comment">// 123.45</span></div></pre></td></tr></table></figure>
<p>还可以接收一个函数，用来转换解析出的属性：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">               <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"name":"小明","age":14&#125;'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</div><div class="line">                    <span class="comment">// 把number * 2:</span></div><div class="line">                    <span class="keyword">if</span> (key === <span class="string">'name'</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> value + <span class="string">'同学'</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">return</span> value;</div><div class="line">               &#125;); <span class="comment">// Object &#123;name: '小明同学', age: 14&#125;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><hr>
<p>JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> Student = &#123;</div><div class="line">          name: <span class="string">'Robot'</span>,</div><div class="line">          height: <span class="number">1.2</span>,</div><div class="line">          run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">              <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is running...'</span>);</div><div class="line">          &#125;</div><div class="line">     &#125;;  </div><div class="line">     <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">          name: <span class="string">'小明'</span></div><div class="line">     &#125;;  </div><div class="line">     xiaoming.__proto__ = Student;</div></pre></td></tr></table></figure></p>
<p>注意最后一行代码把<code>xiaoming</code>的原型指向了对象<code>Student</code>，看上去<code>xiaoming</code>仿佛是从<code>Student</code>继承下来的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">     xiaoming.name; <span class="comment">// '小明'</span></div><div class="line">     xiaoming.run(); <span class="comment">// 小明 is running...</span></div></pre></td></tr></table></figure></p>
<p><code>xiaoming</code>有自己的<code>name</code>属性，但并没有定义<code>run()</code>方法。不过，由于小明是从<code>Student</code>继承而来，只要<code>Student</code>有<code>run()</code>方法，<code>xiaoming</code>也可以调用：<br><b style="color:red;">请注意</b>，上述代码仅用于演示目的。在编写JavaScript代码时，不要直接用<code>obj.__proto__</code>去改变一个对象的原型，并且，低版本的IE也无法使用<code>__proto__</code>。<code>Object.create()</code>方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建<code>xiaoming</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">// 原型对象:</span></div><div class="line">     <span class="keyword">var</span> Student = &#123;</div><div class="line">          name: <span class="string">'Robot'</span>,</div><div class="line">          height: <span class="number">1.2</span>,</div><div class="line">          run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">              <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is running...'</span>);</div><div class="line">          &#125;</div><div class="line">     &#125;;  </div><div class="line">     <span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">          <span class="comment">// 基于Student原型创建一个新对象:</span></div><div class="line">          <span class="keyword">var</span> s = <span class="built_in">Object</span>.create(Student);</div><div class="line">          <span class="comment">// 初始化新对象:</span></div><div class="line">          s.name = name;</div><div class="line">          <span class="keyword">return</span> s;</div><div class="line">     &#125;  </div><div class="line">     <span class="keyword">var</span> xiaoming = createStudent(<span class="string">'小明'</span>);</div><div class="line">     xiaoming.run(); <span class="comment">// 小明 is running...</span></div><div class="line">     xiaoming.__proto__ === Student; <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>这是创建原型继承的一种方法，JavaScript还有其他方法来创建对象，我们在后面会一一讲到。</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。<br>当我们用<code>obj.xxx</code>访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到<code>Object.prototype</code>对象，最后，如果还没有找到，就只能返回<code>undefined</code>。<br>例如，创建一个Array对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div></pre></td></tr></table></figure></p>
<p>其原型链是：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">    arr ----&gt; <span class="built_in">Array</span>.prototype ----&gt; <span class="built_in">Object</span>.prototype ----&gt; <span class="literal">null</span></div></pre></td></tr></table></figure></p>
<p><code>Array.prototype</code>定义了<code>indexOf()</code>、<code>shift()</code>等方法，因此你可以在所有的<code>Array</code>对象上直接调用这些方法。<br>当我们创建一个函数时：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">     <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>函数也是一个对象，它的原型链是：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">    foo ----&gt; <span class="built_in">Function</span>.prototype ----&gt; <span class="built_in">Object</span>.prototype ----&gt; <span class="literal">null</span></div></pre></td></tr></table></figure></p>
<p>由于<code>Function.prototype</code>定义了<code>apply()</code>等方法，因此，所有函数都可以调用<code>apply()</code>方法。<br>很容易想到，如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要注意不要把原型链搞得太长。</p>
<ul>
<li><p>构造函数<br>除了直接用<code>{ ... }</code>创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">       <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            <span class="keyword">this</span>.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">            &#125;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p> 在JavaScript中，可以用关键字new来调用这个函数，并返回一个对象：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">'小明'</span>);</div><div class="line">          xiaoming.name; <span class="comment">// '小明'</span></div><div class="line">          xiaoming.hello(); <span class="comment">// Hello, 小明!</span></div></pre></td></tr></table></figure>
<p><b style="color:red;">注意</b>，如果不写<code>new</code>，这就是一个普通函数，它返回<code>undefined</code>。但是，如果写了<code>new</code>，它就变成了一个构造函数，它绑定的<code>this</code>指向新创建的对象，并默认返回<code>this</code>，也就是说，不需要在最后写<code>return this;</code>。<br>新创建的<code>xiaoming</code>的原型链是：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          xiaoming ----&gt; Student.prototype ----&gt; <span class="built_in">Object</span>.prototype ----&gt; <span class="literal">null</span></div></pre></td></tr></table></figure>
<p>也就是说，<code>xiaoming</code>的原型指向函数<code>Student</code>的原型。如果你又创建了<code>xiaohong</code>、<code>xiaojun</code>，那么这些对象的原型与<code>xiaoming</code>是一样的。<br>用<code>new Student()</code>创建的对象还从原型上获得了一个<code>constructor</code>属性，它指向函数<code>Student</code>本身。<br><b style="color:red;">总结：</b>函数<code>Student</code>恰好有个属性<code>prototype</code>指向<code>xiaoming</code>、<code>xiaohong</code>的原型对象，而且这个原型对象自己还有个属性<code>constructor</code>，指向<code>Student</code>函数本身。但是<code>xiaoming</code>、<code>xiaohong</code>这些对象可没有<code>prototype</code>这个属性，不过可以用<code>__proto__</code>这个非标准用法来查看。另外，要让创建的对象共享一个<code>hello</code>函数，根据对象的属性查找原则，我们只要把<code>hello</code>函数移动到<code>xiaoming</code>、<code>xiaohong</code>这些对象共同的原型上就可以了，也就是<code>Student.prototype</code>：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">               <span class="keyword">this</span>.name = name;</div><div class="line">           &#125;  </div><div class="line">          Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">               alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">          &#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>忘记写<code>new</code>怎么办<br>在strict模式下，<code>this.name = name</code>将报错，因为<code>this</code>绑定为<code>undefined</code>，在非strict模式下，<code>this.name = name</code>不报错，因为<code>this</code>绑定为<code>window</code>，于是无意间创建了全局变量<code>name</code>，并且返回<code>undefined</code>，这个结果更糟糕。 所以，调用构造函数千万不要忘记写<code>new</code>。为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写，而普通函数首字母应当小写，这样，一些语法检查工具如jslint将可以帮你检测到漏写的<code>new</code>。<br>最后，我们还可以编写一个<code>createStudent()</code>函数，在内部封装所有的<code>new</code>操作。一个常用的编程模式像这样：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">               <span class="keyword">this</span>.name = props.name || <span class="string">'匿名'</span>; <span class="comment">// 默认值为'匿名'</span></div><div class="line">               <span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>; <span class="comment">// 默认值为1</span></div><div class="line">          &#125;  </div><div class="line">          Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">               alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">          &#125;;  </div><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> <span class="keyword">new</span> Student(props || &#123;&#125;)</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p>JavaScript的原型继承实现方式就是：</p>
<ul>
<li>定义新的构造函数，并在内部用<code>call()</code>调用希望“继承”的构造函数，并绑定<code>this</code>；</li>
<li>借助中间函数<code>F</code>实现原型链继承，最好通过封装的<code>inherits</code>函数完成；</li>
<li>继续在新的构造函数的原型上定义新方法。<br>示例，创建一个子类<code>PrimaryStudent</code>继承自<code>Student</code>类: <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">               <span class="keyword">this</span>.name = props.name || <span class="string">'Unnamed'</span>;</div><div class="line">          &#125;</div><div class="line">          Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">               alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">          &#125;  </div><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">              <span class="comment">//调用Student类的构造函数,此时Student的this表示当前对象。</span></div><div class="line"></div><div class="line">              Student.call(<span class="keyword">this</span>, props);</div><div class="line">              <span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>;</div><div class="line">          &#125;  </div><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">Child, Parent</span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">               F.prototype = Parent.prototype;</div><div class="line">               Child.prototype = <span class="keyword">new</span> F();</div><div class="line">               Child.prototype.constructor = Child;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// 实现原型继承链:</span></div><div class="line">          inherits(PrimaryStudent, Student);</div><div class="line">          <span class="comment">// 绑定其他方法到PrimaryStudent原型:</span></div><div class="line">          PrimaryStudent.prototype.getGrade = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> <span class="keyword">this</span>.grade;</div><div class="line">          &#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="class继承-ES6引入"><a href="#class继承-ES6引入" class="headerlink" title="class继承(ES6引入)"></a>class继承(ES6引入)</h2><p>新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。</p>
<ul>
<li><p>函数定义<br>用函数实现Student的方法：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">                <span class="keyword">this</span>.name = name;</div><div class="line">          &#125;</div><div class="line">          Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">           &#125;</div></pre></td></tr></table></figure>
<p>如果用新的class关键字来编写<code>Student</code>，可以这样写：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">               <span class="keyword">constructor</span>(name) &#123;</div><div class="line">                   <span class="keyword">this</span>.name = name;</div><div class="line">               &#125;</div><div class="line">               hello() &#123;</div><div class="line">                   alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">               &#125;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>class继承<br>用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">          <span class="class"><span class="keyword">class</span> <span class="title">PrimaryStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;</div><div class="line">               <span class="keyword">constructor</span>(name, grade) &#123;</div><div class="line">                   <span class="keyword">super</span>(name); <span class="comment">// 记得用super调用父类的构造方法!</span></div><div class="line">                   <span class="keyword">this</span>.grade = grade;</div><div class="line">               &#125;</div><div class="line">               myGrade() &#123;</div><div class="line">                   alert(<span class="string">'I am at grade '</span> + <span class="keyword">this</span>.grade);</div><div class="line">               &#125;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><hr>
<p>目前主流的浏览器分这么几种：</p>
<ul>
<li>IE 6~11：国内用得最多的IE浏览器，历来对W3C标准支持差。从IE10开始支持ES6标准；</li>
<li>Chrome：Google出品的基于Webkit内核浏览器，内置了非常强悍的JavaScript引擎——V8。由于Chrome一经安装就时刻保持自升级，所以不用管它的版本，最新版早就支持ES6了；</li>
<li>Safari：Apple的Mac系统自带的基于Webkit内核的浏览器，从OS X 10.7 Lion自带的6.1版本开始支持ES6，目前最新的OS X 10.11 El Caption自带的Safari版本是9.x，早已支持ES6；</li>
<li>Firefox：Mozilla自己研制的Gecko内核和JavaScript引擎OdinMonkey。早期的Firefox按版本发布，后来终于聪明地学习Chrome的做法进行自升级，时刻保持最新；</li>
<li>移动设备上目前iOS和Android两大阵营分别主要使用Apple的Safari和Google的Chrome，由于两者都是Webkit核心，结果HTML5首先在手机上全面普及（桌面绝对是Microsoft拖了后腿），对JavaScript的标准支持也很好，最新版本均支持ES6。</li>
</ul>
<h2 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h2><p>JavaScript可以获取浏览器提供的很多对象，并进行操作。</p>
<ul>
<li>window<br><code>window</code>对象不但充当全局作用域，而且表示浏览器窗口。<br><code>window</code>对象有<code>innerWidth</code>和<code>innerHeight</code>属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。对应的，还有一个<code>outerWidth</code>和<code>outerHeight</code>属性，可以获取浏览器窗口的整个宽高。</li>
<li>navigator<br>navigator对象表示浏览器的信息，最常用的属性包括：<ul>
<li>navigator.appName：浏览器名称；</li>
<li>navigator.appVersion：浏览器版本；</li>
<li>navigator.language：浏览器设置的语言；</li>
<li>navigator.platform：操作系统类型；</li>
<li>navigator.userAgent：浏览器设定的User-Agent字符串。</li>
</ul>
</li>
<li>screen<br>   <code>screen</code>对象表示屏幕的信息，常用的属性有：<ul>
<li>screen.width：屏幕宽度，以像素为单位；</li>
<li>screen.height：屏幕高度，以像素为单位；</li>
<li>screen.colorDepth：返回颜色位数，如8、16、24。</li>
</ul>
</li>
<li><p>location<br>  <code>location</code>对象表示当前页面的URL信息。<br>  可以用<code>location.href</code>获取完整URL。要获得URL各个部分的值，可以这么写：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          location.protocol; <span class="comment">// 'http'</span></div><div class="line">          location.host; <span class="comment">// 'www.example.com'</span></div><div class="line">          location.port; <span class="comment">// '8080'</span></div><div class="line">          location.pathname; <span class="comment">// '/path/index.html'</span></div><div class="line">          location.search; <span class="comment">// '?a=1&amp;b=2'</span></div><div class="line">          location.hash; <span class="comment">// 'TOP'</span></div></pre></td></tr></table></figure>
<p> 要加载一个新页面，可以调用<code>location.assign()</code>。如果要重新加载当前页面，调用location.reload()方法非常方便。</p>
</li>
<li><p>document<br>  <code>document</code>对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，<code>document</code>对象就是整个DOM树的根节点。<br>  document的title属性是从HTML文档中的<title>xxx</title>读取的，但是可以动态改变<br>  要查找DOM树的某个节点，需要从document对象开始查找。最常用的查找是根据ID和Tag Name。<br>  <code>document</code>对象还有一个<code>cookie</code>属性，可以获取当前页面的Cookie。<br>  Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如<code>user=ABC123XYZ(加密的字符串)</code>…，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。<br>  JavaScript可以通过<code>document.cookie</code>读取到当前页面的Cookie：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          <span class="built_in">document</span>.cookie; <span class="comment">// 'v=123; remember=true; prefer=zh'</span></div></pre></td></tr></table></figure>
<p>  由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，这是因为在HTML页面中引入第三方的JavaScript代码是允许的：</p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">          <span class="comment">&lt;!-- 当前页面在wwwexample.com --&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://www.foo.com/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">               <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">              ...</div><div class="line">          <span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>  如果引入的第三方的JavaScript中存在恶意代码，则<code>www.foo.com</code>网站将直接获取到<code>www.example.com</code>网站的用户登录信息。<br>  为了解决这个问题，服务器在设置Cookie时可以使用httpOnly，设定了httpOnly的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持httpOnly选项，IE从IE6 SP1开始支持。</p>
</li>
<li>history<br>  <code>history</code>对象保存了浏览器的历史记录，JavaScript可以调用<code>history</code>对象的<code>back()</code>或<code>forward ()</code>，相当于用户点击了浏览器的“后退”或“前进”按钮。但，任何情况，你都不应该使用history这个对象了。</li>
</ul>
<h2 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h2><p>DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作：</p>
<ul>
<li>更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；</li>
<li>遍历：遍历该DOM节点下的子节点，以便进行进一步操作；</li>
<li>添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；</li>
<li>删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。</li>
</ul>
<p>由于ID在HTML文档中是唯一的，所以<code>document.getElementById()</code>可以直接定位唯一的一个DOM节点。<code>document.getElementsByTagName()</code>和<code>document.getElementsByClassName()</code>总是返回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 返回ID为&apos;test&apos;的节点：</div><div class="line">var test = document.getElementById(&apos;test&apos;);</div><div class="line"></div><div class="line">// 先定位ID为&apos;test-table&apos;的节点，再返回其内部所有tr节点：</div><div class="line">var trs = document.getElementById(&apos;test-table&apos;).getElementsByTagName(&apos;tr&apos;);</div><div class="line"></div><div class="line">// 先定位ID为&apos;test-div&apos;的节点，再返回其内部所有class包含red的节点：</div><div class="line">var reds = document.getElementById(&apos;test-div&apos;).getElementsByClassName(&apos;red&apos;);</div><div class="line"></div><div class="line">// 获取节点test下的所有直属子节点:</div><div class="line">var cs = test.children;</div><div class="line"></div><div class="line">// 获取节点test下第一个、最后一个子节点：</div><div class="line">var first = test.firstElementChild;</div><div class="line">var last = test.lastElementChild;</div></pre></td></tr></table></figure></p>
<p>第二种方法是使用<code>querySelector()</code>和<code>querySelectorAll()</code>，需要了解selector语法，然后使用条件来获取节点，更加方便：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 通过querySelector获取ID为q1的节点：</div><div class="line">var q1 = document.querySelector(&apos;#q1&apos;);</div><div class="line"></div><div class="line">// 通过querySelectorAll获取q1节点内的符合条件的所有节点：</div><div class="line">var ps = q1.querySelectorAll(&apos;div.highlighted &gt; p&apos;);</div></pre></td></tr></table></figure></p>
<p>注意：低版本的IE&lt;8不支持<code>querySelector</code>和<code>querySelectorAll</code>。IE8仅有限支持。</p>
<h3 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h3><ul>
<li><p>创建元素：<code>document.createElement()</code><br>  使用<code>document.createElement()</code>可以创建新元素。这个方法只接受一个参数，即要创建元素的标签名。这个标签名在<code>HTML</code>文档中不区分大小写，在<code>XHTML</code>中区分大小写。<br>  此时，新元素尚未被添加到文档树中，因此设置各种特性均不会影响浏览器的显示。要添加到文档树，可用<code>appendChild()、insertBefore()、replaceChild()</code>。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var div = document.createElement(&quot;div&quot;);</div><div class="line">div.id = &quot;myDiv&quot;;</div><div class="line">div.className = &quot;div1&quot;;</div><div class="line">document.body.appendChild(div);</div></pre></td></tr></table></figure>
<p>  在<code>IE</code>中可以为<code>createElement()</code>方法传入完整的元素标签和属性。(只在<code>IE</code>中兼容)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var div = document.createElement(&quot;&lt;div id=\&quot;mydiv\&quot; class=\&quot;div1\&quot;&gt;&lt;/div&gt;&quot;);</div><div class="line">不能再标签里加其他元素节点或者文本节点，如下的方式和上面的得出的节点一样</div><div class="line">var div = document.createElement(&quot;&lt;div id=\&quot;mydiv\&quot; class=\&quot;div1\&quot;&gt;12212&lt;/div&gt;&quot;);</div></pre></td></tr></table></figure>
</li>
<li><p>创建文本节点 ：<code>document.createTextNode</code><br>使用<code>document.createTextNode()</code>来创建文本节点，这个方法接受一个参数：要插入节点的文本。与设置已有文本节点的值一样，作为参数的文本将按照<code>HTML</code>或<code>XML</code>的格式进行编码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.createTextNode(&quot;121212&quot;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h3><p>（<code>IE9</code>以前不将换行和空格看做文本节点，其他浏览器会）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;div1&quot;&gt;</div><div class="line">    &lt;div id=&quot;div2&quot;&gt;2&lt;/div&gt;</div><div class="line">    &lt;div id=&quot;div3&quot;&gt;3&lt;/div&gt;</div><div class="line">    &lt;div id=&quot;div4&quot;&gt;4&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>parentNode</code>是指定节点的父节点.</li>
<li><p><code>childNodes</code> 返回包含指定节点的子节点的集合，该集合为即时更新的集合（<code>live collection</code>）。<br>即时更新就是对节点元素的任意修改都会立即反映到结果里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var child2 = document.getElementById(&quot;div2&quot;);</div><div class="line">    var parent = child2.parentNode;</div><div class="line">    var allChilds = parent.childNodes;</div><div class="line">    console.log(allChilds.length) // IE下是3，其他浏览器是7</div><div class="line"></div><div class="line">    var nodeAdd = document.createElement(&quot;div&quot;);</div><div class="line">    var textAdd = document.createTextNode(&quot;这是添加的文本节点&quot;);</div><div class="line">    nodeAdd.appendChild(textAdd);</div><div class="line">    parent.appendChild(nodeAdd);</div><div class="line">    console.log(allChilds.length);// IE下是4，其他浏览器是8</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
<li><p><code>nextSibling</code>返回某节点的下一个兄弟节点，<code>previousSibling</code>返回某节点的上一个兄弟节点，没有的话返回<code>null</code>。<br><strong>注意：</strong>可能因为元素换行的原因返回的是<code>text</code>节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var child3 = document.getElementById(&quot;div3&quot;);</div><div class="line">    var next = child3.nextSibling;</div><div class="line">    var previous = child3.previousSibling;</div><div class="line">    console.log(next); // IE下返回div4，其他返回text</div><div class="line">    console.log(previous)  // IE下返回div2，其他返回text</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
<li><p><code>firstChild</code>返回<code>node</code>的子节点中的第一个节点的引用，没有返回<code>null</code></p>
</li>
<li><p><code>lastChild</code>返回<code>node</code>的子节点中的最后一个节点的引用，没有返回<code>null</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    	var child3 = document.getElementById(&quot;div3&quot;);</div><div class="line">    	var parent = child3.parentNode;</div><div class="line">    	var first = parent.firstChild; // IE是div2，其他是text</div><div class="line">    	var last = parent.lastChild; // IE是div4，其他是text</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>  <strong>注意：</strong>childNodes返回指定元素的子元素集合，包括HTML节点，所有属性，文本节点。可以通过nodeType来判断是哪种类型的节点，只有当nodeType==1时才是元素节点，2是属性节点，3是文本节点。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//获取第一个子元素</div><div class="line">function getFirst(elem)&#123;</div><div class="line">   		for(var i=0,e;e=elem.childNodes[i++];)&#123;</div><div class="line">        	if(e.nodeType==1)</div><div class="line">            	return e;</div><div class="line">    	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="节点元素关系"><a href="#节点元素关系" class="headerlink" title="节点元素关系"></a>节点元素关系</h3><p>以下方法只算元素，不算文本节点。<br>以下三个方法用法和节点关系完全一样，只是这三个方法只看元素节点，不管因为空格、换行造成的文本节点或者手动加上去的文本节点。</p>
<ul>
<li><code>children</code>： 返回所有元素子节点（<code>IE5+、ff3.5、opera3、chrome</code>，但在<code>IE8</code>及以下会将注释节点看成一个元素节点）<br>以下两个<code>IE9+</code>才支持</li>
<li><code>nextElementSibling</code>：返回元素的下一个兄弟元素节点</li>
<li><code>previousElementSibling</code>: 返回元素的上一个兄弟元素节点</li>
</ul>
<h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><ul>
<li><p><code>appendChild()</code>用于向<code>childNodes</code>列表的末尾添加一个节点，并且返回这个新增的节点。<br>如果传入到<code>appendChild()</code>里的节点已经是文档的一部分了，那结果就是将节点从原来的位置转移到新位置，任何一个节点不能同时出现在文档中的多个位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var returnNode = someNode.appendChild(someNode.firstChild); // 返回第一个节点</div><div class="line">    console.log(returnNode === someNode.firstChild); // false</div><div class="line">    console.log(returnNode === someNode.lastChild); // true</div></pre></td></tr></table></figure>
</li>
<li><p><code>insetBefore()</code>可以将节点插入到某个特定的位置。这个方法接受两个参数：要插入的节点和作为参照的节点。<br>插入节点后，被插入的节点变成参照节点的前一个同胞节点，同时被方法返回。 如果参照节点是<code>null</code>，则与</p>
</li>
<li><p><code>appendChild()</code>执行相同的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> // 插入后成为最后一个子节点</div><div class="line">    var returnNode = someNode.insetBefore(newNode, null);</div><div class="line">    console.log(returnNode === someNode.lastChild); // true</div><div class="line"></div><div class="line">    // 插入后成为第一个子节点</div><div class="line">    var returnNode = someNode.insetBefore(newNode, someNode.firstChild);</div><div class="line">    console.log(returnNode === newNode); // true</div><div class="line">    console.log(returnNode === someNode.firstChild); // true</div><div class="line"></div><div class="line">    // 插入到最后一个子节点的前面</div><div class="line">    var returnNode = someNode.insetBefore(newNode, someNode.lastChild);</div><div class="line">    console.log(returnNode === someNode.childNodes[someNode.childnodes.length - 2]) // true</div></pre></td></tr></table></figure>
</li>
<li><p><code>replaceChild()</code>接受两个参数：要插入的节点和要被替换的节点。被替换的节点将由这个方法返回并从文档中被移除，同时由要插入的节点占据其位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 替换第一个子节点</div><div class="line">    var returnNode = someNode.replaceChild(newNode, someNode.firstChild);</div></pre></td></tr></table></figure>
</li>
<li><p><code>removeChild()</code>该方法移除节点，接受一个参数，即要移除的节点，同时该方法返回被移除的节点。只能是一个节点，不能是一组节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> // 移除第一个子节点</div><div class="line">    var returnNode = someNode.removeChild(someNode.firstChild);</div></pre></td></tr></table></figure>
</li>
<li><p><code>cloneNode(deep)</code>返回调用该方法的节点的一个副本。参数表示是否采用深度克隆,如果为<code>true</code>,则该节点的所有后代节点也都会被克隆,如果为<code>false</code>,则只克隆该节点本身，文本或者换行、空格这些不会复制，因为他们都是一个<code>textNode</code>。<br><code>deep</code>是一个可选参数. 如果省略的话, <code>deep</code>参数的默认值为<code>true</code>,也就是说,深度克隆是默认的.如果想使用浅克隆, 你需要将该参数指定为<code>false</code>。<br>克隆一个元素节点会拷贝它所有的属性以及属性值,当然也就包括了属性上绑定的事件(比如<code>onclick=&quot;alert(1)&quot;</code>),但不会拷贝那些使用<code>addEventListener()</code>方法或者<code>node.onclick = fn</code>这种用<code>JavaScript</code>动态绑定的事件。</p>
</li>
</ul>
<h3 id="元素选择"><a href="#元素选择" class="headerlink" title="元素选择"></a>元素选择</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;div1&quot;&gt;</div><div class="line">        &lt;p id=&quot;div2&quot; class=&quot;one&quot; name=&quot;nameone&quot;&gt;2&lt;/p&gt;</div><div class="line">        &lt;div id=&quot;div3&quot;&gt;3&lt;/div&gt;</div><div class="line">        &lt;div id=&quot;div4&quot; name=&quot;div2&quot;&gt;4&lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div></pre></td></tr></table></figure>
<ul>
<li><code>DOMObject.querySelector</code>返回节点子树内与之相匹配的第一个<code>Element</code>节点。如果没有匹配的节点，则返回<code>null</code>。</li>
<li><p><code>DOMObject.querySelectorAll</code>返回一个包含节点子树内所有与之相匹配的<code>Element</code>节点列表，如果没有相匹配的，则返回一个空节点列表<br>  <strong>注意：</strong>由 <code>querySelector()</code>、<code>querySelectorAll()</code>返回的节点列表不是动态实时的（非<code>live Collection</code>）。这和其他<code>DOM</code>查询方法返回动态实时节点列表不一样。<br>  选择器方法接受一个或多个用逗号分隔的选择器来确定需要被返回的元素。例如，要选择文档中所有<code>CSS</code>的类(<code>class</code>)是<code>warning</code>或者<code>note</code>的段落(<code>p</code>)元素,可以这样写：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var special = document.querySelectorAll( &quot;p.warning, p.note&quot; );</div></pre></td></tr></table></figure>
<p>  也可以通过ID来查询，例如：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var el = document.querySelector( &quot;#main, #basic, #exclamation&quot; );</div></pre></td></tr></table></figure>
<p>  执行上面的代码后，<code>el</code>就包含了文档中元素的<code>ID</code>是<code>main</code>，<code>basic</code>或<code>exclamation</code>的所有元素中的第一个元素。</p>
</li>
<li><code>document.getElementById()</code>也是<strong>非</strong>live collection<br><strong>注意：</strong>getElementById方法只有document对象才有</li>
<li><p><code>DOMObject.getElementsByTagName()</code> 方法返回一个实时的包含具有给出标签名的元素们的<code>HTMLCollection</code>。指定的元素的子树会被搜索，包括元素自己。返回的 <code>list</code> 是实时的（<code>live collection</code>），意味着它会随着<code>DOM</code>树的变化自动更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var live = document.getElementsByTagName(&quot;p&quot;);</div><div class="line">    console.log(live[0].innerHTML);</div><div class="line">    document.getElementById(&quot;div1&quot;).removeChild(document.getElementById(&quot;div2&quot;));</div><div class="line">    console.log(live[0].innerHTML);</div><div class="line">    // 第一个输出2，第二个报错，因为无法引用到p标签</div></pre></td></tr></table></figure>
</li>
<li><p><code>document.getElementsByName()</code>该方法返回一个实时的<code>nodelist collection</code>，包含文档中所有<code>name</code>属性匹配的标签。这是一个<strong>live collection</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    var live = document.getElementsByName(&quot;div2&quot;);</div><div class="line">    console.log(live[0].innerHTML);</div><div class="line">    document.getElementById(&quot;div1&quot;).removeChild(document.getElementById(&quot;div2&quot;));</div><div class="line">    console.log(live[0].innerHTML);</div><div class="line">    // chrome下：全部输出4</div><div class="line">    // IE下： 第一个输出2，第二个报错。</div></pre></td></tr></table></figure>
</li>
<li><p><code>DOMObject.getElementsByClassName()</code>该方法返回一个即时更新的（<code>live</code>） <code>HTMLCollection</code>，包含了所有拥有指定 <code>class</code> 的子元素。当在 <code>document</code> 对象上调用此方法时，会检索整个文档，包括根元素。(<code>IE9</code>以下不支持)<br>要匹配多个<code>class</code>，则<code>className</code>用空格分开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getElementsByClassName(&quot;class1 class2&quot;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3><ul>
<li><p><code>DOMObject.setAttribute()</code>添加一个新属性（<code>attribute</code>）到元素上，或改变元素上已经存在的属性的值。<br>如果指定的属性已经存在，则其值变为传递的值。如果不存在，则创建指定的属性。也可指定为<code>null</code>。如果设置为<code>null</code>，最好使用<code>removeAttribute()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var div2 = document.getElementById(&quot;div2&quot;);</div><div class="line">    div2.setAttribute(&quot;class&quot;, &quot;new_class&quot;);</div><div class="line">    div2.setAttribute(&quot;id&quot;, &quot;new_id&quot;);</div></pre></td></tr></table></figure>
</li>
<li><p><code>DOMObject.removeAttribute()</code>该方法用于移除元素的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> var div2 = document.getElementById(&quot;div2&quot;);</div><div class="line">    div2.removeAttribute(&quot;class&quot;);</div></pre></td></tr></table></figure>
</li>
<li><p><code>DOMObject.getAttribute()</code>该方法返回元素上指定属性（<code>attribute</code>）的值。如果指定的属性不存在，则返回 <code>null</code> 或 <code>&quot;&quot;</code> （空字符串）（<code>IE5+</code>都返回<code>null</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var div2 = document.getElementById(&quot;div2&quot;);</div><div class="line">    var attr = div2.getAttribute(&quot;class&quot;);</div><div class="line">    console.log(attr);</div></pre></td></tr></table></figure>
</li>
<li><p><code>DOMObject.hasAttribute()</code>返回一个布尔值，指示该元素是否包含有指定的属性（<code>attribute</code>）。</p>
</li>
<li><p>自定义属性<code>data-*</code><br>  <code>html5</code>里有一个<code>data-*</code>去设置获取元素的自定义属性值。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;div1&quot; data-aa=&quot;11&quot;&gt;</div></pre></td></tr></table></figure>
<p>  利用<code>div1.dataset</code>可以获得一个<code>DOMStringMap</code>，包含了元素的所有<code>data-*</code>。使用<code>div1.dataset.aa</code>就可以获取<code>11</code>的值。同样，通过设置<code>div1.dataset.bb = &quot;22&quot;</code>就可以设置一个自定义属性值。在不兼容的浏览器里，就使用<code>getAttribute</code>和<code>setAttribute</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">	  var div1 = document.getElementById(&quot;div1&quot;);</div><div class="line">	    var a = null;</div><div class="line">	    if (div1.dataset) &#123;</div><div class="line">	        a = div1.dataset.aa;</div><div class="line">	        div1.dataset.bb = &quot;222&quot;;</div><div class="line">	    &#125; else &#123;</div><div class="line">	        a = div1.getAttribute(&quot;data-aa&quot;);</div><div class="line">	        div1.setAttribute(&quot;data-bb&quot;, &quot;2222&quot;);</div><div class="line">	    &#125;</div><div class="line">	    console.log(a);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><p>在HTML表单中，可以上传文件的唯一控件就是<code>&lt;input type=&quot;file&quot;&gt;</code>。<br><em>注意</em>：当一个表单包含<code>&lt;input type=&quot;file&quot;&gt;</code>时，表单的<code>enctype</code>必须指定为<code>multipart/form-data</code>，<code>method</code>必须指定为<code>post</code>，浏览器才能正确编码并以<code>multipart/form-data</code>格式发送表单的数据。<br>通常，上传的文件都由后台服务器处理，JavaScript可以在提交表单时对文件扩展名做检查，以便防止用户上传无效格式的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var f = document.getElementById(&apos;test-file-upload&apos;);</div><div class="line">var filename = f.value; // &apos;C:\fakepath\test.png&apos;</div><div class="line">if (!filename || !(filename.endsWith(&apos;.jpg&apos;) || filename.endsWith(&apos;.png&apos;) || filename.endsWith(&apos;.gif&apos;))) &#123;</div><div class="line">    alert(&apos;Can only upload image file.&apos;);</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>FileAPI<br>  HTML5的File API提供了<code>File</code>和<code>FileReader</code>两个主要对象，可以获得文件信息并读取文件。<br>  下面的例子演示了如何读取用户选取的图片文件，并在一个<code>&lt;div&gt;</code>中预览图像：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">var</div><div class="line">    fileInput = document.getElementById(&apos;test-image-file&apos;),</div><div class="line">    info = document.getElementById(&apos;test-file-info&apos;),</div><div class="line">    preview = document.getElementById(&apos;test-image-preview&apos;);</div><div class="line">// 监听change事件:</div><div class="line">fileInput.addEventListener(&apos;change&apos;, function () &#123;</div><div class="line">    // 清除背景图片:</div><div class="line">    preview.style.backgroundImage = &apos;&apos;;</div><div class="line">    // 检查文件是否选择:</div><div class="line">    if (!fileInput.value) &#123;</div><div class="line">        info.innerHTML = &apos;没有选择文件&apos;;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    // 获取File引用:</div><div class="line">    var file = fileInput.files[0];</div><div class="line">    // 获取File信息:</div><div class="line">    info.innerHTML = &apos;文件: &apos; + file.name + &apos;&lt;br&gt;&apos; +</div><div class="line">                     &apos;大小: &apos; + file.size + &apos;&lt;br&gt;&apos; +</div><div class="line">                     &apos;修改: &apos; + file.lastModifiedDate;</div><div class="line">    if (file.type !== &apos;image/jpeg&apos; &amp;&amp; file.type !== &apos;image/png&apos; &amp;&amp; file.type !== &apos;image/gif&apos;) &#123;</div><div class="line">        alert(&apos;不是有效的图片文件!&apos;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    // 读取文件:</div><div class="line">    var reader = new FileReader();</div><div class="line">    reader.onload = function(e) &#123;</div><div class="line">        var</div><div class="line">            data = e.target.result; // &apos;data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...&apos;            </div><div class="line">        preview.style.backgroundImage = &apos;url(&apos; + data + &apos;)&apos;;</div><div class="line">    &#125;;</div><div class="line">    // 以DataURL的形式读取文件:</div><div class="line">    reader.readAsDataURL(file);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>  上面的代码演示了如何通过HTML5的File API读取文件内容。以DataURL的形式读取到的文件是一个字符串，类似于<code>data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...</code>，常用于设置图像。如果需要服务器端处理，把字符串<code>base64,</code>后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。</p>
</li>
</ul>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>在现代浏览器上写AJAX主要依靠<code>XMLHttpRequest</code>对象，对于低版本的IE，需要换一个<code>ActiveXObject</code>对象，下面的写法能兼容主流浏览器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">function success(text) &#123;</div><div class="line">    var textarea = document.getElementById(&apos;test-ie-response-text&apos;);</div><div class="line">    textarea.value = text;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function fail(code) &#123;</div><div class="line">    var textarea = document.getElementById(&apos;test-ie-response-text&apos;);</div><div class="line">    textarea.value = &apos;Error code: &apos; + code;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var request;</div><div class="line">if (window.XMLHttpRequest) &#123;</div><div class="line">    request = new XMLHttpRequest();</div><div class="line">&#125; else &#123;</div><div class="line">    request = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">request.onreadystatechange = function () &#123; // 状态发生变化时，函数被回调</div><div class="line">    if (request.readyState === 4) &#123; // 成功完成</div><div class="line">        // 判断响应结果:</div><div class="line">        if (request.status === 200) &#123;</div><div class="line">            // 成功，通过responseText拿到响应的文本:</div><div class="line">            return success(request.responseText);</div><div class="line">        &#125; else &#123;</div><div class="line">            // 失败，根据响应码判断失败原因:</div><div class="line">            return fail(request.status);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        // HTTP请求还在继续...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 发送请求:</div><div class="line">request.open(&apos;GET&apos;, &apos;/api/categories&apos;);</div><div class="line">request.send();</div><div class="line"></div><div class="line">alert(&apos;请求已发送，请等待响应...&apos;);</div></pre></td></tr></table></figure></p>
<p><code>XMLHttpRequest</code>对象的<code>open()</code>方法有3个参数，第一个参数指定是<code>GET</code>还是<code>POST</code>，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是<code>true</code>，所以不用写。<br><em>注意</em>，千万不要把第三个参数指定为<code>false</code>，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态。<br>最后调用<code>send()</code>方法才真正发送请求。<code>GET</code>请求不需要参数，<code>POST</code>请求需要把body部分以字符串或者<code>FormData</code>对象传进去。</p>
<ul>
<li><p>安全限制(JSONP)<br>  上面代码的URL使用的是相对路径。如果你把它改为<code>&#39;http://www.sina.com.cn/&#39;</code>，再运行，肯定报错。在Chrome的控制台里，还可以看到错误信息。<br>  这是因为浏览器的同源策略导致的。默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。<br>  JS 解决跨域问题的方法–JSONP：<br>  实现原理：凡是拥有”src”这个属性的标签都拥有跨域的能力，比如<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>，可以在script标签内请求服务器，服务器返回函数调用的字符串（数据作为函数的参数），客户端就会把这段字符串作为JS代码执行，由此客户端就能获取服务器端的数据。<br>  示例代码：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    // 得到航班信息查询结果后的回调函数</div><div class="line">    var flightHandler = function(data)&#123;</div><div class="line">        alert(&apos;你查询的航班结果是：票价 &apos; + data.price + &apos; 元，&apos; + &apos;余票 &apos; + data.tickets + &apos; 张。&apos;);</div><div class="line">    &#125;; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）</div><div class="line">    var url = &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler&quot;; // 创建script标签，设置其属性</div><div class="line">    var script = document.createElement(&apos;script&apos;);</div><div class="line">    script.setAttribute(&apos;src&apos;, url); // 把script标签加入head，此时调用开始</div><div class="line"> document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); </div><div class="line"> &lt;/script&gt;</div></pre></td></tr></table></figure>
<p>   我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flightHandler(&#123; &quot;code&quot;: &quot;CA1998&quot;, &quot;price&quot;: 1780, &quot;tickets&quot;: 5 &#125;);</div></pre></td></tr></table></figure>
<p>  然后页面就会把返回的字符串作为JS代码执行。<br>  <strong>注意：ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本。</strong></p>
</li>
</ul>


            <div class="post-info">
    <p class="eof">- EOF -</p>
    <p class="copyright">All rights reserved <a href="http://heji1993.github.io/about">@heji1993</a>.</p>
    <p class="link">本文链接：<a href="https://heji1993.github.io/2016/09/14/Javascript学习笔记/">https://heji1993.github.io/2016/09/14/Javascript学习笔记/</a></p>

    <div class="share">
    分享本页：
    
        <div class="bdsharebuttonbox"><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信">微信</a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间">QQ空间</a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博">新浪微博</a><a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博">腾讯微博</a><a href="#" class="bds_more" data-cmd="more"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"0","bdSize":"24"},"share":{"bdSize":16}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

    
    
</div>

</div>


            
    <section class="comment">
    <div class="ds-thread" data-thread-key="undefined" data-title="JS学习笔记" data-url="https://heji1993.github.io/2016/09/14/Javascript学习笔记/" data-author-key="何机"></div>
</section>


<script type="text/javascript">
var duoshuoQuery = {short_name:"heji"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';
        ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
</script>





        </div>
    </div>
</article>

    <footer id="footer">
        <div id="bottom-tip">
            何机的博客 —— <small>No pains,no gains</small>
        </div>
        <small>该博客由 <a href="https://hexo.io/" target="_blank">Hexo</a> 强力驱动，搭载 <a href="https://github.com/gejiawen/hexadillax2" target="_blank">Hexadillax2</a> 主题</small><br />
        <!--<small>如果你访问github速度过慢，可移步本站的备份站点<a href="http://gejiawen.gitcafe.io">gejiawen.gitcafe.io</a></small><br />-->
        <small>&copy; 2016 <a href="https://heji1993.github.io" target="_blank">何机</a></small>
    </footer>
    
    <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e4dd778a6204eb51e4f25460e37481ad";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>


    <script type="text/javascript" src="http://tajs.qq.com/stats?sId=58628762" charset="UTF-8"></script>


    <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-51347904-1', 'auto');
  ga('send', 'pageview');
</script>

</body>
</html>

