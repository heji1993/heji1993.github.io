<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[CSS3弹性盒模型]]></title>
      <url>https://heji1993.github.io/2016/12/10/CSS3%E5%BC%B9%E6%80%A7%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>弹性盒模型布局方式是CSS3规范中提出的一种新的布局方案。该布局方案提供了一种更加高效简单的方式来处理容器中的元素布局、对齐、空间分配等操作，即使容器中的元素尺寸未知（或者尺寸大小是动态的）也能工作得很好。目前CSS3提出的此种布局方式也被各大主流浏览器所支持，可以预见Flexbox Layout在未来将会被广泛使用。</p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CSS3新增的<a href="http://www.w3.org/TR/css-flexbox/" target="_blank" rel="external">Flexible Box Layout</a>（弹性盒模型布局方式）是CSS3规范中提出的一种新的布局方案。该布局方案提供了一种更加高效简单的方式来处理容器中的元素布局、对齐、空间分配等操作，即使容器中的元素尺寸未知（或者尺寸大小是动态的）也能工作得很好。目前CSS3提出的此种布局方式也被各大主流浏览器所支持，可以预见Flexbox Layout在未来将会被广泛使用。</p>
<h2 id="初识Flexbox"><a href="#初识Flexbox" class="headerlink" title="初识Flexbox"></a>初识Flexbox</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在弹性盒模型布局中，需要事先指定一个容器，后续的所有布局操作都是基于此容器来定义的。其核心是<strong>容器会根据布局的需要（动态的）调整其中所包含的子元素（即布局条目）的尺寸、顺序来填充容器的所有可用空间。</strong><br>当容器的尺寸由于屏幕大小（或者浏览器窗口尺寸）发生变化时，其中包含的布局条目也会自动地进行调整。举个例子，当容器尺寸增大时，包含的条目将会自动拉伸以沾满多余的空白空间；当容器尺寸变小时，条目会自动收缩以适应容器的尺寸防止移除容器的范围。<br>额外提一点，Flexbox布局是<strong>不存在内置的布局方向</strong>的。这是什么意思呢？比如传统的布局方案中，块级布局（block）默认是将各个块级元素按照垂直方向自上向下依次堆放；内联布局（inline）默认是将各个内联元素按照水平方向按照从左到右的顺序依次堆放。而弹性盒布局不存在这种默认的布局方向限制，它提供了独立的布局方向属性，开发人员可以根据布局需要自行设置。</p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p>弹性盒模型是一种新的布局方式，它有自己的一套概念，图解如下：<br><img src="http://7xkwt1.com1.z0.glb.clouddn.com/CSS3-Flexbox%E5%B1%9E%E6%80%A7%E4%B8%8E%E5%BC%B9%E6%80%A7%E7%9B%92%E6%A8%A1%E5%9E%8B-001.png" alt=""><br>主要包含以下几个概念：</p>
<ol>
<li><code>flex container</code>，即所谓的<strong>容器</strong>（或者称之为<strong>弹性盒</strong>、<strong>flex容器</strong>）。注意这里说的容器并不是单纯的dom元素所指代的容器，而是特指设置了弹性盒布局的dom元素。</li>
<li><code>flex item</code>，即所谓的<strong>条目</strong>（或者称之为<strong>flex条目</strong>）。这里的条目其实就是容器的子元素。比如<code>ul</code>元素为一个flex容器，那么其内部包含的<code>li</code>元素就是flex条目。大部分时候，不同的弹性盒布局真正产生变化的其实就是条目的布局行为发生了变化。</li>
<li><code>main axis</code>和<code>cross axis</code>，即所谓的<strong>主轴</strong>和<strong>交叉轴</strong>（有的翻译文章也称之为<strong>侧轴</strong>）。这两个属性定义flex布局方向。需要注意的是，虽然图中主轴是水平方向，交叉轴是垂直方向，但是这并不是固定的，开发人员完全自定义主轴和交叉轴的方向。<ol>
<li>在使用flex布局时，一般我们需要首先明确主轴的方向，然后交叉轴的方向也会随之确定下来。因为<strong>交叉轴的方向始终是与主轴的方向是垂直的</strong>。</li>
<li>flex容器中flex条目可以根据布局需要排列成<strong>单行</strong>或者<strong>多行</strong>。</li>
<li>主轴<code>main axis</code>的作用是确定每一行上flex条目的排列方向。</li>
<li>（当flex条目成多行排列时）交叉轴<code>cross axis</code>的作用是确定行与行之间的排列方向。</li>
</ol>
</li>
<li><code>main start</code>和<code>main end</code>，即所谓的<strong>主轴起点</strong>和<strong>主轴终点</strong>。<ol>
<li>明确主轴的方向后（如上所述，不管是主轴还是交叉轴其实只有两种方向，即水平或者垂直），还需要确定他们各自的排列方向。</li>
<li>假如已经明确主轴的方向是水平的，那么其排列方向仍然会有两种可选，一种是<strong>从左到右</strong>的排列方向（flex条目从左到右依次堆放），另一种是<strong>从右到左</strong>排列方向（flex条目从右到左依次堆放）。</li>
<li>主轴起点在左主轴终点在右即为<strong>从左到右</strong>的排列方向。（如上图所示）</li>
<li>主轴起点在右主轴终点在左即为<strong>从右到左</strong>的排列方向。</li>
</ol>
</li>
<li><code>cross start</code>和<code>cross end</code>，即所谓的<strong>交叉轴起点</strong>和<strong>交叉轴终点</strong>。<ol>
<li>跟主轴起点和主轴终点的含义类似，交叉轴起点和交叉轴终点明确了行与行之间的排列顺序。</li>
<li>假如已经明确交叉轴的方向是垂直的，那么其排列方向仍然将会有两种可选，一种是<strong>从上到下</strong>的排列方向（第二行在第一行的下方），另一种是<strong>从下到上</strong>的排列方向（第二行在第一行的上方）。</li>
</ol>
</li>
<li>所以，在flex容器进行布局时，在每一行中会把其中的flex条目从主轴起始位置开始，依次排列到主轴结束位置。当flex容器中存在多行时，会把每一行从交叉轴起始位置开始，依次排列到交叉轴结束位置。</li>
<li><code>main size</code>和<code>cross size</code>，即所谓的<strong>主轴尺寸</strong>和<strong>交叉轴尺寸</strong>。对应dom元素在主轴和交叉轴上的大小。<ol>
<li>如果主轴方向是水平的（那么交叉轴方向肯定是垂直的），此时主轴尺寸即是dom元素（flex容器）的宽度属性，交叉轴尺寸即是dom元素（flex容器）的高度属性。</li>
<li>如果主轴方向是垂直的，那么主轴尺寸和交叉轴尺寸对应的dom元素宽高属性与之前相反。</li>
</ol>
</li>
</ol>
<h3 id="新旧语法"><a href="#新旧语法" class="headerlink" title="新旧语法"></a>新旧语法</h3><p>flex布局先后有两种语法，一种是W3C于2009年发布的旧语法，另一种是W3C最新发布的新语法。<br>旧语法中，所有的flex属性都以<code>box</code>打头，flex设置为<code>display: box</code>。<br>新语法中，所有的flex属性都以<code>flex</code>打头，flex设置为<code>display: flex</code>。<br>关于新旧语法在实际使用时，肯定是推荐使用新语法的，虽然新语法的浏览器支持性不如旧语法，但是毕竟是旧的语法，迟早是要淘汰的，而且新语法的表现也更加一致。</p>
<h2 id="属性详解"><a href="#属性详解" class="headerlink" title="属性详解"></a>属性详解</h2><p><strong>注意</strong>，flex布局中的css样式声明与一般的css声明不同，它会有两个作用对象，分别是<strong>flex容器</strong>和<strong>flex条目</strong>。即，有的flex属性只能作用于flex容器，而有的flex属性只能作用于flex条目。下面我们针对flex布局的各个属性分别作详细说明。</p>
<h3 id="问题引导"><a href="#问题引导" class="headerlink" title="问题引导"></a>问题引导</h3><p>现在有一个无序列表（<code>ul</code>元素），其包含了6个列表项（<code>li</code>元素），如何做可以让列表项（<code>li</code>元素）自适应父容器的尺寸？换句话说，当父容器尺寸足够大时，所有的<code>li</code>元素平铺成一行；当父容器的尺寸减小时，<code>li</code>元素自动换行。<br>大家都能想到的一种常规做法应该就是给<code>li</code>元素设置浮动。不过这里我们将使用flex布局来实现这种布局需求。html和css代码如下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"flex-container"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"flex-item"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"flex-item"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"flex-item"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"flex-item"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"flex-item"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"flex-item"</span>&gt;</span>6<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span> &#123;</div><div class="line"> <span class="attribute">list-style</span>: none;</div><div class="line"> <span class="attribute">display</span>: flex;</div><div class="line"> <span class="attribute">flex-direction</span>: row;</div><div class="line"> <span class="attribute">flex-wrap</span>: wrap;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.flex-item</span> &#123;</div><div class="line"> <span class="attribute">margin</span>: <span class="number">5px</span>;</div><div class="line"> <span class="attribute">width</span>: <span class="number">300px</span>;</div><div class="line"> <span class="attribute">height</span>: <span class="number">300px</span>;</div><div class="line"> <span class="attribute">text-align</span>: center;</div><div class="line"> <span class="attribute">line-height</span>: <span class="number">300px</span>;</div><div class="line"> <span class="attribute">background-color</span>: gold;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在可以自行缩放浏览器的窗口，观察<code>.flex-item</code>块的行为。</p>
<h3 id="display-flex"><a href="#display-flex" class="headerlink" title="display: flex"></a>display: flex</h3><p>在之前说过，要想使用弹性盒布局必须事先指定一个容器，这个容器就是所谓的flex容器。那么如何指定flex容器呢？很简单，将其<code>display</code>属性设置为<code>flex</code>即可。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container</span>&#123;</div><div class="line">  <span class="attribute">display</span>: flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>注意</strong>，如果需要在内联的场景下使用flex布局，则需要设置<code>display: inline-flex</code>。而且以下几种属性设置在弹性盒布局中是不起作用的。</p>
<ol>
<li>浮动元素（<code>float</code>）</li>
<li>清除浮动（<code>clear</code>）</li>
<li>css3多列布局（<code>columns-*</code>）</li>
<li>垂直居中（<code>vertical-align</code>）</li>
<li>首行/首字符选择伪类（<code>::first-line</code>和<code>::first-letter</code>）</li>
</ol>
<h3 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h3><p><code>flex-direction</code>属性的作用是设置<strong>主轴</strong>方向。我们之前有说过，一旦主轴方向确定，那么连带的交叉轴的方向也会确定下来。这样就确定了flex条目基本的排列方式。<br>下面我们来看一下<code>flex-direction</code>的具体用法，如下表:</p>
<table>
<thead>
<tr>
<th>可选值</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>row</td>
<td>横向从左到右排列</td>
<td>即左对齐。此为默认值</td>
</tr>
<tr>
<td>row-reverse</td>
<td>反转横向排列（从右到左排列）</td>
<td>即右对齐</td>
</tr>
<tr>
<td>column</td>
<td>纵向排列（从上到下排列）</td>
<td>即设置主轴方向为垂直方向</td>
</tr>
<tr>
<td>column-reverse</td>
<td>反转纵向排列（从下到上排列）</td>
<td>主轴方向为垂直方向，但是越后面的flex条目反而在上方</td>
</tr>
</tbody>
</table>
<h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p><code>flex-wrap</code>属性用于设置当所有的flex条目的尺寸之和超过flex容器的主轴尺寸时应该采取的行为。<br>下面让我们来看一下<code>flex-wrap</code>的具体用法，如下表：</p>
<table>
<thead>
<tr>
<th>可选值</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>nowrap</td>
<td>容器中的条目只占满容器在主轴方向上的一行，此时可能出现条目互相重叠或超出容器范围的现象</td>
<td>此为默认值</td>
</tr>
<tr>
<td>wrap</td>
<td>当容器中的条目超出主轴方向上的一行时，会把条目排列到下一行。而下一行的位置与交叉轴的方向一致</td>
<td>交叉轴的存在感就是在此</td>
</tr>
<tr>
<td>wrap-reverse</td>
<td>与<code>wrap</code>的含义类似，不同的是下一行的位置与交叉轴的方向相反。</td>
<td>-</td>
</tr>
</tbody>
</table>
<h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p>之前说的两个属性<code>flex-direction</code>和<code>flex-wrap</code>，从某种意义上来说就是设置flex布局的主轴和交叉轴。一旦flex布局的主轴和交叉轴确定下来，基本上整个布局中flex条目的排列方式我们就可以自行脑补出来了。<br>而<code>flex-flow</code>属性其实就是<code>flex-direction</code>和<code>flex-wrap</code>的复合属性。所以下面两段代码的效果是一致的。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-container1</span> &#123;</div><div class="line"> <span class="attribute">flex-direction</span>: row;</div><div class="line"> <span class="attribute">flex-wrap</span>: wrap;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.flex-container2</span> &#123;</div><div class="line"> <span class="attribute">flex-flow</span>: row wrap;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>前面说的几个属性其实都是针对flex容器的设置。而<code>order</code>属性是针对flex条目的。它的作用是自定义flex容器中条目的顺序。其用法示例如下:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-item</span><span class="selector-pseudo">:last-child</span> &#123;</div><div class="line"><span class="comment">/*作用是让最后一个flex条目排在最前,order越小越排在前,且可设置为负值*/</span></div><div class="line"> <span class="attribute">order</span>: -<span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="flex条目的弹性设置"><a href="#flex条目的弹性设置" class="headerlink" title="flex条目的弹性设置"></a>flex条目的弹性设置</h3><p>弹性盒模型的真正牛逼的地方在于flex容器中的<strong>flex条目的尺寸是弹性的</strong>。这是啥意思呢？个人觉得它包含下面的几层含义：</p>
<ul>
<li>主轴尺寸不够大时，使用<code>flex-wrap</code>可以让flex条目自动换行。</li>
<li>主轴尺寸不够大时，还可以缩小条目的尺寸防止溢出容器范围。</li>
<li>主轴尺寸足够大时，可以适当扩展条目的尺寸来占用容器的额外空白空间。<br>flex条目尺寸的弹性由3个css属性来确定，分别是<code>flex-basis</code>、<code>flex-grow</code>和<code>flex-shrink</code>。他们的相关说明如下：</li>
</ul>
<h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p><code>flex-basis</code>用于设置flex条目的初始尺寸（未进行任何调整之前）。当设置为<code>auto</code>时，则实际使用的值是主轴尺寸属性的值。若主轴尺寸也是<code>auto</code>，那么使用的值由条目内容的尺寸来确定。(默认值是auto)</p>
<h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>当主轴尺寸足够大时，flex条目在容器内一行就全部排列完了，此时容器的空间还有剩余，那么可用<code>flex-grow</code>扩展flex条目。举个例子，一个容器中有3个flex条目，其<code>flex-grow</code>属性分别如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.flex-item:nth-child(1) &#123;</div><div class="line"> flex-grow: 1;</div><div class="line">&#125;</div><div class="line">.flex-item:nth-child(2) &#123;</div><div class="line"> flex-grow: 2;</div><div class="line">&#125;</div><div class="line">.flex-item:nth-child(3) &#123;</div><div class="line"> flex-grow: 3;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同时，flex容器的宽度是800px，每个条目的宽度为200px，所以容器还将剩余200px。由于条目都设置了<code>flex-grow</code>属性，那么此三个条目将按比例分配容器的剩余空间。第一个条目将得到200 <em> 1/6 = 33px左右，第二个条目将得到200 </em> 2/6 = 66px，第三个条目将得到200 * 3/6 = 99px左右。</p>
<h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p><code>flex-shrink</code>在使用上类似<code>flex-grow</code>，不过它使用于设置当主轴尺寸不够大时缩小flex条目。同样的，我们来举个例子，一个容器中有3个flex条目，每个felx条目的尺寸为200px，容器的尺寸为500px。很明显此时容器尺寸已经放不下其中三个flex条目了。我们对每个flex条目设置<code>flex-shrink</code>属性<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.flex-item</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</div><div class="line"> <span class="attribute">flex-shrink</span>: <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.flex-item</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</div><div class="line"> <span class="attribute">flex-shrink</span>: <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.flex-item</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</div><div class="line"> <span class="attribute">flex-shrink</span>: <span class="number">3</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果我们希望flex容器能够刚刚好将三个flex条目放下，我们需要缩小的尺寸为600-500 = 100px。接下来三个条目将根据<code>flex-shrink</code>属性按比例的分摊需要缩小的尺寸，即分别为100 <em> 1/6 = 16.6px，100 </em> 2/6 = 33.3px，100 * 3/6 = 50px。所以三个flex条目最终的尺寸为200 - 16.6 = 183.4px，200 - 33.3 = 166.7px，200 - 50 = 150px。</p>
<h4 id="多行弹性布局注意事项"><a href="#多行弹性布局注意事项" class="headerlink" title="多行弹性布局注意事项"></a>多行弹性布局注意事项</h4><p>我们使用<code>flex-grow</code>和<code>flex-shrink</code>属性对flex条目进行扩展或者缩小时，这些操作其实是以<strong>行</strong>为单位来操作的。因此当有多行弹性布局时，可能会有一些出乎意料的表现。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">.flex-container &#123;</div><div class="line"> width: 999px;</div><div class="line"> flex-direction: row;</div><div class="line"> flex-wrap: wrap;</div><div class="line"> display: flex;</div><div class="line">&#125;</div><div class="line">.flex-item &#123;</div><div class="line"> width: 300px;</div><div class="line"> flex-grow: 1;</div><div class="line"> flex-shrink: 1;</div><div class="line"> flex-basis: auto;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"flex-container"</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"flex-item"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"flex-item"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"flex-item"</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"flex-item"</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>容器宽度999px，flex条目300px，允许多行排列。那么第一行会排列三个，第二行会排列一个，因设置了<code>flex-grow: 1</code>，第一行剩余的99px会被评分到三个flex条目，第二行剩余的699px也会被平分到第二行的flex条目，由于第二行只有一个条目，所以第二行的条目的宽度为999px。</p>
<h3 id="flex复合属性"><a href="#flex复合属性" class="headerlink" title="flex复合属性"></a>flex复合属性</h3><p>如你所见，<code>flex</code>是一个复合属性，它的语法如下：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flex: none | auto | [flex-grow] | [flex-shrink] | [flex-basis]</div></pre></td></tr></table></figure></p>
<p>其中<code>none</code>的含义为：<code>0 0 auto</code>, 即<code>flex-grow: 0</code>，<code>flex-shrink: 0</code>， <code>flex-basis: auto</code>。<br>其中<code>auto</code>的含义为：<code>1 1 auto</code>, 即<code>flex-grow: 1</code>，<code>flex-shrink: 1</code>， <code>flex-basis: auto</code>。<br>当<code>flex-basis</code>被省略时，其值为<code>0%</code>。</p>
<h3 id="flex条目的对齐"><a href="#flex条目的对齐" class="headerlink" title="flex条目的对齐"></a>flex条目的对齐</h3><p>当flex容器中flex条目的尺寸和排列都确定下来之后，我们还可以设置这些flex条目在容器中的对齐方式。目前有三种对齐方式。</p>
<h4 id="基于margin-auto对齐"><a href="#基于margin-auto对齐" class="headerlink" title="基于margin: auto对齐"></a>基于<code>margin: auto</code>对齐</h4><p>第一种对齐方式是<strong>使用空白边</strong>，即<code>margin: auto</code>。在使用自动空白边时，flex容器中额外的空白空间将会由被声明为<code>auto</code>的空白边占据。这种方式在W3C的官方文档被称之为<em>non-normative</em>，更加像是一种奇淫巧计。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">/about</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">/projects</span>&gt;</span>Projects<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">/interact</span>&gt;</span>Interact<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"> <span class="tag">&lt;<span class="name">li</span> <span class="attr">id</span>=<span class="string">"login"</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">/login</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"> <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></div><div class="line">ul &#123;</div><div class="line"> list-style: none;</div><div class="line"> display: flex;</div><div class="line">&#125;</div><div class="line">li &#123;</div><div class="line"> min-width: min-content;</div><div class="line">&#125;</div><div class="line">#login &#123;</div><div class="line"> margin-left: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>示例中的<code>#login</code>元素通过简单的<code>margin-left</code>设置，占据所有的剩余空白。</p>
<h4 id="基于主轴对齐"><a href="#基于主轴对齐" class="headerlink" title="基于主轴对齐"></a>基于主轴对齐</h4><p>第二种对齐方式是基于主轴方向上的对齐策略。可以通过<code>justify-content</code>属性来进行设置。借助此属性，我们可以调整flex条目在主轴方向上的对齐策略。<br>我们来看下<code>justify-content</code>属性的基本用法，（<strong>注意</strong>，<code>justify-content</code>用于设置flex容器）</p>
<table>
<thead>
<tr>
<th>可选值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>flex-start</td>
<td>条目集中于该行的起始位置。第一个条目与其所在行在主轴起始方向上的边界保持对齐，其余的条目按照顺序依次排列。</td>
</tr>
<tr>
<td>flex-end</td>
<td>条目集中于该行的结束方向。最后一个条目与其所在行在主轴结束方向上的边界保持对齐，其余的条目按照顺序依次排列。</td>
</tr>
<tr>
<td>center</td>
<td>条目集中于该行的中央。条目都往该行的中央排列，在主轴起始方向和结束方向上留有同样大小的空白空间。如果空白空间不足，则条目会在两个方向上超出同样的空间。</td>
</tr>
<tr>
<td>space-between</td>
<td>第一个条目与其所在行在主轴起始方向上的边界保持对齐，最后一个条目与其所在行在主轴结束方向上的边界保持对齐。空白空间在条目之间平均分配，使得相邻条目之间的空白尺寸相同。</td>
</tr>
<tr>
<td>space-around</td>
<td>类似于<code>space-between</code>，不同的是第一个条目和最后一个条目与该行的边界之间同样存在空白空间，该空白空间的尺寸是条目之间的空白空间的尺寸的一半。</td>
</tr>
</tbody>
</table>
<h4 id="基于交叉轴对齐"><a href="#基于交叉轴对齐" class="headerlink" title="基于交叉轴对齐"></a>基于交叉轴对齐</h4><p>第三种对齐方式是基于交叉轴方向上的对齐策略。此种方式中，我们有两个属性可以做相关设置，它们分别是<code>align-items</code>和<code>align-self</code>。其中前者是用来设置flex容器的，后者是用来设置flex条目的，这两个属性的作用对象是不同的。在某些场景下，我们可以对flex条目设置<code>align-self</code>来复写flex容器指定的对齐方式。<br>我们来看看<code>align-items</code>的基本用法</p>
<table>
<thead>
<tr>
<th>可选值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>flex-start</td>
<td>条目与其所在行在交叉轴起始方向上的边界保持对齐。</td>
</tr>
<tr>
<td>flex-end</td>
<td>条目与其所在行在交叉轴结束方向上的边界保持对齐。</td>
</tr>
<tr>
<td>center</td>
<td>条目的空白边盒子（margin box）在交叉轴上居中。如果交叉轴尺寸小于条目的尺寸，则条目会在两个方向上超出相同大小的空间。</td>
</tr>
<tr>
<td>baseline</td>
<td>条目在基准线上保持对齐。在所有条目中，基准线与交叉轴起始方向上的边界距离最大的条目，它与所在行在交叉轴方向上的边界保持对齐。</td>
</tr>
<tr>
<td>stretch</td>
<td>如果条目的交叉轴尺寸的计算值是<code>auto</code>，则其实际使用的值会使得条目在交叉轴方向上尽可能地占满。</td>
</tr>
</tbody>
</table>
<p><code>align-self</code>的属性基本与<code>align-items</code>一致（用法和含义基本都一样）。不过<code>align-self</code>除了<code>align-items</code>属性可选值之外，还可以设置为<code>auto</code>。当设置为<code>auto</code>时，其值是父节点的属性<code>align-items</code>的值,如果该节点没有父节点，则为<code>stretch</code>。</p>
<h3 id="flex行的对齐"><a href="#flex行的对齐" class="headerlink" title="flex行的对齐"></a>flex行的对齐</h3><p>前面说完了flex容器中flex条目的对齐方式。这里我们再来说一下<strong>flex行</strong>的对齐。什么叫flex行？W3C官方文档中提到了一个名词，叫做<a href="http://www.w3.org/TR/css-flexbox/#flex-lines" target="_blank" rel="external"><strong>Flex Lines</strong></a>。<br>那么什么叫Flex Lines呢？说的直白点就是多行flex布局时，主轴方向上的每一行就是Flex Lines。<br><code>align-content</code>属性的作用和<code>justify-content</code>属性很相似，只不过<code>justify-content</code>是用于在主轴方向上对齐行内的flex条目，而<code>align-content</code>是用于设置行与行之间的对齐策略。<br><code>align-content</code>详细的用法如下表:</p>
<table>
<thead>
<tr>
<th>可选值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>flex-start</td>
<td>行集中于容器的交叉轴起始位置。第一行与容器在交叉轴起始方向上的边界保持对齐，其余行按照顺序依次排列。</td>
</tr>
<tr>
<td>flex-end</td>
<td>行集中于容器的交叉轴结束位置。第一行与容器在交叉轴结束方向上的边界保持对齐，其余行按照顺序依次排列。</td>
</tr>
<tr>
<td>center</td>
<td>行集中于容器的中央。行都往容器的中央排列，在交叉轴起始方向和结束方向上留有同样大小的空白空间。如果空白空间不足，则行会在两个方向上超出同样的空间。</td>
</tr>
<tr>
<td>space-between</td>
<td>行在容器中均匀分布。第一行与容器在交叉轴起始方向上的边界保持对齐，最后一行与容器在交叉轴结束方向上的边界保持对齐。空白空间在行之间平均分配，使得相邻行之间的空白尺寸相同。</td>
</tr>
<tr>
<td>space-around</td>
<td>类似于<code>space-between</code>，不同的是第一行条目和最后一个行目与容器行的边界之间同样存在空白空间，而该空白空间的尺寸是行目之间的空白空间的尺寸的一半。</td>
</tr>
<tr>
<td>stretch</td>
<td>伸展行来占满剩余的空间。多余的空间在行之间平均分配，使得每一行的交叉轴尺寸变大。</td>
</tr>
</tbody>
</table>
<h3 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h3><p>本文的<strong>新旧语法</strong>中曾经提到，弹性盒模型官方有好几个版本的语法，这是因为其规范本身有过多个不同版本，因为浏览器对于该规范的支持也存在一些不一致。大致来说总共有三个不同版本的语法。</p>
<ul>
<li>最新规范：最新版本规范的语法，即<code>display: flex</code>。</li>
<li>中间版本：2011年的非官方规范语法，即<code>display: flexbox</code>。</li>
<li>老规范：2009年的规范的语法，即<code>display: box</code>。<br>浏览器的支持情况如下，</li>
</ul>
<table>
<thead>
<tr>
<th>Chrome</th>
<th>Safari</th>
<th>Firefox</th>
<th>Opera</th>
<th>IE</th>
<th>Android</th>
<th>iOS</th>
</tr>
</thead>
<tbody>
<tr>
<td>21+（新规范）</td>
<td>6.1+（新规范）</td>
<td>22+（新规范）</td>
<td>12.1+（新规范）</td>
<td>11+（新规范）</td>
<td>4.4+（新规范）</td>
<td>7.1+（新规范）</td>
</tr>
<tr>
<td>20-（老规范）</td>
<td>3.1+（老规范）</td>
<td>2-21（老规范）</td>
<td>-</td>
<td>10（中间版本）</td>
<td>2.1+（老规范）</td>
<td>3.2+（老规范）</td>
</tr>
</tbody>
</table>
<p>从上面看来，弹性盒布局模型基本已经被主流的现代浏览器所支持。除了IE系的浏览器拖了后腿之外，基本可以无障碍的使用。不过虽然如此，我们为了兼容性，在实际使用的时候除了规范中定义的属性之外，最好添加不同浏览器内核的私有前缀。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据库生成pdm]]></title>
      <url>https://heji1993.github.io/2016/09/21/%E4%BD%BF%E7%94%A8powerdesigner%E5%80%92%E8%BD%AC%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      <content type="html"><![CDATA[<p>如何使用powerdesigner根据数据库生成pdm。</p>
<a id="more"></a>
<p>由于powerdesigner是32位的应用程序，所以需要下载32位的JDK。</p>
<ul>
<li>配置系统变量<br>CLASSPATH = E:\Workspaces\my-jar\mysql-connector-java-5.1.7-bin.jar  （如果需要反转Oracle数据库，这里的值是Oracle驱动包的路径）<br>JAVA_HOME = D:\Java\jdk1.6.0_13\;<br>Path = %Path%;% JAVA_HOME %\bin;  </li>
<li>PowerDesigner配置<br>PowerDesigner Tools –&gt; General Options –&gt; Variables：<br>JAR D:\Java\jdk1.6.0_13\bin\jar.exe<br>JAVA D:\Java\jdk1.6.0_13\bin\java.exe<br>JAVAC D:\Java\jdk1.6.0_13\bin\javac.exe<br>JAVADOC D:\Java\jdk1.6.0_13\bin\javadoc.exe</li>
<li>打开Powerdesigner，文件–&gt;Reverse Engineer –&gt; Database…<br><img src="index_files/6736595f-4701-424b-9b3b-5bb534aa573c.png" alt=""></li>
<li>使用数据源<br><img src="index_files/623e5892-970b-46dc-a8bd-2f7dcd52ed5f.png" alt=""></li>
<li>配置数据库连接<br><img src="index_files/76e72467-d912-45cc-94c0-57a33a208c74.png" alt=""></li>
<li>添加一个数据源并测试连接<br><img src="index_files/ad10bbc3-74da-4786-b156-138d693c7398.png" alt=""><br><img src="index_files/9739f9b8-5e3c-4796-bd6b-9e64f8634dc9.png" alt=""></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS学习笔记]]></title>
      <url>https://heji1993.github.io/2016/09/14/Javascript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>Javascript入门教程。</p>
<a id="more"></a>
<h1 id="常用技巧-推荐学习工具：javascripting"><a href="#常用技巧-推荐学习工具：javascripting" class="headerlink" title="常用技巧(推荐学习工具：javascripting)"></a>常用技巧(推荐学习工具：javascripting)</h1><hr>
<ul>
<li><strong> 本教程使用chrome的console演示。chrome的console可以按住Ctrl和+加大字体，使用Ctrl+0复原 </strong></li>
<li><p><strong> js中获取iframe的元素或者调用iframe的方法 </strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">     iframeObj.contentWindow.document</div><div class="line">     iframeObj.contentWindow.functionName();</div></pre></td></tr></table></figure>
</li>
<li><p>高级for循环</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> index <span class="keyword">in</span> object)</div></pre></td></tr></table></figure>
<p>当用于数组时，index表示数组元素的索引<br>当用于对象时，index表示对象属性的key</p>
</li>
<li>javascript灵活性之一：<br>可以通过传递回调函数避免过度嵌套</li>
<li><p>javascript灵活性之二：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> tasks = [<span class="string">"init"</span>,<span class="string">"start"</span>,<span class="string">"stop"</span>,<span class="string">"destory"</span>];</div><div class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> index <span class="keyword">in</span> tasks)&#123;</div><div class="line">          <span class="comment">//相当于调用init();start();...</span></div><div class="line">          tasks[index]();</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>数组的map方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">//Array.map(callback(item,index))返回由数组中每个元素调用回调函数之后的新元素组成的数组。join方法把数组转换为字符串,参数表示分隔符</span></div><div class="line">     <span class="keyword">var</span> body = items.map(<span class="function"><span class="keyword">function</span>(<span class="params">item,i</span>)</span>&#123;</div><div class="line">          <span class="keyword">return</span> i+<span class="string">")"</span>+item;</div><div class="line">     &#125;).join(<span class="string">'\n'</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>substring(start,[end])和slice(start,[end])<br>substring方法所有参数必须为正数，否则返回空<br>slice方法如果参数start为负数，end为空，表示从尾部开始算起。比如’hello’.slice(-2)—&gt;lo<br>如果参数start为负数，end也必须为负数，且要比start大，否则返回空</p>
</li>
<li><p>splice()方法再论（数组是以0作为首元素的下标，splice()方法返回删除的元素）<br>当只有一个参数时，以参数为起始位置删除后面所有元素例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> items = [<span class="string">'Bob'</span>,<span class="string">'Jack'</span>,<span class="string">'Lily'</span>,<span class="string">'Sam'</span>];</div><div class="line">     <span class="keyword">var</span> array = items.splice(<span class="number">2</span>);</div><div class="line">     <span class="built_in">console</span>.log(array);  <span class="comment">//['Lily','Sam']</span></div></pre></td></tr></table></figure>
<p>当有两个参数时例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> items = [<span class="string">'Bob'</span>,<span class="string">'Jack'</span>,<span class="string">'Lily'</span>,<span class="string">'Sam'</span>];</div><div class="line">     <span class="keyword">var</span> array = items.splice(<span class="number">2</span>，<span class="number">1</span>);</div><div class="line">     <span class="built_in">console</span>.log(array);  <span class="comment">//['Lily']</span></div><div class="line">     <span class="built_in">console</span>.log(items); <span class="comment">//['Bob','Jack','Sam']</span></div></pre></td></tr></table></figure>
<p>当有多个参数时：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> items = [<span class="string">'Bob'</span>,<span class="string">'Jack'</span>,<span class="string">'Lily'</span>,<span class="string">'Sam'</span>];</div><div class="line">     <span class="keyword">var</span> array = items.splice(<span class="number">2</span>，<span class="number">1</span>，<span class="string">'Tom'</span>，<span class="string">'Lucy'</span>);</div><div class="line">     <span class="built_in">console</span>.log(array);  <span class="comment">//['Lily']</span></div><div class="line">     <span class="built_in">console</span>.log(items); <span class="comment">//['Bob','Jack','Tom','Lucy','Sam']</span></div></pre></td></tr></table></figure>
</li>
<li><p>JSON.parse(str)和JSON. stringify(jsonObj)<br>JSON.parse(str)用于把字符串转化为JSON对象<br>JSON.stringify(obj)用于把JSON对象转化为字符串</p>
</li>
<li><p>父页面获取iframe子页面的元素<br>JS版本：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">      <span class="keyword">var</span> frameDoc=<span class="built_in">document</span>.getElementById(<span class="string">'iframeId'</span>).contentWindow.document  <span class="comment">//document对象</span></div><div class="line">       <span class="keyword">var</span> frameBody=<span class="built_in">document</span>.getElementById(<span class="string">'iframeId'</span>).contentWindow.document.body   <span class="comment">//body对象</span></div></pre></td></tr></table></figure>
<p>JQ版本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">     $(<span class="string">"#iframe的ID"</span>).contents().find(<span class="string">"#iframe中的控件ID"</span>).click();<span class="comment">//jquery 方法1 必须在iframe加载完后才有效</span></div></pre></td></tr></table></figure>
</li>
<li><p>在iframe中获取父页面的id元素<br>JS版本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> obj=<span class="built_in">window</span>.parent.document.getElementById(<span class="string">'objId'</span>)</div></pre></td></tr></table></figure>
<p>JQ版本</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">     $(<span class="string">'#父级窗口的objId'</span>, <span class="built_in">window</span>.parent.document).css(<span class="string">'height'</span>:<span class="string">'height);  // window可省略不写</span></div></pre></td></tr></table></figure>
</li>
<li><p>iframe高度自适应</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     $(<span class="string">'#iframeId'</span>).load(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;  </div><div class="line">          <span class="keyword">var</span> iframeHeight=$(<span class="keyword">this</span>).contents().height(); </div><div class="line">          $(<span class="keyword">this</span>).height(iframeHeight+<span class="string">'px'</span>);  </div><div class="line">     &#125;);</div></pre></td></tr></table></figure>
</li>
<li><p>JS字符串中的方法传参数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> html=<span class="string">"&lt;a onclick='selecthoods(\" "</span>+a + <span class="string">"\"); &gt;AAA&lt;/a&gt;"</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>JS实现模拟安卓端连续点击返回键退出应用的demo</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">//监听返回键</span></div><div class="line">                app.initialize(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                    <span class="built_in">document</span>.addEventListener(<span class="string">"backbutton"</span>, shutDown, <span class="literal">false</span>);</div><div class="line">                &#125;);</div><div class="line">                <span class="keyword">var</span> beginDate;          <span class="comment">// 两次点击退出按钮开始时间 </span></div><div class="line">                <span class="keyword">var</span> isToast = <span class="literal">false</span>;    <span class="comment">// 是否弹出弹框 </span></div><div class="line">                <span class="function"><span class="keyword">function</span> <span class="title">shutDown</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                     <span class="keyword">var</span> endDate = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(); <span class="comment">// 两次点击退出按钮结束时间 </span></div><div class="line">                     <span class="comment">// 提示过Toast并且两次点击时间小于2S </span></div><div class="line">                     <span class="keyword">if</span> ( isToast &amp;&amp; endDate - beginDate &lt; <span class="number">2000</span> ) &#123; </div><div class="line">                         beginDate = endDate; </div><div class="line">                         isToast = <span class="literal">false</span>; </div><div class="line">                         powerdata.router.exit(<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;&#125;);</div><div class="line">                     &#125; <span class="keyword">else</span></div><div class="line">                         Toast(<span class="string">'再次点击退出程序'</span>,<span class="number">2000</span>);  </div><div class="line">                &#125;</div><div class="line"> </div><div class="line">                <span class="comment">//自定义弹框 2s消失 </span></div><div class="line">                 <span class="function"><span class="keyword">function</span> <span class="title">Toast</span>(<span class="params">msg,duration</span>)</span>&#123; </div><div class="line">                     isToast = <span class="literal">true</span>; </div><div class="line">                     beginDate = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(); </div><div class="line">                     duration=<span class="built_in">isNaN</span>(duration)?<span class="number">3000</span>:duration; <span class="comment">// duration是不是一个数字     </span></div><div class="line">                     <span class="keyword">var</span> m = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>); </div><div class="line">                     m.innerHTML = msg; </div><div class="line">                     m.style.cssText=<span class="string">"width:60%; min-width:150px; background:#000; opacity:0.5; height:40px; color:#fff; line-height:40px; text-align:center; border-radius:5px; position:fixed; top:80%; left:20%; z-index:999999; font-weight:bold;"</span>; </div><div class="line">                     <span class="built_in">document</span>.body.appendChild(m); </div><div class="line">                     setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </div><div class="line">                         <span class="keyword">var</span> d = <span class="number">0.5</span>; </div><div class="line">                         m.style.webkitTransition = <span class="string">'-webkit-transform '</span> + d + <span class="string">'s ease-in, opacity '</span> + d + <span class="string">'s ease-in'</span>; </div><div class="line">                         m.style.opacity = <span class="string">'0'</span>; </div><div class="line">                         setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">document</span>.body.removeChild(m) &#125;, d * <span class="number">1000</span>); </div><div class="line">                     &#125;, duration); </div><div class="line">                 &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>JS实现动态时间</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">               <span class="comment">//时间</span></div><div class="line">            <span class="function"><span class="keyword">function</span> <span class="title">getCurDate</span>(<span class="params"></span>)</span>&#123; </div><div class="line">                 <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>(); </div><div class="line">                 <span class="keyword">var</span> week; </div><div class="line">                 <span class="keyword">switch</span> (d.getDay())&#123; </div><div class="line">                     <span class="keyword">case</span> <span class="number">1</span>: week=<span class="string">"星期一"</span>; <span class="keyword">break</span>; </div><div class="line">                     <span class="keyword">case</span> <span class="number">2</span>: week=<span class="string">"星期二"</span>; <span class="keyword">break</span>; </div><div class="line">                     <span class="keyword">case</span> <span class="number">3</span>: week=<span class="string">"星期三"</span>; <span class="keyword">break</span>; </div><div class="line">                     <span class="keyword">case</span> <span class="number">4</span>: week=<span class="string">"星期四"</span>; <span class="keyword">break</span>; </div><div class="line">                     <span class="keyword">case</span> <span class="number">5</span>: week=<span class="string">"星期五"</span>; <span class="keyword">break</span>; </div><div class="line">                     <span class="keyword">case</span> <span class="number">6</span>: week=<span class="string">"星期六"</span>; <span class="keyword">break</span>; </div><div class="line">                     <span class="keyword">default</span>: week=<span class="string">"星期天"</span>; </div><div class="line">                 &#125; </div><div class="line">                 <span class="keyword">var</span> years = d.getFullYear(); </div><div class="line">                 <span class="keyword">var</span> month = add_zero(d.getMonth()+<span class="number">1</span>); </div><div class="line">                 <span class="keyword">var</span> days = add_zero(d.getDate()); </div><div class="line">                 <span class="keyword">var</span> hours = add_zero(d.getHours()); </div><div class="line">                 <span class="keyword">var</span> minutes = add_zero(d.getMinutes()); </div><div class="line">                 <span class="keyword">var</span> seconds=add_zero(d.getSeconds()); </div><div class="line">                 <span class="keyword">var</span> ndate = years+<span class="string">"年"</span>+month+<span class="string">"月"</span>+days+<span class="string">"日 "</span>+hours+<span class="string">":"</span>+minutes+<span class="string">":"</span>+seconds+<span class="string">" "</span>+week; </div><div class="line">                 $(<span class="string">'.nowTime'</span>).html(ndate)</div><div class="line">            &#125; </div><div class="line">            <span class="function"><span class="keyword">function</span> <span class="title">add_zero</span>(<span class="params">temp</span>)</span>&#123; </div><div class="line">                 <span class="keyword">if</span>(temp&lt;<span class="number">10</span>) <span class="keyword">return</span> <span class="string">"0"</span>+temp; </div><div class="line">                 <span class="keyword">else</span> <span class="keyword">return</span> temp; </div><div class="line">            &#125;  </div><div class="line">               setInterval(getCurDate,<span class="number">100</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="JavaScript简介"><a href="#JavaScript简介" class="headerlink" title="JavaScript简介"></a>JavaScript简介</h1><hr>
<ul>
<li>JavaScript历史<br>   在上个世纪的1995年，当时的网景公司正凭借其Navigator浏览器成为Web时代开启时最著名的第一代互联网公司。由于网景公司希望能在静态HTML页面上添加一些动态效果，于是叫Brendan Eich这哥们在两周之内设计出了JavaScript语言。你没看错，这哥们只用了10天时间。为什么起名叫JavaScript？原因是当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。</li>
<li>ECMAScript<br>   因为网景开发了JavaScript，一年后微软又模仿JavaScript开发了JScript，为了让JavaScript成为全球标准，几个公司联合ECMA（European Computer Manufacturers Association）组织定制了JavaScript语言的标准，被称为ECMAScript标准。 所以简单说来就是，ECMAScript是一种语言标准，而JavaScript是网景公司对ECMAScript标准的一种实现。<br>   那为什么不直接把JavaScript定为标准呢？因为JavaScript是网景的注册商标。</li>
<li>JavaScript版本<br>  由于JavaScript的标准——ECMAScript在不断发展，最新版ECMAScript 6标准（简称ES6）已经在2015年6月正式发布了，所以，讲到JavaScript的版本，实际上就是说它实现了ECMAScript标准的哪个版本。由于浏览器在发布时就确定了JavaScript的版本，加上很多用户还在使用IE6这种古老的浏览器，这就导致你在写JavaScript的时候，要照顾一下老用户，不能一上来就用最新的ES6标准写，否则，老用户的浏览器是无法运行新版本的JavaScript代码的。</li>
</ul>
<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><hr>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul>
<li>语法<br>JavaScript的语法和Java语言类似，每个语句以<code>;</code>结束，语句块用<code>{...}</code>。但是，JavaScript并不强制要求在每个语句的结尾加<code>;</code>，浏览器中负责执行JavaScript代码的引擎会自动在每个语句的结尾补上<code>;</code>。</li>
<li><p>注释<br>  以//开头直到行末的字符被视为行注释，注释是给开发人员看到，JavaScript引擎会自动忽略：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="comment">// 这是一行注释</span></div><div class="line">          alert(<span class="string">'hello'</span>); <span class="comment">// 这也是注释</span></div></pre></td></tr></table></figure>
<p>  另一种块注释是用/<em>…</em>/把多行字符包裹起来，把一大“块”视为一个注释：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="comment">/* 从这里开始是块注释</span></div><div class="line">          仍然是注释</div><div class="line">          仍然是注释</div><div class="line">          注释结束 */</div></pre></td></tr></table></figure>
</li>
<li><p>大小写<br>  请注意，JavaScript严格区分大小写，如果弄错了大小写，程序将报错或者运行不正常。</p>
</li>
</ul>
<h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><ul>
<li><p>Number<br>  JavaScript不区分整数和浮点数，统一用Number表示，以下都是合法的Number类型：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          <span class="number">123</span>; <span class="comment">// 整数123</span></div><div class="line">          <span class="number">0.456</span>; <span class="comment">// 浮点数0.456</span></div><div class="line">          <span class="number">1.2345e3</span>; <span class="comment">// 科学计数法表示1.2345x1000，等同于1234.5</span></div><div class="line">          <span class="number">-99</span>; <span class="comment">// 负数</span></div><div class="line">          <span class="literal">NaN</span>; <span class="comment">// NaN表示Not a Number，当无法计算结果时用NaN表示</span></div><div class="line">          <span class="literal">Infinity</span>; <span class="comment">// Infinity表示无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity</span></div></pre></td></tr></table></figure>
<p>  Number可以直接做四则运算，规则和数学一致：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">          <span class="number">1</span> + <span class="number">2</span>; <span class="comment">// 3</span></div><div class="line">          (<span class="number">1</span> + <span class="number">2</span>) * <span class="number">5</span> / <span class="number">2</span>; <span class="comment">// 7.5</span></div><div class="line">          <span class="number">2</span> / <span class="number">0</span>; <span class="comment">// Infinity</span></div><div class="line">          <span class="number">0</span> / <span class="number">0</span>; <span class="comment">// NaN</span></div><div class="line">         <span class="comment">// 注意%是求余运算。</span></div><div class="line">          <span class="number">10</span> % <span class="number">3</span>; <span class="comment">// 1</span></div><div class="line">          <span class="number">10.5</span> % <span class="number">3</span>; <span class="comment">// 1.5</span></div></pre></td></tr></table></figure>
</li>
<li><p>字符串<br>  字符串是以单引号’或双引号”括起来的任意文本，比如<code>&#39;abc&#39;</code>，<code>&quot;xyz&quot;</code>等等。请注意，<code>&#39;&#39;</code>或<code>&quot;&quot;</code>本身只是一种表示方式，不是字符串的一部分，因此，字符串<code>&#39;abc&#39;</code>只有<code>a，b，c</code>这3个字符。</p>
</li>
<li><p>布尔值<br>  布尔值和布尔代数的表示完全一致，一个布尔值只有true、false两种值，要么是true，要么是false，可以直接用true、false表示布尔值，也可以通过布尔运算计算出来：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="literal">true</span>; <span class="comment">// 这是一个true值</span></div><div class="line">          <span class="literal">false</span>; <span class="comment">// 这是一个false值</span></div><div class="line">          <span class="number">2</span> &gt; <span class="number">1</span>; <span class="comment">// 这是一个true值</span></div><div class="line">          <span class="number">2</span> &gt;= <span class="number">3</span>; <span class="comment">// 这是一个false值</span></div></pre></td></tr></table></figure>
<p>  <code>&amp;&amp;</code>运算是与运算，只有所有都为<code>true</code>，<code>&amp;&amp;</code>运算结果才是<code>true</code>：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">          <span class="literal">true</span> &amp;&amp; <span class="literal">true</span>; <span class="comment">// 这个&amp;&amp;语句计算结果为true</span></div><div class="line">          <span class="literal">true</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// 这个&amp;&amp;语句计算结果为false</span></div><div class="line">          <span class="literal">false</span> &amp;&amp; <span class="literal">true</span> &amp;&amp; <span class="literal">false</span>; <span class="comment">// 这个&amp;&amp;语句计算结果为false</span></div></pre></td></tr></table></figure>
<p>  <code>||</code>运算是或运算，只要其中有一个为<code>true</code>，<code>||</code>运算结果就是<code>true</code><br>  <code>!</code>运算是非运算，它是一个单目运算符，把<code>true</code>变成<code>false</code>，<code>false</code>变成<code>true</code>：</p>
</li>
<li><p>比较运算符<br>  当我们对Number做比较时，可以通过比较运算符得到一个布尔值：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          <span class="number">2</span> &gt; <span class="number">5</span>; <span class="comment">// false</span></div><div class="line">          <span class="number">5</span> &gt;= <span class="number">2</span>; <span class="comment">// true</span></div><div class="line">          <span class="number">7</span> == <span class="number">7</span>; <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>  实际上，JavaScript允许对任意数据类型做比较：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="literal">false</span> == <span class="number">0</span>; <span class="comment">// true</span></div><div class="line">          <span class="literal">false</span> === <span class="number">0</span>; <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>  要特别注意相等运算符==。JavaScript在设计时，有两种比较运算符：<br>  第一种是==比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；<br>  第二种是===比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。<br>  由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。<br>  另一个例外是NaN这个特殊的Number与所有其他值都不相等，包括它自己：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          <span class="literal">NaN</span> === <span class="literal">NaN</span>; <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>  唯一能判断NaN的方法是通过isNaN()函数：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          <span class="built_in">isNaN</span>(<span class="literal">NaN</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>  最后要注意浮点数的相等比较：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          <span class="number">1</span> / <span class="number">3</span> === (<span class="number">1</span> - <span class="number">2</span> / <span class="number">3</span>); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>  这不是JavaScript的设计缺陷。浮点数在运算过程中会产生误差，因为计算机无法精确表示无限循环小数。要比较两个浮点数是否相等，只能计算它们之差的绝对值，看是否小于某个阈值：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          <span class="built_in">Math</span>.abs(<span class="number">1</span> / <span class="number">3</span> - (<span class="number">1</span> - <span class="number">2</span> / <span class="number">3</span>)) &lt; <span class="number">0.0000001</span>; <span class="comment">// true</span></div></pre></td></tr></table></figure>
</li>
<li><p>null 和 undefined<br>  null表示一个“空”的值，它和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而null表示“空”。<br>  JavaScript的设计者希望用null表示一个空的值，而undefined表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用null。undefined仅仅在判断函数参数是否传递的情况下有用。</p>
</li>
<li><p>数组<br>  数组是一组按顺序排列的集合，集合的每个值称为元素。JavaScript的数组可以包括任意数据类型。例如：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">'Hello'</span>, <span class="literal">null</span>, <span class="literal">true</span>];</div></pre></td></tr></table></figure>
<p>  上述数组包含6个元素。数组用[]表示，元素之间用,分隔。另一种创建数组的方法是通过Array()函数实现：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 创建了数组[1, 2, 3]</span></div></pre></td></tr></table></figure>
<p>  然而，出于代码的可读性考虑，强烈建议直接使用<code>[]</code>。<br>  数组的元素可以通过索引来访问。请注意，索引的起始值为<code>0</code>：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">'Hello'</span>, <span class="literal">null</span>, <span class="literal">true</span>];</div><div class="line">          arr[<span class="number">0</span>]; <span class="comment">// 返回索引为0的元素，即1</span></div><div class="line">          arr[<span class="number">5</span>]; <span class="comment">// 返回索引为5的元素，即true</span></div><div class="line">          arr[<span class="number">6</span>]; <span class="comment">// 索引超出了范围，返回undefined</span></div></pre></td></tr></table></figure>
</li>
<li><p>对象<br>  JavaScript的对象是一组由键-值组成的无序集合，例如：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> person = &#123;</div><div class="line">               name: <span class="string">'Bob'</span>,</div><div class="line">               age: <span class="number">20</span>,</div><div class="line">               tags: [<span class="string">'js'</span>, <span class="string">'web'</span>, <span class="string">'mobile'</span>],</div><div class="line">               city: <span class="string">'Beijing'</span>,</div><div class="line">               hasCar: <span class="literal">true</span>,</div><div class="line">               zipcode: <span class="literal">null</span></div><div class="line">          &#125;;</div></pre></td></tr></table></figure>
<p>  JavaScript对象的键都是字符串类型，值可以是任意数据类型。上述person对象一共定义了6个键值对，其中每个键又称为对象的属性，例如，person的name属性为’Bob’，zipcode属性为null。<br>  要获取一个对象的属性，我们用对象变量.属性名的方式：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          person.name; <span class="comment">// 'Bob'</span></div><div class="line">          person.zipcode; <span class="comment">// null</span></div></pre></td></tr></table></figure>
</li>
<li><p>变量<br>  变量在JavaScript中就是用一个变量名表示，变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。申明一个变量用var语句，比如：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> a; <span class="comment">// 申明了变量a，此时a的值为undefined</span></div><div class="line">          <span class="keyword">var</span> $b = <span class="number">1</span>; <span class="comment">// 申明了变量$b，同时给$b赋值，此时$b的值为1</span></div><div class="line">          <span class="keyword">var</span> s_007 = <span class="string">'007'</span>; <span class="comment">// s_007是一个字符串</span></div><div class="line">          <span class="keyword">var</span> Answer = <span class="literal">true</span>; <span class="comment">// Answer是一个布尔值true</span></div><div class="line">          <span class="keyword">var</span> t = <span class="literal">null</span>; <span class="comment">// t的值是null</span></div></pre></td></tr></table></figure>
<p>  变量名也可以用中文，但是，请不要给自己找麻烦。<br>  在JavaScript中，使用等号<code>=</code>对变量进行赋值。可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，但是要注意只能用<code>var</code>申明一次，例如：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> a = <span class="number">123</span>; <span class="comment">// a的值是整数123</span></div><div class="line">          a = <span class="string">'ABC'</span>; <span class="comment">// a变为字符串</span></div></pre></td></tr></table></figure>
<p>  这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错，例如java。<br>  和静态语言相比，动态语言更灵活，就是这个原因。</p>
</li>
<li><p>strict模式<br>  JavaScript在设计之初，为了方便初学者学习，并不强制要求用var申明变量。这个设计错误带来了严重的后果：如果一个变量没有通过var申明就被使用，那么该变量就自动被申明为全局变量：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          i = <span class="number">10</span>; <span class="comment">// i现在是全局变量</span></div></pre></td></tr></table></figure>
<p>  在同一个页面的不同的JavaScript文件中，如果都不用<code>var</code>申明，恰好都使用了变量<code>i</code>，将造成变量<code>i</code>互相影响，产生难以调试的错误结果。<br>  使用var申明的变量则不是全局变量，它的范围被限制在该变量被申明的函数体内（函数的概念将稍后讲解），同名变量在不同的函数体内互不冲突。<br>   为了修补JavaScript这一严重设计缺陷，ECMA在后续规范中推出了strict模式，在strict模式下运行的JavaScript代码，强制通过var申明变量，未使用var申明变量就使用的，将导致运行错误。<br>   启用strict模式的方法是在JavaScript代码的第一行写上：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;</div><div class="line">          <span class="comment">// 如果浏览器支持strict模式，</span></div><div class="line">          <span class="comment">// 下面的代码将报ReferenceError错误:</span></div><div class="line">          abc = <span class="string">'Hello, world'</span>;</div><div class="line">          alert(abc);</div></pre></td></tr></table></figure>
<p>  这是一个字符串，不支持strict模式的浏览器会把它当做一个字符串语句执行，支持strict模式的浏览器将开启strict模式运行JavaScript。<br>  运行代码，如果浏览器报错，请修复后再运行。如果浏览器不报错，说明你的浏览器太古老了，需要尽快升级。<br>  不用var申明的变量会被视为全局变量，为了避免这一缺陷，所有的JavaScript代码都应该使用strict模式。我们在后面编写的JavaScript代码将全部采用strict模式。</p>
</li>
</ul>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Javascript的字符串就是用<code>&#39;&#39;</code>或<code>&quot;&quot;</code>括起来的字符表示。<br>如果<code>&#39;</code>本身也是一个字符，那就可以用<code>&quot;&quot;</code>括起来，比如<code>&quot;I&#39;m OK&quot;</code>包含的字符是<code>I</code>，<code>&#39;</code>，<code>m</code>，空格，<code>O</code>，<code>K</code>这6个字符。<br>如果字符串内部既包含<code>&#39;</code>又包含<code>&quot;</code>怎么办？可以用转义字符<code>\</code>来标识，比如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> str = <span class="string">'I\'m \"OK\"!'</span>;</div></pre></td></tr></table></figure></p>
<p>转义字符<code>\</code>可以转义很多字符，比如<code>\n</code>表示换行，<code>\t</code>表示制表符，字符<code>\</code>本身也要转义，所以<code>\\</code>表示的字符就是<code>\</code>。<br><b style="color:red;">由于多行字符串用<code>\n</code>写起来比较费事，所以最新的ES6标准新增了一种多行字符串的表示方法：</b></p>
<ul>
<li><p>字符串常见操作<br>  1、获取长度</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> s = <span class="string">'Hello, world!'</span>;</div><div class="line">          s.length; <span class="comment">// 13</span></div></pre></td></tr></table></figure>
<p>  2、获取指定位置的字符</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> s = <span class="string">'Hello, world!'</span>;</div><div class="line">          s[<span class="number">0</span>]; <span class="comment">// 'H'</span></div><div class="line">          s[<span class="number">6</span>]; <span class="comment">// ' '</span></div><div class="line">          s[<span class="number">7</span>]; <span class="comment">// 'w'</span></div><div class="line">          s[<span class="number">12</span>]; <span class="comment">// '!'</span></div><div class="line">          s[<span class="number">13</span>]; <span class="comment">// undefined 超出范围的索引不会报错，但一律返回undefined</span></div></pre></td></tr></table></figure>
<p>  3、需要特别注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会有任何错误，但是，也没有任何效果：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> s = <span class="string">'Test'</span>;</div><div class="line">          s[<span class="number">0</span>] = <span class="string">'X'</span>;</div><div class="line">          alert(s); <span class="comment">// s仍然为'Test'</span></div></pre></td></tr></table></figure>
<p>  JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串：<br>  4、toUpperCase</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> s = <span class="string">'Hello'</span>;</div><div class="line">         <span class="comment">// toUpperCase()把一个字符串全部变为大写</span></div><div class="line">          s.toUpperCase(); <span class="comment">// 返回'HELLO'</span></div></pre></td></tr></table></figure>
<p>  5、indexOf</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> s = <span class="string">'hello, world'</span>;</div><div class="line">          s.indexOf(<span class="string">'world'</span>); <span class="comment">// 返回7</span></div><div class="line">          s.indexOf(<span class="string">'World'</span>); <span class="comment">// 没有找到指定的子串，返回-1</span></div></pre></td></tr></table></figure>
<p>  6、substring</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> s = <span class="string">'hello, world'</span></div><div class="line">         <span class="comment">// substring()返回指定索引区间的子串</span></div><div class="line">          s.substring(<span class="number">0</span>, <span class="number">5</span>); <span class="comment">// 从索引0开始到5（不包括5），返回'hello'</span></div><div class="line">          s.substring(<span class="number">7</span>); <span class="comment">// 从索引7开始到结束，返回'world'</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul>
<li><p>基本知识<br>JavaScript的Array可以包含任意数据类型，并通过索引来访问每个元素。<br>要取得Array的长度，直接访问length属性：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3.14</span>, <span class="string">'Hello'</span>, <span class="literal">null</span>, <span class="literal">true</span>];</div><div class="line">          arr.length; <span class="comment">// 6</span></div></pre></td></tr></table></figure>
<p>  <b style="color:red;">请注意，直接给Array的length赋一个新的值会导致Array大小的变化：</b></p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">          arr.length; <span class="comment">// 3</span></div><div class="line">          arr.length = <span class="number">6</span>;</div><div class="line">          arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, undefined]</span></div><div class="line">          arr.length = <span class="number">2</span>;</div><div class="line">          arr; <span class="comment">// arr变为[1, 2]</span></div></pre></td></tr></table></figure>
<p>  Array可以通过索引把对应的元素修改为新的值，因此，对Array的索引进行赋值会直接修改这个Array：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">          arr[<span class="number">1</span>] = <span class="number">99</span>;</div><div class="line">          arr; <span class="comment">// arr现在变为['A', 99, 'C']</span></div></pre></td></tr></table></figure>
<p>  <b style="color:red">请注意，如果通过索引赋值时，索引超过了范围，同样会引起Array大小的变化：</b></p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">          arr[<span class="number">5</span>] = <span class="string">'x'</span>;</div><div class="line">          arr; <span class="comment">// arr变为[1, 2, 3, undefined, undefined, 'x']</span></div></pre></td></tr></table></figure>
<p>  大多数其他编程语言不允许直接改变数组的大小，越界访问索引会报错。然而，JavaScript的Array却不会有任何错误。在编写代码时，不建议直接修改Array的大小，访问索引时要确保索引不会越界。</p>
</li>
<li><p>常用方法</p>
<ul>
<li><p>indexOf<br>与String类似，Array也可以通过indexOf()来搜索一个指定的元素的位置：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="string">'30'</span>, <span class="string">'xyz'</span>];</div><div class="line">               arr.indexOf(<span class="number">10</span>); <span class="comment">// 元素10的索引为0</span></div><div class="line">               arr.indexOf(<span class="number">20</span>); <span class="comment">// 元素20的索引为1</span></div><div class="line">               arr.indexOf(<span class="number">30</span>); <span class="comment">// 元素30没有找到，返回-1</span></div><div class="line">               arr.indexOf(<span class="string">'30'</span>); <span class="comment">// 元素'30'的索引为2</span></div></pre></td></tr></table></figure>
</li>
<li><p>slice (不会改变原数组)<br>slice()就是对应String的substring()版本，它截取Array的部分元素，然后返回一个新的Array：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>];</div><div class="line">               arr.slice(<span class="number">0</span>, <span class="number">3</span>); <span class="comment">// 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']</span></div><div class="line">               arr.slice(<span class="number">3</span>); <span class="comment">// 从索引3开始到结束: ['D', 'E', 'F', 'G']</span></div></pre></td></tr></table></figure>
<p>如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>];</div><div class="line">               <span class="keyword">var</span> aCopy = arr.slice();</div><div class="line">               aCopy; <span class="comment">// ['A', 'B', 'C', 'D', 'E', 'F', 'G']</span></div><div class="line">               aCopy === arr; <span class="comment">// false</span></div></pre></td></tr></table></figure>
</li>
<li><p>push和pop(改变原数组)<br>push()向Array的末尾添加若干元素，pop()则把Array的最后一个元素删除掉：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</div><div class="line">               arr.push(<span class="string">'A'</span>, <span class="string">'B'</span>); <span class="comment">// 返回Array新的长度: 4</span></div><div class="line">               arr; <span class="comment">// [1, 2, 'A', 'B']</span></div><div class="line">               arr.pop(); <span class="comment">// pop()返回'B'</span></div><div class="line">               arr; <span class="comment">// [1, 2, 'A']</span></div><div class="line">               arr.pop(); arr.pop(); arr.pop(); <span class="comment">// 连续pop 3次</span></div><div class="line">               arr; <span class="comment">// []</span></div><div class="line">               arr.pop(); <span class="comment">// 空数组继续pop不会报错，而是返回undefined</span></div><div class="line">               arr; <span class="comment">// []</span></div></pre></td></tr></table></figure>
</li>
<li><p>unshift和shift(改变原数组)<br>如果要往Array的头部添加若干元素，使用unshift()方法，shift()方法则把Array的第一个元素删掉：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</div><div class="line">               arr.unshift(<span class="string">'A'</span>, <span class="string">'B'</span>); <span class="comment">// 返回Array新的长度: 4</span></div><div class="line">               arr; <span class="comment">// ['A', 'B', 1, 2]</span></div><div class="line">               arr.shift(); <span class="comment">// 'A'</span></div><div class="line">               arr; <span class="comment">// ['B', 1, 2]</span></div><div class="line">               arr.shift(); arr.shift(); arr.shift(); <span class="comment">// 连续shift 3次</span></div><div class="line">               arr; <span class="comment">// []</span></div><div class="line">               arr.shift(); <span class="comment">// 空数组继续shift不会报错，而是返回undefined</span></div><div class="line">               arr; <span class="comment">// []</span></div></pre></td></tr></table></figure>
</li>
<li><p>sort(改变原数组)<br>sort()可以对当前Array进行排序，它会直接修改当前Array的元素位置，直接调用时，按照默认顺序排序：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'A'</span>];</div><div class="line">               arr.sort();</div><div class="line">               arr; <span class="comment">// ['A', 'B', 'C']</span></div></pre></td></tr></table></figure>
<p>能否按照我们自己指定的顺序排序呢？完全可以，我们将在后面的函数中讲到。</p>
</li>
<li><p>reverse(改变原数组)<br>reverse()把整个Array的元素给掉个个，也就是反转：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>];</div><div class="line">               arr.reverse();</div><div class="line">               arr; <span class="comment">// ['three', 'two', 'one']</span></div></pre></td></tr></table></figure>
</li>
<li><p>splice(改变原数组)<br>splice()方法是修改Array的“万能方法”，它可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="string">'Microsoft'</span>, <span class="string">'Apple'</span>, <span class="string">'Yahoo'</span>, <span class="string">'AOL'</span>, <span class="string">'Excite'</span>, <span class="string">'Oracle'</span>];</div><div class="line">               <span class="comment">// 从索引2开始删除3个元素,然后再添加两个元素:</span></div><div class="line">               arr.splice(<span class="number">2</span>, <span class="number">3</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回删除的元素 ['Yahoo', 'AOL', 'Excite']</span></div><div class="line">               arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></div><div class="line">               <span class="comment">// 只删除,不添加:</span></div><div class="line">               arr.splice(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// ['Google', 'Facebook']</span></div><div class="line">               arr; <span class="comment">// ['Microsoft', 'Apple', 'Oracle']</span></div><div class="line">               <span class="comment">// 只添加,不删除:</span></div><div class="line">               arr.splice(<span class="number">2</span>, <span class="number">0</span>, <span class="string">'Google'</span>, <span class="string">'Facebook'</span>); <span class="comment">// 返回[],因为没有删除任何元素</span></div><div class="line">               arr; <span class="comment">// ['Microsoft', 'Apple', 'Google', 'Facebook', 'Oracle']</span></div></pre></td></tr></table></figure>
</li>
<li><p>concat(改变原数组)<br>concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">               <span class="keyword">var</span> added = arr.concat([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line">               added; <span class="comment">// ['A', 'B', 'C', 1, 2, 3]</span></div><div class="line">               arr; <span class="comment">// ['A', 'B', 'C']</span></div></pre></td></tr></table></figure>
<p>请注意，concat()方法并没有修改当前Array，而是返回了一个新的Array。<br>实际上，concat()方法可以接收任意个元素和Array，并且自动把Array拆开，然后全部添加到新的Array里：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">               arr.concat(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]); <span class="comment">// ['A', 'B', 'C', 1, 2, 3, 4]</span></div></pre></td></tr></table></figure>
</li>
<li><p>join(不会改变原数组)<br>join()方法是一个非常实用的方法，它把当前Array的每个元素都用指定的字符串连接起来，然后返回连接后的字符串：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">               <span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">               arr.join(<span class="string">'-'</span>); <span class="comment">// 'A-B-C-1-2-3'</span></div></pre></td></tr></table></figure>
<p>如果Array的元素不是字符串，将自动转换为字符串后再连接。</p>
</li>
<li>多维数组</li>
</ul>
</li>
</ul>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><ul>
<li><p>基础知识<br>  JavaScript的对象是一种无序的集合数据类型，它由若干键值对组成。<br>JavaScript的对象用于描述现实世界中的某个对象。例如，为了描述“小明”这个淘气的小朋友，我们可以用若干键值对来描述他：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">               name: <span class="string">'小明'</span>,</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               school: <span class="string">'No.1 Middle School'</span>,</div><div class="line">               height: <span class="number">1.70</span>,</div><div class="line">               weight: <span class="number">65</span>,</div><div class="line">               score: <span class="literal">null</span></div><div class="line">          &#125;;</div></pre></td></tr></table></figure>
<p>  JavaScript用一个{…}表示一个对象，键值对以xxx: xxx形式申明，用,隔开。注意，最后一个键值对不需要在末尾加,，如果加了，有的浏览器（如低版本的IE）将报错。<br>访问属性是通过.操作符完成的，但这要求属性名必须是一个有效的变量名。如果属性名包含特殊字符，就必须用’’括起来：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> xiaohong = &#123;</div><div class="line">               name: <span class="string">'小红'</span>,</div><div class="line">               <span class="string">'middle-school'</span>: <span class="string">'No.1 Middle School'</span></div><div class="line">          &#125;;</div></pre></td></tr></table></figure>
<p>  xiaohong的属性名middle-school不是一个有效的变量，就需要用’’括起来。访问这个属性也无法使用.操作符，必须用[‘xxx’]来访问：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          xiaohong[<span class="string">'middle-school'</span>]; <span class="comment">// 'No.1 Middle School'</span></div><div class="line">          xiaohong[<span class="string">'name'</span>]; <span class="comment">// '小红'</span></div><div class="line">          xiaohong.name; <span class="comment">// '小红'(推荐写法)</span></div></pre></td></tr></table></figure>
<p>  如果访问一个不存在的属性会返回什么呢？JavaScript规定，访问不存在的属性不报错，而是返回undefined：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">               name: <span class="string">'小明'</span></div><div class="line">          &#125;;</div><div class="line">          xiaoming.age; <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
</li>
<li><p>对象属性的增删改查<br>  由于JavaScript的对象是动态类型，你可以自由地给一个对象添加或删除属性：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">               name: <span class="string">'小明'</span></div><div class="line">          &#125;;</div><div class="line">          xiaoming.age; <span class="comment">// undefined</span></div><div class="line">          xiaoming.age = <span class="number">18</span>; <span class="comment">// 新增一个age属性</span></div><div class="line">          xiaoming.age; <span class="comment">// 18</span></div><div class="line">          <span class="keyword">delete</span> xiaoming.age; <span class="comment">// 删除age属性</span></div><div class="line">          xiaoming.age; <span class="comment">// undefined</span></div><div class="line">          <span class="keyword">delete</span> xiaoming[<span class="string">'name'</span>]; <span class="comment">// 删除name属性</span></div><div class="line">          xiaoming.name; <span class="comment">// undefined</span></div><div class="line">          <span class="keyword">delete</span> xiaoming.school; <span class="comment">// 删除一个不存在的school属性也不会报错</span></div></pre></td></tr></table></figure>
<p>  如果我们要检测xiaoming是否拥有某一属性，可以用in操作符：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">               name: <span class="string">'小明'</span>,</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               school: <span class="string">'No.1 Middle School'</span>,</div><div class="line">               height: <span class="number">1.70</span>,</div><div class="line">               weight: <span class="number">65</span>,</div><div class="line">               score: <span class="literal">null</span></div><div class="line">          &#125;;</div><div class="line">          <span class="string">'name'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></div><div class="line">          <span class="string">'grade'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>  不过要小心，如果in判断一个属性存在，这个属性不一定是xiaoming的，它可能是xiaoming继承得到的：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">         <span class="comment">// 因为toString定义在object对象中，而所有对象最终都会在原型链上指向object，所以xiaoming也拥有toString属性。</span></div><div class="line">          <span class="string">'toString'</span> <span class="keyword">in</span> xiaoming; <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>  要判断一个属性是否是xiaoming自身拥有的，而不是继承得到的，可以用hasOwnProperty()方法：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">               name: <span class="string">'小明'</span></div><div class="line">          &#125;;</div><div class="line">          xiaoming.hasOwnProperty(<span class="string">'name'</span>); <span class="comment">// true</span></div><div class="line">          xiaoming.hasOwnProperty(<span class="string">'toString'</span>); <span class="comment">// false</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><p>JavaScript使用<code>if () { ... } else { ... }</code>来进行条件判断。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> age = <span class="number">20</span>;</div><div class="line">          <span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123; <span class="comment">// 如果age &gt;= 18为true，则执行if语句块</span></div><div class="line">               alert(<span class="string">'adult'</span>);</div><div class="line">          &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则执行else语句块</span></div><div class="line">               alert(<span class="string">'teenager'</span>);</div><div class="line">          &#125;</div></pre></td></tr></table></figure></p>
<p>其中else语句是可选的。如果语句块只包含一条语句，那么可以省略<code>{}</code>（最好不要这样做，容易引发错误）：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> age = <span class="number">20</span>;</div><div class="line">          <span class="keyword">if</span> (age &gt;= <span class="number">18</span>)</div><div class="line">               alert(<span class="string">'adult'</span>);</div><div class="line">          <span class="keyword">else</span></div><div class="line">               alert(<span class="string">'teenager'</span>);</div></pre></td></tr></table></figure></p>
<p>如果还要更细致地判断条件，可以使用多个<code>if...else...</code>的组合：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> age = <span class="number">3</span>;</div><div class="line">          <span class="keyword">if</span> (age &gt;= <span class="number">18</span>) &#123;</div><div class="line">               alert(<span class="string">'adult'</span>);</div><div class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (age &gt;= <span class="number">6</span>) &#123;</div><div class="line">               alert(<span class="string">'teenager'</span>);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">               alert(<span class="string">'kid'</span>);</div><div class="line">          &#125;</div></pre></td></tr></table></figure></p>
<p>如果if的条件判断语句结果不是true或false怎么办？例如：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> s = <span class="string">'123'</span>;</div><div class="line">          <span class="keyword">if</span> (s.length) &#123; <span class="comment">// 条件计算结果为3</span></div><div class="line">               <span class="comment">// JavaScript把null、undefined、0、NaN和空字符串''视为false，其他值一概视为true，因此上述代码条件判断的结果是true。</span></div><div class="line">          &#125;</div></pre></td></tr></table></figure></p>
<h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>JavaScript的循环有两种，一种是for循环，通过初始条件、结束条件和递增条件来循环执行语句块：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> x = <span class="number">0</span>;</div><div class="line">     <span class="keyword">var</span> i;</div><div class="line">     <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=<span class="number">10000</span>; i++) &#123;</div><div class="line">          x = x + i;</div><div class="line">     &#125;</div><div class="line">     x; <span class="comment">// 50005000</span></div></pre></td></tr></table></figure></p>
<p>for循环的3个条件都是可以省略的，如果没有退出循环的判断条件，就必须使用break语句退出循环，否则就是死循环：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> x = <span class="number">0</span>;</div><div class="line">     <span class="keyword">for</span> (;;) &#123; <span class="comment">// 将无限循环下去</span></div><div class="line">          <span class="keyword">if</span> (x &gt; <span class="number">100</span>) &#123;</div><div class="line">              <span class="keyword">break</span>; <span class="comment">// 通过if判断来退出循环</span></div><div class="line">          &#125;</div><div class="line">          x ++;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p><code>for ... in</code>循环</p>
<p>for循环的一个变体是for … in循环，它可以把一个对象的所有属性依次循环出来：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> o = &#123;</div><div class="line">          name: <span class="string">'Jack'</span>,</div><div class="line">          age: <span class="number">20</span>,</div><div class="line">          city: <span class="string">'Beijing'</span></div><div class="line">     &#125;;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</div><div class="line">          alert(key); <span class="comment">// 'name', 'age', 'city'</span></div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>要过滤掉对象继承的属性，用hasOwnProperty()来实现：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> o = &#123;</div><div class="line">          name: <span class="string">'Jack'</span>,</div><div class="line">          age: <span class="number">20</span>,</div><div class="line">          city: <span class="string">'Beijing'</span></div><div class="line">     &#125;;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> o) &#123;</div><div class="line">          <span class="keyword">if</span> (o.hasOwnProperty(key)) &#123;</div><div class="line">              alert(key); <span class="comment">// 'name', 'age', 'city'</span></div><div class="line">          &#125;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>while循环(比较简单，这里不介绍)</p>
<h2 id="Map和Set（ES6规范引入）"><a href="#Map和Set（ES6规范引入）" class="headerlink" title="Map和Set（ES6规范引入）"></a>Map和Set（ES6规范引入）</h2><p>JavaScript的默认对象表示方式{}可以视为其他语言中的Map或Dictionary的数据结构，即一组键值对。但是JavaScript的对象有个小问题，就是键必须是字符串。但实际上Number或者其他数据类型作为键也是非常合理的。为了解决这个问题，最新的ES6规范引入了新的数据类型Map。要测试你的浏览器是否支持ES6规范，请执行以下代码，如果浏览器报ReferenceError错误，那么你需要换一个支持ES6的浏览器：</p>
<ul>
<li><p>Map<br>  Map是一组键值对的结构，具有极快的查找速度。<br>  用JavaScript写一个Map如下：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'Michael'</span>, <span class="number">95</span>], [<span class="string">'Bob'</span>, <span class="number">75</span>], [<span class="string">'Tracy'</span>, <span class="number">85</span>]]);</div><div class="line">          m.get(<span class="string">'Michael'</span>); <span class="comment">// 95</span></div></pre></td></tr></table></figure>
<p>  初始化Map需要一个二维数组，或者直接初始化一个空Map。Map具有以下方法：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(); <span class="comment">// 空Map</span></div><div class="line">          m.set(<span class="string">'Adam'</span>, <span class="number">67</span>); <span class="comment">// 添加新的key-value</span></div><div class="line">          m.set(<span class="string">'Bob'</span>, <span class="number">59</span>);</div><div class="line">          m.has(<span class="string">'Adam'</span>); <span class="comment">// 是否存在key 'Adam': true</span></div><div class="line">          m.get(<span class="string">'Adam'</span>); <span class="comment">// 67</span></div><div class="line">          m.delete(<span class="string">'Adam'</span>); <span class="comment">// 删除key 'Adam'</span></div><div class="line">          m.get(<span class="string">'Adam'</span>); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>  由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">          m.set(<span class="string">'Adam'</span>, <span class="number">67</span>);</div><div class="line">          m.set(<span class="string">'Adam'</span>, <span class="number">88</span>);</div><div class="line">          m.get(<span class="string">'Adam'</span>); <span class="comment">// 88</span></div></pre></td></tr></table></figure>
</li>
<li><p>Set<br>  <code>Set</code>和<code>Map</code>类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。<br>要创建一个Set，需要提供一个Array作为输入，或者直接创建一个空Set：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>(); <span class="comment">// 空Set</span></div><div class="line">          <span class="keyword">var</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 含1, 2, 3</span></div></pre></td></tr></table></figure>
<p>  重复元素在Set中自动被过滤：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="string">'3'</span>]);</div><div class="line">          s; <span class="comment">// Set &#123;1, 2, 3, "3"&#125;</span></div></pre></td></tr></table></figure>
<p>  通过add(key)方法可以添加元素到Set中，可以重复添加，但不会有效果：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          &gt;&gt;&gt; s.add(<span class="number">4</span>)</div><div class="line">          &gt;&gt;&gt; s</div><div class="line">          &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</div><div class="line">          &gt;&gt;&gt; s.add(<span class="number">4</span>)</div><div class="line">          &gt;&gt;&gt; s</div><div class="line">          &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</div></pre></td></tr></table></figure>
<p>  通过delete(key)方法可以删除元素：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line">          s; <span class="comment">// Set &#123;1, 2, 3&#125;</span></div><div class="line">          s.delete(<span class="number">3</span>);</div><div class="line">          s; <span class="comment">// Set &#123;1, 2&#125;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="iterable"><a href="#iterable" class="headerlink" title="iterable"></a>iterable</h2><p>遍历Array可以采用下标循环，遍历Map和Set就无法使用下标。为了统一集合类型，ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型。 具有iterable类型的集合可以通过新的<code>for ... of</code>循环来遍历。<br><b style="color:red;"><code>for ... of</code>循环是ES6引入的新的语法</b>，请测试你的浏览器是否支持：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     <span class="string">'use strict'</span>;</div><div class="line">     <span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123;</div><div class="line">     &#125;</div><div class="line">     alert(<span class="string">'你的浏览器支持for ... of'</span>);</div></pre></td></tr></table></figure></p>
<p>用for … of循环遍历集合，用法如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">     <span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</div><div class="line">     <span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123; <span class="comment">// 遍历Array</span></div><div class="line">          alert(x);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> s) &#123; <span class="comment">// 遍历Set</span></div><div class="line">          alert(x);</div><div class="line">     &#125;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> m) &#123; <span class="comment">// 遍历Map</span></div><div class="line">          alert(x[<span class="number">0</span>] + <span class="string">'='</span> + x[<span class="number">1</span>]);<span class="comment">//1=x，2=y，3=z</span></div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>你可能会有疑问，<code>for ... of</code>循环和<code>for ... in</code>循环有何区别？<br><code>for ... in</code>循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性。当我们手动给Array对象添加了额外的属性后，<code>for ... in</code>循环将带来意想不到的意外效果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">     a.name = <span class="string">'Hello'</span>;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">in</span> a) &#123;</div><div class="line">          alert(x); <span class="comment">// '0', '1', '2', 'name'，x是属性的名称，对于数组来说，它每个元素的索引被视为属性名称</span></div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p><code>for ... in</code>循环将把name包括在内，但Array的length属性却不包括在内。<code>for ... of</code>循环则完全修复了这些问题，它只循环集合本身的元素：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">     a.name = <span class="string">'Hello'</span>;</div><div class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> x <span class="keyword">of</span> a) &#123;</div><div class="line">         <span class="comment">//只循环集合本身的元素</span></div><div class="line"></div><div class="line">          alert(x); <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span></div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>然而，更好的方式是直接使用<code>iterable</code>内置的<code>forEach</code>方法，它接收一个函数，每次迭代就自动回调该函数。以<code>Array</code>为例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">     a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, index, array</span>) </span>&#123;</div><div class="line">          <span class="comment">// element: 指向当前元素的值</span></div><div class="line">          <span class="comment">// index: 指向当前索引</span></div><div class="line">          <span class="comment">// array: 指向Array对象本身</span></div><div class="line">          alert(element);</div><div class="line">     &#125;);</div></pre></td></tr></table></figure>
<p><b style="color:red;">注意，forEach()方法是ES5.1标准引入的，你需要测试浏览器是否支持。</b><br>Set与Array类似，但Set没有索引，因此回调函数的前两个参数都是元素本身：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]);</div><div class="line">     s.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element, sameElement, set</span>) </span>&#123;</div><div class="line">          alert(element);</div><div class="line">     &#125;);</div></pre></td></tr></table></figure></p>
<p>Map的回调函数参数依次为value、key和map本身：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="number">1</span>, <span class="string">'x'</span>], [<span class="number">2</span>, <span class="string">'y'</span>], [<span class="number">3</span>, <span class="string">'z'</span>]]);</div><div class="line">     m.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, key, map</span>) </span>&#123;</div><div class="line">          alert(value);</div><div class="line">     &#125;);</div></pre></td></tr></table></figure></p>
<p>如果对某些参数不感兴趣，由于JavaScript的函数调用不要求参数必须一致，因此可以忽略它们。例如，只需要获得Array的element：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> a = [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>];</div><div class="line">     a.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</div><div class="line">          alert(element);</div><div class="line">     &#125;);</div></pre></td></tr></table></figure></p>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><hr>
<h2 id="函数的定义和调用"><a href="#函数的定义和调用" class="headerlink" title="函数的定义和调用"></a>函数的定义和调用</h2><ul>
<li><p>定义函数<br>   在JavaScript中，定义函数的方式如下：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">               <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</div><div class="line">                   <span class="keyword">return</span> x;</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   <span class="keyword">return</span> -x;</div><div class="line">               &#125;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
<p>   上述<code>abs()</code>函数的定义如下：</p>
<ul>
<li><code>function</code>指出这是一个函数定义；</li>
<li><code>abs</code>是函数的名称；</li>
<li><code>(x)</code>括号内列出函数的参数，多个参数以<code>,</code>分隔；</li>
<li><p><code>{ ... }</code>之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。<br>请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。 如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined。<br>第二种定义函数的方式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> abs = <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">               <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</div><div class="line">                   <span class="keyword">return</span> x;</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   <span class="keyword">return</span> -x;</div><div class="line">               &#125;</div><div class="line">          &#125;;</div></pre></td></tr></table></figure>
<p>在这种方式下，<code>function (x) { ... }</code>是一个匿名函数，它没有函数名。但是，这个匿名函数赋值给了变量<code>abs</code>，所以，通过变量<code>abs</code>就可以调用该函数。<br><b style="color:red;">上述两种定义完全等价，注意第二种方式按照完整语法需要在函数体末尾加一个;，表示赋值语句结束。</b></p>
</li>
</ul>
</li>
<li><p>调用函数<br>  调用函数时，按顺序传入参数即可：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          abs(<span class="number">10</span>); <span class="comment">// 返回10</span></div><div class="line">          abs(<span class="number">-9</span>); <span class="comment">// 返回9</span></div></pre></td></tr></table></figure>
<p>  由于JavaScript允许传入任意个参数而不影响调用，因此传入的参数比定义的参数多也没有问题，虽然函数内部并不需要这些参数：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          abs(<span class="number">10</span>, <span class="string">'blablabla'</span>); <span class="comment">// 返回10</span></div><div class="line">          abs(<span class="number">-9</span>, <span class="string">'haha'</span>, <span class="string">'hehe'</span>, <span class="literal">null</span>); <span class="comment">// 返回9</span></div></pre></td></tr></table></figure>
<p>  传入的参数比定义的少也没有问题：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          abs(); <span class="comment">// 返回NaN</span></div></pre></td></tr></table></figure>
<p>  此时<code>abs(x)</code>函数的参数<code>x</code>将收到<code>undefined</code>，计算结果为<code>NaN</code>。<br>  要避免收到<code>undefined</code>，可以对参数进行检查：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">               <span class="keyword">if</span> (<span class="keyword">typeof</span> x !== <span class="string">'number'</span>) &#123;</div><div class="line">                   <span class="keyword">throw</span> <span class="string">'Not a number'</span>;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</div><div class="line">                   <span class="keyword">return</span> x;</div><div class="line">               &#125; <span class="keyword">else</span> &#123;</div><div class="line">                   <span class="keyword">return</span> -x;</div><div class="line">               &#125;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>arguments<br>  JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。arguments类似Array但它不是一个Array：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">               alert(x); <span class="comment">// 10</span></div><div class="line">               <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">arguments</span>.length; i++) &#123;</div><div class="line">                   alert(<span class="built_in">arguments</span>[i]); <span class="comment">// 10, 20, 30</span></div><div class="line">               &#125;</div><div class="line">          &#125;</div><div class="line">          foo(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</div></pre></td></tr></table></figure>
<p>  利用arguments，你可以获得调用者传入的所有参数。也就是说，即使函数不定义任何参数，还是可以拿到参数的值：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">abs</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">0</span>) &#123;</div><div class="line">                   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">var</span> x = <span class="built_in">arguments</span>[<span class="number">0</span>];</div><div class="line">               <span class="keyword">return</span> x &gt;= <span class="number">0</span> ? x : -x;</div><div class="line">          &#125;</div><div class="line">          abs(); <span class="comment">// 0</span></div><div class="line">          abs(<span class="number">10</span>); <span class="comment">// 10</span></div><div class="line">          abs(<span class="number">-9</span>); <span class="comment">// 9</span></div></pre></td></tr></table></figure>
<p>  <b style="color:red;">利用arguments参数实现可选参数的函数：</b></p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">          <span class="comment">// foo(a[, b], c)</span></div><div class="line">          <span class="comment">// 接收2~3个参数，b是可选参数，如果只传2个参数，b默认为null：</span></div><div class="line">         <span class="comment">// 要把中间的参数b变为“可选”参数，就只能通过arguments判断，然后重新调整参数并赋值。</span></div><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>) </span>&#123;</div><div class="line">               <span class="keyword">if</span> (<span class="built_in">arguments</span>.length === <span class="number">2</span>) &#123;</div><div class="line">                   <span class="comment">// 实际拿到的参数是a和b，c为undefined</span></div><div class="line">                   c = b; <span class="comment">// 把b赋给c</span></div><div class="line">                   b = <span class="literal">null</span>; <span class="comment">// b变为默认值</span></div><div class="line">               &#125;</div><div class="line">               <span class="comment">// ...</span></div><div class="line">          &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>rest参数（<b style="color:red;">ES6引入</b>）<br>  ES6标准引入了rest参数，可以获取除已定义的其他传入参数组成的数组：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, ...rest</span>) </span>&#123;</div><div class="line">               <span class="built_in">console</span>.log(<span class="string">'a = '</span> + a);</div><div class="line">               <span class="built_in">console</span>.log(<span class="string">'b = '</span> + b);</div><div class="line">               <span class="built_in">console</span>.log(rest);</div><div class="line">          &#125;  </div><div class="line">          foo(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</div><div class="line">          <span class="comment">// 结果:</span></div><div class="line">          <span class="comment">// a = 1</span></div><div class="line">          <span class="comment">// b = 2</span></div><div class="line">          <span class="comment">// Array [ 3, 4, 5 ]</span></div><div class="line">          foo(<span class="number">1</span>);</div><div class="line">          <span class="comment">// 结果:</span></div><div class="line">          <span class="comment">// a = 1</span></div><div class="line">          <span class="comment">// b = undefined</span></div><div class="line">          <span class="comment">// Array []</span></div></pre></td></tr></table></figure>
<p>  用<code>rest</code>参数编写一个<code>sum()</code>函数，接收任意个参数并返回它们的和：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">...rest</span>) </span>&#123;</div><div class="line">             <span class="keyword">var</span> sum = <span class="number">0</span>;</div><div class="line">             <span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">of</span> rest) &#123;</div><div class="line">               sum += i;     </div><div class="line">             &#125;</div><div class="line">             <span class="keyword">return</span> sum;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>小心你的return语句<br> 前面我们讲到了JavaScript引擎有一个在行末自动添加分号的机制，这可能让你栽到return语句的一个大坑：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> &#123; name: <span class="string">'foo'</span> &#125;;</div><div class="line">          &#125;</div><div class="line">          foo(); <span class="comment">// &#123; name: 'foo' &#125;</span></div></pre></td></tr></table></figure>
<p> 如果把return语句拆成两行：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span>         <span class="regexp">/ /</span> 自动添加了分号，相当于<span class="keyword">return</span> <span class="literal">undefined</span>;</div><div class="line">                   &#123; name: <span class="string">'foo'</span> &#125;;   <span class="comment">// 这行语句已经没法执行到了</span></div><div class="line">          &#125;</div><div class="line">          foo(); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p> 所以正确的多行写法是：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> &#123; <span class="comment">// 这里不会自动加分号，因为&#123;表示语句尚未结束</span></div><div class="line">                   name: <span class="string">'foo'</span></div><div class="line">               &#125;;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h2><ul>
<li>基础知识<br>在JavaScript中，用var申明的变量实际上是有作用域的。<br>1、如果一个变量在函数体内部申明，则该变量的作用域为整个函数体，在函数体外不可引用该变量：<br>2、如果两个不同的函数各自申明了同一个变量，那么该变量只在各自的函数体内起作用。换句话说，不同函数内部的同名变量互相独立，互不影响：<br>3、由于JavaScript的函数可以嵌套，此时，内部函数可以访问外部函数定义的变量，反过来则不行：<br>4、JavaScript的函数在查找变量时从自身函数定义开始，从“内”向“外”查找。如果内部函数定义了与外部函数重名的变量，则内部函数的变量将“屏蔽”外部函数的变量。</li>
<li><p>变量提升<br>   JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;</div><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> x = <span class="string">'Hello, '</span> + y;</div><div class="line">               a lert(x);</div><div class="line">               <span class="keyword">var</span> y = <span class="string">'Bob'</span>;</div><div class="line">          &#125;</div><div class="line">          foo();</div></pre></td></tr></table></figure>
<p>   虽然是strict模式，但语句var x = ‘Hello, ‘ + y;并不报错，原因是变量y在稍后申明了。但是alert显示Hello, undefined，说明变量y的值为undefined。这正是因为JavaScript引擎自动提升了变量y的声明，但不会提升变量y的赋值。<br>对于上述foo()函数，JavaScript引擎看到的代码相当于：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> y; <span class="comment">// 提升变量y的申明</span></div><div class="line">               <span class="keyword">var</span> x = <span class="string">'Hello, '</span> + y;</div><div class="line">               alert(x);</div><div class="line">               y = <span class="string">'Bob'</span>;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
<p>   由于JavaScript的这一怪异的“特性”，我们在函数内部定义变量时，请严格遵守“在函数内部首先申明所有变量”这一规则。最常见的做法是用一个var申明函数内部用到的所有变量：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="comment">//JS引擎在认为可以加分号的地方自动加分号，这里不会自动加分号</span></div><div class="line">               <span class="keyword">var</span></div><div class="line">                   x = <span class="number">1</span>, <span class="comment">// x初始化为1</span></div><div class="line">                   y = x + <span class="number">1</span>, <span class="comment">// y初始化为2</span></div><div class="line">                   z, i; <span class="comment">// z和i为undefined</span></div><div class="line">               <span class="comment">// 其他语句:</span></div><div class="line">               f or (i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;      </div><div class="line">               &#125;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>全局作用域<br>   不在任何函数内定义的变量就具有全局作用域。实际上，JavaScript默认有一个全局对象window，全局作用域的变量实际上被绑定到window的一个属性：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;  </div><div class="line">          <span class="keyword">var</span> course = <span class="string">'Learn JavaScript'</span>;</div><div class="line">          alert(course); <span class="comment">// 'Learn JavaScript'</span></div><div class="line">          alert(<span class="built_in">window</span>.course); <span class="comment">// 'Learn JavaScript'</span></div></pre></td></tr></table></figure>
<p>   因此，直接访问全局变量course和访问window.course是完全一样的。同理，全局定义的函数也可以通过<code>window.functionName()</code>方式调用。<br>进一步大胆地猜测，我们每次直接调用的alert()函数其实也是window的一个变量：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;  </div><div class="line">          <span class="built_in">window</span>.alert(<span class="string">'调用window.alert()'</span>);</div><div class="line">          <span class="comment">// 把alert保存到另一个变量:</span></div><div class="line">          <span class="keyword">var</span> old_alert = <span class="built_in">window</span>.alert;</div><div class="line">          <span class="comment">// 给alert赋一个新函数:</span></div><div class="line">          <span class="built_in">window</span>.alert = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</div><div class="line">          alert(<span class="string">'无法用alert()显示了!'</span>);</div><div class="line">          <span class="comment">// 恢复alert:</span></div><div class="line">          <span class="built_in">window</span>.alert = old_alert;</div><div class="line">          alert(<span class="string">'又可以用alert()了!'</span>);</div></pre></td></tr></table></figure>
<p>   这说明JavaScript实际上只有一个全局作用域。任何变量（函数也视为变量），如果没有在当前函数作用域中找到，就会继续往上查找，最后如果在全局作用域中也没有找到，则报ReferenceError错误。</p>
</li>
<li><p>名字空间<br>   全局变量会绑定到window上，不同的JavaScript文件如果使用了相同的全局变量，或者定义了相同名字的顶层函数，都会造成命名冲突，并且很难被发现。 减少冲突的一个方法是把自己的所有变量和函数全部绑定到一个全局变量中。例如：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">          <span class="comment">// 唯一的全局变量MYAPP:</span></div><div class="line">          <span class="keyword">var</span> MYAPP = &#123;&#125;;  </div><div class="line">          <span class="comment">// 其他变量:</span></div><div class="line">          MYAPP.name = <span class="string">'myapp'</span>;</div><div class="line">          MYAPP.version = <span class="number">1.0</span>;</div><div class="line">          <span class="comment">// 其他函数:</span></div><div class="line">          MYAPP.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> <span class="string">'foo'</span>;</div><div class="line">          &#125;;</div></pre></td></tr></table></figure>
<p>   把自己的代码全部放入唯一的名字空间MYAPP中，会大大减少全局变量冲突的可能。 许多著名的JavaScript库都是这么干的：jQuery，YUI，underscore等等。</p>
</li>
<li><p>局部作用域<br>   由于JavaScript的变量作用域实际上是函数内部，我们在for循环等语句块中是无法定义具有局部作用域的变量的：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;</div><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</div><div class="line">                   <span class="comment">//</span></div><div class="line">               &#125;</div><div class="line">               i += <span class="number">100</span>; <span class="comment">// 仍然可以引用变量i</span></div><div class="line">          &#125;</div></pre></td></tr></table></figure>
<p>   为了解决块级作用域，<b style="color:red;">ES6引入了新的关键字let</b>，用let替代var可以申明一个块级作用域的变量：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;  </div><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> sum = <span class="number">0</span>;</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;</div><div class="line">                   sum += i;</div><div class="line">               &#125;</div><div class="line">               i += <span class="number">1</span>; <span class="comment">// SyntaxError</span></div><div class="line">          &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>常量<br>  由于var和let申明的是变量，如果要申明一个常量，在ES6之前是不行的，我们通常用全部大写的变量来表示“这是一个常量，不要修改它的值”：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> PI = <span class="number">3.14</span>;</div></pre></td></tr></table></figure>
<p>  <b style="color:red;">ES6标准引入了新的关键字const来定义常量</b>，const与let都具有块级作用域：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;</div><div class="line">          <span class="keyword">const</span> PI = <span class="number">3.14</span>;</div><div class="line">          PI = <span class="number">3</span>; <span class="comment">// 某些浏览器不报错，但是无效果！</span></div><div class="line">          PI; <span class="comment">// 3.14</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li><p>方法与<code>this</code><br>  在一个对象中绑定函数，称为这个对象的方法。<br>  如果我们给xiaoming绑定一个函数，就可以做更多的事情。比如，写个age()方法，返回xiaoming的年龄：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">               name: <span class="string">'小明'</span>,</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">                   <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">               &#125;</div><div class="line">          &#125;;</div><div class="line">          xiaoming.age; <span class="comment">// function xiaoming.age()，this指向xiaoming这个对象，即指向函数所属对象，即指向函数的调用者</span></div><div class="line">          xiaoming.age(); <span class="comment">// 今年调用是25,明年调用就变成26了</span></div></pre></td></tr></table></figure>
<p>  在一个方法内部，this是一个特殊变量，它始终指向当前对象，也就是xiaoming这个变量。所以，this.birth可以拿到xiaoming的birth属性。<br>  让我们拆开写：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">               <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">                name: <span class="string">'小明'</span>,</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               age: getAge</div><div class="line">          &#125;;  </div><div class="line">          xiaoming.age(); <span class="comment">// 25, 正常结果</span></div><div class="line">          getAge(); <span class="comment">// NaN</span></div></pre></td></tr></table></figure>
<p>  单独调用函数getAge()怎么返回了<code>NaN</code>？上面说了，<code>this</code>即指向函数的调用者，<code>getAge()</code>等价于<code>window.getAge()</code>，所以当调 用<code>getAge()</code>方法时，<code>this</code>指向window对象。<br>  由于这是一个巨大的设计错误，要想纠正可没那么简单。ECMA决定，在strict模式下让函数的this指向undefined，因此，在strict模式下，你会得到一个错误：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;  </div><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">               name: <span class="string">'小明'</span>,</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">                   <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">               &#125;</div><div class="line">          &#125;;</div><div class="line">          <span class="keyword">var</span> fn = xiaoming.age;</div><div class="line">          fn(); <span class="comment">// Uncaught TypeError: Cannot read property 'birth' of undefined</span></div></pre></td></tr></table></figure>
<p>  有些时候，喜欢重构的你把方法重构了一下：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;</div><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">               name: <span class="string">'小明'</span>,</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                       <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">                       <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">                   &#125;</div><div class="line">                   <span class="keyword">return</span> getAgeFromBirth();</div><div class="line">               &#125;</div><div class="line">          &#125;;  </div><div class="line">          xiaoming.age(); <span class="comment">// Uncaught TypeError: Cannot read property 'birth' of undefined</span></div></pre></td></tr></table></figure>
<p>  结果又报错了！原因是this指针只在age方法的函数内指向xiaoming，在函数内部定义的函数，this又指向undefined了！（在非strict模式下，它重新指向全局对象window！）<br>  修复的方法，我们用一个that变量首先捕获this：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;  </div><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">               name: <span class="string">'小明'</span>,</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               age: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   <span class="keyword">var</span> that = <span class="keyword">this</span>; <span class="comment">// 在方法内部一开始就捕获this</span></div><div class="line">                   <span class="function"><span class="keyword">function</span> <span class="title">getAgeFromBirth</span>(<span class="params"></span>) </span>&#123;</div><div class="line">                       <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">                       <span class="keyword">return</span> y - that.birth; <span class="comment">// 用that而不是this</span></div><div class="line">                   &#125;</div><div class="line">                   <span class="keyword">return</span> getAgeFromBirth();</div><div class="line">               &#125;</div><div class="line">          &#125;;</div><div class="line">          xiaoming.age(); <span class="comment">// 25</span></div></pre></td></tr></table></figure>
</li>
<li><p>apply<br>  虽然在一个独立的函数调用中，根据是否是strict模式，this指向undefined或window，不过，我们还是可以控制this的指向的！<br>  要指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。<br>  用<code>apply</code>修复<code>getAge()</code>调用：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">getAge</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> y = <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear();</div><div class="line">               <span class="keyword">return</span> y - <span class="keyword">this</span>.birth;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">               name: <span class="string">'小明'</span>,</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               age: getAge</div><div class="line">          &#125;;  </div><div class="line">          xiaoming.age(); <span class="comment">// 25</span></div><div class="line">          getAge.apply(xiaoming, []); <span class="comment">// 25, this指向xiaoming, 参数为空</span></div></pre></td></tr></table></figure>
<p>  另一个与<code>apply()</code>类似的方法是<code>call()</code>，唯一区别是：</p>
<ul>
<li><code>apply()</code>把参数打包成<code>Array</code>再传入；</li>
<li><p><code>call()</code>把参数按顺序传入。<br>比如调用<code>Math.max(3, 5, 4)</code>，分别用<code>apply()</code>和<code>call()</code>实现如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>]); <span class="comment">// 5</span></div><div class="line">          <span class="built_in">Math</span>.max.call(<span class="literal">null</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>); <span class="comment">// 5</span></div></pre></td></tr></table></figure>
<p>对普通函数调用，我们通常把<code>this</code>绑定为<code>null</code>。</p>
</li>
</ul>
</li>
<li>装饰器<br>  利用<code>apply()</code>，我们还可以动态改变函数的行为。<br>  JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。<br>  现在假定我们想统计一下代码一共调用了多少次<code>parseInt()</code>，可以把所有的调用都找出来，然后手动加上<code>count += 1</code>，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的<code>parseInt()</code>：  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line">          <span class="keyword">var</span> oldParseInt = <span class="built_in">parseInt</span>; <span class="comment">// 保存原函数</span></div><div class="line">          <span class="built_in">window</span>.parseInt = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">               count += <span class="number">1</span>;</div><div class="line">               <span class="keyword">return</span> oldParseInt.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>); <span class="comment">// 调用原函数</span></div><div class="line">          &#125;;</div><div class="line">          <span class="comment">// 测试:</span></div><div class="line">          <span class="built_in">parseInt</span>(<span class="string">'10'</span>);</div><div class="line">          <span class="built_in">parseInt</span>(<span class="string">'20'</span>);</div><div class="line">          <span class="built_in">parseInt</span>(<span class="string">'30'</span>);</div><div class="line">          count; <span class="comment">// 3</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><p>JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。<br>一个最简单的高阶函数：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">     <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, f</span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> f(x) + f(y);</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>当我们调用<code>add(-5, 6, Math.abs)</code>时，参数<code>x</code>，<code>y</code>和<code>f</code>分别接收<code>-5</code>，<code>6</code>和函数<code>Math.abs</code>，根据函数定义，我们可以推导计算过程为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     x = <span class="number">-5</span>;</div><div class="line">     y = <span class="number">6</span>;</div><div class="line">     f = <span class="built_in">Math</span>.abs;</div><div class="line">     f(x) + f(y) ==&gt; <span class="built_in">Math</span>.abs(<span class="number">-5</span>) + <span class="built_in">Math</span>.abs(<span class="number">6</span>) ==&gt; <span class="number">11</span>;</div><div class="line">     <span class="keyword">return</span> <span class="number">11</span>;</div></pre></td></tr></table></figure></p>
<h3 id="map-reduce"><a href="#map-reduce" class="headerlink" title="map/reduce"></a>map/reduce</h3><ul>
<li><p>map<br>  举例说明，比如我们有一个函数f(x)=x2，要把这个函数作用在一个数组[1, 2, 3, 4, 5, 6, 7, 8, 9]上，就可以用map实现如下：<br>  由于<code>map()</code>方法定义在JavaScript的<code>Array</code>中，我们调用<code>Array</code>的<code>map()</code>方法，传入我们自己的函数，就得到了一个新的<code>Array</code>作为结果：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">pow</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> x * x;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</div><div class="line">          arr.map(pow); <span class="comment">// [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></div></pre></td></tr></table></figure>
<p>  <code>map()</code>传入的参数是<code>pow</code>，即函数对象本身。<br>  map()作为高阶函数，事实上它把运算规则抽象了，因此，我们不但可以计算简单的f(x)=x2，还可以计算任意复杂的函数，比如，把Array的所有数字转为字符串：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</div><div class="line">          arr.map(<span class="built_in">String</span>); <span class="comment">// ['1', '2', '3', '4', '5', '6', '7', '8', '9']</span></div></pre></td></tr></table></figure>
</li>
<li><p>reduce<br>  Array的reduce()把一个函数作用在这个Array的[x1, x2, x3…]上，这个函数必须接收两个参数，reduce()把结果继续和序列的下一个元素做累积计算，其效果就是：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          [x1, x2, x3, x4].reduce(f) = f(f(f(x1, x2), x3), x4);</div></pre></td></tr></table></figure>
<p>  比方说对一个Array求和，就可以用reduce实现：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</div><div class="line">         <span class="keyword">var</span> sum =  arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> x + y;</div><div class="line">          &#125;); <span class="comment">// 25</span></div><div class="line">         <span class="keyword">return</span> sum;</div></pre></td></tr></table></figure>
<p>  要把[1, 3, 5, 7, 9]变换成整数13579，reduce()也能派上用场：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>];</div><div class="line">          arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> x * <span class="number">10</span> + y;</div><div class="line">          &#125;); <span class="comment">// 13579</span></div></pre></td></tr></table></figure>
<p>  <b>请把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[‘adam’, ‘LISA’, ‘barT’]，输出：[‘Adam’, ‘Lisa’, ‘Bart’]。</b></p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;</div><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">normalize</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> arr.map(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</div><div class="line">                   <span class="keyword">return</span>  s.slice(<span class="number">0</span>,<span class="number">1</span>).toUpperCase() + s.slice(<span class="number">1</span>).toLowerCase();</div><div class="line">               &#125;);</div><div class="line">          &#125;</div><div class="line">            <span class="comment">// 测试:</span></div><div class="line">          <span class="keyword">if</span> (normalize([<span class="string">'adam'</span>, <span class="string">'LISA'</span>, <span class="string">'barT'</span>]).toString() === [<span class="string">'Adam'</span>, <span class="string">'Lisa'</span>, <span class="string">'Bart'</span>].toString()) &#123;</div><div class="line">               alert(<span class="string">'测试通过!'</span>);</div><div class="line">          &#125; <span class="keyword">else</span> &#123;</div><div class="line">               alert(<span class="string">'测试失败!'</span>);</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p><code>filter</code>也是一个常用的操作，它用于把<code>Array</code>的某些元素过滤掉，然后返回剩下的元素。 和<code>map()</code>类似，<code>Array</code>的<code>filter()</code>也接收一个函数。和<code>map()</code>不同的是，<code>filter()</code>把传入的函数依次作用于每个元素，然后根据返回值是<code>true</code>还是<code>false</code>决定保留还是丢弃该元素。<br>例如，在一个Array中，删掉偶数，只保留奇数，可以这么写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">15</span>];</div><div class="line">     <span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> x % <span class="number">2</span> !== <span class="number">0</span>;</div><div class="line">     &#125;);</div><div class="line">     r; <span class="comment">// [1, 5, 9, 15]</span></div></pre></td></tr></table></figure></p>
<p>把一个<code>Array</code>中的空字符串删掉，可以这么写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> arr = [<span class="string">'A'</span>, <span class="string">''</span>, <span class="string">'B'</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="string">'C'</span>, <span class="string">'  '</span>];</div><div class="line">     <span class="keyword">var</span> r = arr.filter(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> s &amp;&amp; s.trim(); <span class="comment">// 注意：IE9以下的版本没有trim()方法</span></div><div class="line">     &#125;);</div><div class="line">     r; <span class="comment">// ['A', 'B', 'C']</span></div></pre></td></tr></table></figure></p>
<p><b>练习：请尝试用filter()筛选出素数：</b><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">     <span class="string">'use strict'</span>;</div><div class="line">     <span class="function"><span class="keyword">function</span> <span class="title">get_primes</span>(<span class="params">arr</span>) </span>&#123;  </div><div class="line">          <span class="keyword">return</span> arr.filter(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">             <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">2</span> ; i &lt; x ; i++)&#123;</div><div class="line">                 <span class="keyword">if</span>(x % i === <span class="number">0</span>)&#123;</div><div class="line">                      <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">                 &#125;</div><div class="line">             &#125;</div><div class="line">             <span class="keyword">return</span> x === <span class="number">1</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</div><div class="line">          &#125;);</div><div class="line">     &#125;</div><div class="line">     <span class="comment">// 测试:</span></div><div class="line">     <span class="keyword">var</span></div><div class="line">          x,</div><div class="line">          r,</div><div class="line">          arr = [];</div><div class="line">     <span class="keyword">for</span> (x = <span class="number">1</span>; x &lt; <span class="number">100</span>; x++) &#123;</div><div class="line">          arr.push(x);</div><div class="line">     &#125;</div><div class="line">     r = get_primes(arr);</div><div class="line">     <span class="keyword">if</span> (r.toString() === [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>].toString()) &#123;</div><div class="line">          alert(<span class="string">'测试通过!'</span>);</div><div class="line">     &#125; <span class="keyword">else</span> &#123;</div><div class="line">          alert(<span class="string">'测试失败: '</span> + r.toString());</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。如果是数字，我们可以直接比较，但如果是字符串或者两个对象呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。<br>JavaScript的<code>Array</code>的<code>sort()</code>方法就是用于排序的，但是排序结果可能让你大吃一惊：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">// 看上去正常的结果:</span></div><div class="line">     [<span class="string">'Google'</span>, <span class="string">'Apple'</span>, <span class="string">'Microsoft'</span>].sort(); <span class="comment">// ['Apple', 'Google', 'Microsoft'];</span></div><div class="line">     <span class="comment">// apple排在了最后:</span></div><div class="line">     [<span class="string">'Google'</span>, <span class="string">'apple'</span>, <span class="string">'Microsoft'</span>].sort(); <span class="comment">// ['Google', 'Microsoft", 'apple']  </span></div><div class="line">     <span class="comment">// 无法理解的结果:</span></div><div class="line">     [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>].sort(); <span class="comment">// [1, 10, 2, 20]</span></div></pre></td></tr></table></figure></p>
<p>第二个排序把apple排在了最后，是因为字符串根据ASCII码进行排序，而小写字母a的ASCII码在大写字母之后。<br>第三个排序因为<code>Array</code>的<code>sort()</code>方法默认把所有元素先转换为String再排序，结果<code>&#39;10&#39;</code>排在了<code>&#39;2&#39;</code>的前面，因为字符<code>&#39;1&#39;</code>比字符<code>&#39;2&#39;</code>的ASCII码小。<br>如果不知道sort()方法的默认排序规则，直接对数字排序，绝对栽进坑里！幸运的是，sort()方法也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。<br>要按数字大小排序，我们可以这么写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> arr = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">1</span>, <span class="number">2</span>];</div><div class="line">     arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">          <span class="keyword">if</span> (x &lt; y) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span> (x &gt; y) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">     &#125;); <span class="comment">// [1, 2, 10, 20]</span></div></pre></td></tr></table></figure></p>
<p>默认情况下，对字符串排序，是按照ASCII的大小比较的，现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能定义出忽略大小写的比较算法就可以：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> arr = [<span class="string">'Google'</span>, <span class="string">'apple'</span>, <span class="string">'Microsoft'</span>];</div><div class="line">     arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">s1, s2</span>) </span>&#123;</div><div class="line">          x1 = s1.toUpperCase();</div><div class="line">          x2 = s2.toUpperCase();</div><div class="line">          <span class="keyword">if</span> (x1 &lt; x2) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">if</span> (x1 &gt; x2) &#123;</div><div class="line">              <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">     &#125;); <span class="comment">// ['apple', 'Google', 'Microsoft']</span></div></pre></td></tr></table></figure></p>
<p>最后友情提示，sort()方法会直接对Array进行修改，它返回的结果仍是当前Array：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> a1 = [<span class="string">'B'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>];</div><div class="line">     <span class="keyword">var</span> a2 = a1.sort();</div><div class="line">     a1; <span class="comment">// ['A', 'B', 'C']</span></div><div class="line">     a2; <span class="comment">// ['A', 'B', 'C']</span></div><div class="line">     a1 === a2; <span class="comment">// true, a1和a2是同一对象</span></div></pre></td></tr></table></figure></p>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul>
<li><p>函数作为返回值<br>  高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。我们来实现一个对<code>Array</code>的求和，不返回求和的结果，而是返回求和的函数！</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">lazy_sum</span>(<span class="params">arr</span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</div><div class="line">                       <span class="keyword">return</span> x + y;</div><div class="line">                   &#125;);</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">return</span> sum;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
<p>  当我们调用<code>lazy_sum()</code>时，返回的并不是求和结果，而是求和函数：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> f = lazy_sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]); <span class="comment">// function sum()</span></div></pre></td></tr></table></figure>
<p>  调用函数<code>f</code>时，才真正计算求和的结果：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          f(); <span class="comment">// 15</span></div></pre></td></tr></table></figure>
<p>  在这个例子中，我们在函数<code>lazy_sum</code>中又定义了函数<code>sum</code>，并且，内部函数<code>sum</code>可以引用外部函数<code>lazy_sum</code>的参数和局部变量，当<code>lazy_sum</code>返回函数<code>sum</code>时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。<br>  请再注意一点，当我们调用<code>lazy_sum()</code>时，每次调用都会返回一个新的函数，即使传入相同的参数：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> f1 = lazy_sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</div><div class="line">          <span class="keyword">var</span> f2 = lazy_sum([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</div><div class="line">          f1 === f2; <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>  <code>f1()</code>和<code>f2()</code>的调用结果互不影响。</p>
</li>
<li><p>闭包<br>  注意到返回的函数在其定义内部引用了局部变量arr，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，实现起来可不容易。<br>另一个需要注意的问题是，返回的函数并没有立刻执行，而是直到调用了f()才执行。我们来看一个例子：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> arr = [];</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</div><div class="line">                    <span class="comment">// 每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个Array中返回了。</span></div><div class="line">                   arr.push(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                       <span class="keyword">return</span> i * i;</div><div class="line">                   &#125;);</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">return</span> arr;</div><div class="line">          &#125;  </div><div class="line">          <span class="keyword">var</span> results = count();</div><div class="line">          <span class="keyword">var</span> f1 = results[<span class="number">0</span>];</div><div class="line">          <span class="keyword">var</span> f2 = results[<span class="number">1</span>];</div><div class="line">          <span class="keyword">var</span> f3 = results[<span class="number">2</span>];</div><div class="line">          <span class="comment">//原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了4，因此最终结果为16。</span></div><div class="line">          f1(); <span class="comment">// 16</span></div><div class="line">          f2(); <span class="comment">// 16</span></div><div class="line">          f3(); <span class="comment">// 16</span></div></pre></td></tr></table></figure>
<p>  <b>返回闭包时牢记的一点就是：返回函数不要引用任何循环变量，或者后续会发生变化的变量。</b><br>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">count</span>(<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> arr = [];</div><div class="line">               <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">3</span>; i++) &#123;</div><div class="line">                   arr.push((<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</div><div class="line">                       <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                           <span class="keyword">return</span> n * n;</div><div class="line">                       &#125;</div><div class="line">                   &#125;)(i));</div><div class="line">               &#125;</div><div class="line">               <span class="keyword">return</span> arr;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">var</span> results = count();</div><div class="line">          <span class="keyword">var</span> f1 = results[<span class="number">0</span>];</div><div class="line">          <span class="keyword">var</span> f2 = results[<span class="number">1</span>];</div><div class="line">          <span class="keyword">var</span> f3 = results[<span class="number">2</span>];  </div><div class="line">          f1(); <span class="comment">// 1</span></div><div class="line">          f2(); <span class="comment">// 4</span></div><div class="line">          f3(); <span class="comment">// 9</span></div></pre></td></tr></table></figure>
<p>  注意这里用了一个“创建一个匿名函数并立刻执行”的语法：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          (<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> x * x;</div><div class="line">          &#125;)(<span class="number">3</span>); <span class="comment">// 9</span></div></pre></td></tr></table></figure>
<p>  理论上讲，创建一个匿名函数并立刻执行可以这么写：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x * x &#125; (<span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>  但是由于JavaScript语法解析的问题，会报SyntaxError错误，因此需要用括号把整个函数定义括起来：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          (<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123; <span class="keyword">return</span> x * x &#125;) (<span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>  闭包的实际运用:<br>  在面向对象的程序设计语言里，比如Java和C++，要在对象内部封装一个私有变量，可以用<code>private</code>修饰一个成员变量。在没有<code>class</code>机制，只有函数的语言里，借助闭包，同样可以封装一个私有变量。我们用JavaScript创建一个计数器：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'use strict'</span>;  </div><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">create_counter</span>(<span class="params">initial</span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> x = initial || <span class="number">0</span>;</div><div class="line">               <span class="keyword">return</span> &#123;</div><div class="line">                   inc: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                       x += <span class="number">1</span>;</div><div class="line">                       <span class="keyword">return</span> x;</div><div class="line">                   &#125;</div><div class="line">               &#125;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
<p>  它用起来像这样：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> c1 = create_counter();</div><div class="line">          c1.inc(); <span class="comment">// 1</span></div><div class="line">          c1.inc(); <span class="comment">// 2</span></div><div class="line">          c1.inc(); <span class="comment">// 3</span></div><div class="line">          <span class="keyword">var</span> c2 = create_counter(<span class="number">10</span>);</div><div class="line">          c2.inc(); <span class="comment">// 11</span></div><div class="line">          c2.inc(); <span class="comment">// 12</span></div><div class="line">          c2.inc(); <span class="comment">// 13</span></div></pre></td></tr></table></figure>
<p>  在返回的对象中，实现了一个闭包，该闭包携带了局部变量x，并且，从外部代码根本无法访问到变量x。换句话说，闭包就是携带状态的函数，并且它的状态可以完全对外隐藏起来。<br>闭包还可以把多参数的函数变成单参数的函数。例如，要计算xy可以用<code>Math.pow(x, y)</code>函数，不过考虑到经常计算x2或x3，我们可以利用闭包创建新的函数<code>pow2</code>和<code>pow3</code>：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">make_pow</span>(<span class="params">n</span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">                   <span class="keyword">return</span> <span class="built_in">Math</span>.pow(x, n);</div><div class="line">               &#125;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// 创建两个新函数:</span></div><div class="line">          <span class="keyword">var</span> pow2 = make_pow(<span class="number">2</span>);</div><div class="line">          <span class="keyword">var</span> pow3 = make_pow(<span class="number">3</span>);  </div><div class="line">          pow2(<span class="number">5</span>); <span class="comment">// 25</span></div><div class="line">          pow3(<span class="number">7</span>); <span class="comment">// 343</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="箭头函数-ES6新增"><a href="#箭头函数-ES6新增" class="headerlink" title="箭头函数(ES6新增)"></a>箭头函数(ES6新增)</h2><p>ES6标准新增了一种新的函数：Arrow Function（箭头函数）。<br>为什么叫Arrow Function？因为它的定义用的就是一个箭头：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">    x =&gt; x * x</div></pre></td></tr></table></figure></p>
<p>上面的箭头函数相当于：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">     <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> x * x;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>在继续学习箭头函数之前，请测试你的浏览器是否支持ES6的Arrow Function：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    <span class="string">'use strict'</span>;</div><div class="line">    <span class="keyword">var</span> fn = x =&gt; x * x;</div><div class="line">    alert(<span class="string">'你的浏览器支持ES6的Arrow Function!'</span>);</div></pre></td></tr></table></figure></p>
<p>箭头函数相当于匿名函数，并且简化了函数定义。箭头函数有两种格式，一种像上面的，只包含一个表达式，连<code>{ ... }</code>和<code>return</code>都省略掉了。还有一种可以包含多条语句，这时候就不能省略<code>{ ... }</code>和<code>return</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">     x =&gt; &#123;</div><div class="line">          <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</div><div class="line">              <span class="keyword">return</span> x * x;</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">else</span> &#123;</div><div class="line">              <span class="keyword">return</span> - x * x;</div><div class="line">          &#125;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>如果参数不是一个，就需要用括号()括起来：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">// 两个参数:</span></div><div class="line">     (x, y) =&gt; x * x + y * y</div><div class="line">    <span class="comment">//上例相当于</span></div><div class="line">    <span class="function"><span class="keyword">function</span> (<span class="params">x,y</span>)</span>&#123;</div><div class="line">         <span class="keyword">return</span> x * x + y * y;</div><div class="line">     &#125;  </div><div class="line">     <span class="comment">// 无参数:</span></div><div class="line">     () =&gt; <span class="number">3.14</span></div><div class="line">    <span class="comment">//上例相当于</span></div><div class="line">    <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">         <span class="keyword">return</span> <span class="number">3.14</span>;</div><div class="line">     &#125;  </div><div class="line">     <span class="comment">// 可变参数:</span></div><div class="line">     (x, y, ...rest) =&gt; &#123;</div><div class="line">          <span class="keyword">var</span> i, sum = x + y;</div><div class="line">          <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;rest.length; i++) &#123;</div><div class="line">              sum += rest[i];</div><div class="line">          &#125;</div><div class="line">          <span class="keyword">return</span> sum;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>如果要返回一个对象，就要注意，如果是单表达式，这么写的话会报错：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">// SyntaxError:</span></div><div class="line">     x =&gt; &#123; foo: x &#125;</div></pre></td></tr></table></figure></p>
<p>因为和函数体的<code>{ ... }</code>有语法冲突，所以要改为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">// ok:</span></div><div class="line">     x =&gt; (&#123; foo: x &#125;)</div></pre></td></tr></table></figure></p>
<ul>
<li><p>this<br>   箭头函数看上去是匿名函数的一种简写，但实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，由上下文确定。 回顾前面的例子，由于JavaScript函数对this绑定的错误处理，下面的例子无法得到预期结果：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> obj = &#123;</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></div><div class="line">                   <span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                       <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向window或undefined</span></div><div class="line">                   &#125;;</div><div class="line">                   <span class="keyword">return</span> fn();</div><div class="line">               &#125;</div><div class="line">          &#125;;</div></pre></td></tr></table></figure>
<p>  现在，箭头函数完全修复了<code>this</code>的指向，<code>this</code>总是指向词法作用域，也就是外层调用者<code>obj</code>：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> obj = &#123;</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               getAge: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                   <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></div><div class="line">                   <span class="keyword">var</span> fn = () =&gt; <span class="keyword">new</span> <span class="built_in">Date</span>().getFullYear() - <span class="keyword">this</span>.birth; <span class="comment">// this指向obj对象</span></div><div class="line">                   <span class="keyword">return</span> fn();</div><div class="line">               &#125;</div><div class="line">          &#125;;</div><div class="line">          obj.getAge(); <span class="comment">// 25</span></div></pre></td></tr></table></figure>
<p>  如果使用箭头函数，以前的那种hack写法：<code>var that = this;</code> 就不再需要了。<br>  由于this在箭头函数中已经按照词法作用域绑定了，所以，用call()或者apply()调用箭头函数时，无法对this进行绑定，即传入的第一个参数被忽略：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> obj = &#123;</div><div class="line">               birth: <span class="number">1990</span>,</div><div class="line">               getAge: <span class="function"><span class="keyword">function</span> (<span class="params">year</span>) </span>&#123;</div><div class="line">                   <span class="keyword">var</span> b = <span class="keyword">this</span>.birth; <span class="comment">// 1990</span></div><div class="line">                   <span class="keyword">var</span> fn = (y) =&gt; y - <span class="keyword">this</span>.birth; <span class="comment">// this.birth仍是1990</span></div><div class="line">                   <span class="keyword">return</span> fn.call(&#123;birth:<span class="number">2000</span>&#125;, year); <span class="comment">//第一个参数被忽略</span></div><div class="line">               &#125;</div><div class="line">          &#125;;</div><div class="line">          obj.getAge(<span class="number">2015</span>); <span class="comment">// 25</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="标准对象"><a href="#标准对象" class="headerlink" title="标准对象"></a>标准对象</h1><hr>
<p>在JavaScript的世界里，一切都是对象。<br>但是某些对象还是和其他对象不太一样。为了区分对象的类型，我们用typeof操作符获取对象的类型，它总是返回一个字符串：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">typeof</span> <span class="number">123</span>; <span class="comment">// 'number'</span></div><div class="line">     <span class="keyword">typeof</span> <span class="literal">NaN</span>; <span class="comment">// 'number'</span></div><div class="line">     <span class="keyword">typeof</span> <span class="string">'str'</span>; <span class="comment">// 'string'</span></div><div class="line">     <span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// 'boolean'</span></div><div class="line">     <span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// 'undefined'</span></div><div class="line">     <span class="keyword">typeof</span> <span class="built_in">Math</span>.abs; <span class="comment">// 'function'</span></div><div class="line">     <span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// 'object'</span></div><div class="line">     <span class="keyword">typeof</span> []; <span class="comment">// 'object'</span></div><div class="line">     <span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// 'object'</span></div></pre></td></tr></table></figure></p>
<p>可见，<code>number</code>、<code>string</code>、<code>boolean</code>、<code>function</code>和<code>undefined</code>有别于其他类型。特别注意<code>null</code>的类型是<code>object</code>，<code>Array</code>的类型也是<code>object</code>，如果我们用<code>typeof</code>将无法区分出<code>null</code>、<code>Array</code>和通常意义上的object——<code>{}</code>。</p>
<h2 id="包装对象"><a href="#包装对象" class="headerlink" title="包装对象"></a>包装对象</h2><p><code>number</code>、<code>boolean</code>和<code>string</code>都有包装对象。没错，在JavaScript中，字符串也区分<code>string</code>类型和它的包装类型。包装对象用<code>new</code>创建：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> n = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// 123,生成了新的包装类型</span></div><div class="line">          <span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// true,生成了新的包装类型</span></div><div class="line">          <span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>); <span class="comment">// 'str',生成了新的包装类型</span></div></pre></td></tr></table></figure></p>
<p>虽然包装对象看上去和原来的值一模一样，显示出来也是一模一样，但他们的类型已经变为object了！所以，包装对象和原始值用===比较会返回false：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>); <span class="comment">// 'object'</span></div><div class="line">          <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>) === <span class="number">123</span>; <span class="comment">// false</span></div><div class="line">          <span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>); <span class="comment">// 'object'</span></div><div class="line">          <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>) === <span class="literal">true</span>; <span class="comment">// false  </span></div><div class="line">          <span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>); <span class="comment">// 'object'</span></div><div class="line">          <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'str'</span>) === <span class="string">'str'</span>; <span class="comment">// false</span></div></pre></td></tr></table></figure></p>
<p>所以闲的蛋疼也不要使用包装对象！尤其是针对string类型！！！<br>如果没有写<code>new</code>关键字，那么<code>Number()</code>、<code>Boolean()</code>和<code>String()</code>被当做普通函数，把任何类型的数据转换为<code>number</code>、<code>boolean</code>和<code>string</code>类型（注意不是其包装类型）。<br>总结一下，有这么几条规则需要遵守：</p>
<ul>
<li>不要使用<code>new Number()</code>、<code>new Boolean()</code>、<code>new String()</code>创建包装对象；</li>
<li>用<code>parseInt()</code>或<code>parseFloat()</code>来转换任意类型到<code>number</code>；</li>
<li>用<code>String()</code>来转换任意类型到<code>string</code>，或者直接调用某个对象的<code>toString()</code>方法；</li>
<li>通常不必把任意类型转换为<code>boolean</code>再判断，因为可以直接写<code>if (myVar) {...}</code>；</li>
<li><code>typeof</code>操作符可以判断出<code>number</code>、<code>boolean</code>、<code>string</code>、<code>function</code>和<code>undefined</code>；</li>
<li>判断<code>Array</code>要使用<code>Array.isArray(arr)</code>；</li>
<li>判断<code>null</code>请使用<code>myVar === null</code>；</li>
<li>判断某个全局变量是否存在用<code>typeof window.myVar === &#39;undefined&#39;</code>；</li>
<li>函数内部判断某个变量是否存在用<code>typeof myVar === &#39;undefined&#39;</code>。</li>
</ul>
<h2 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h2><p>在JavaScript中，Date对象用来表示日期和时间。<br>要获取系统当前时间，用：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">          now; <span class="comment">// Wed Jun 24 2015 19:49:22 GMT+0800 (CST)</span></div><div class="line">          now.getFullYear(); <span class="comment">// 2015, 年份</span></div><div class="line">          now.getMonth(); <span class="comment">// 5, 月份，注意月份范围是0~11，5表示六月</span></div><div class="line">          now.getDate(); <span class="comment">// 24, 表示24号</span></div><div class="line">          now.getDay(); <span class="comment">// 3, 表示星期三</span></div><div class="line">          now.getHours(); <span class="comment">// 19, 24小时制</span></div><div class="line">          now.getMinutes(); <span class="comment">// 49, 分钟</span></div><div class="line">          now.getSeconds(); <span class="comment">// 22, 秒</span></div><div class="line">          now.getMilliseconds(); <span class="comment">// 875, 毫秒数</span></div><div class="line">          now.getTime(); <span class="comment">// 1435146562875, 以number形式表示的时间戳</span></div></pre></td></tr></table></figure></p>
<h2 id="RegExp：正则表达式"><a href="#RegExp：正则表达式" class="headerlink" title="RegExp：正则表达式"></a>RegExp：正则表达式</h2><ul>
<li><p>基本用法</p>
<ul>
<li>在正则表达式中，如果直接给出字符，就是精确匹配。用<code>\d</code>可以匹配一个数字，<code>\w</code>可以匹配一个字母或数字，所以：<code>&#39;00\d&#39;</code>可以匹配<code>&#39;007&#39;</code>，但无法匹配<code>&#39;00A&#39;</code>；<code>&#39;\d\d\d&#39;</code>可以匹配<code>&#39;010&#39;</code></li>
<li><code>.</code>可以匹配任意字符，所以：<code>&#39;js.&#39;</code>可以匹配<code>&#39;jsp&#39;</code>、<code>&#39;jss&#39;</code>、<code>&#39;js!&#39;</code>等等。</li>
<li>要匹配变长的字符，在正则表达式中，用<code>*</code>表示任意个字符（包括0个），用<code>+</code>表示至少一个字符，用<code>?</code>表示0个或1个字符，用<code>{n}</code>表示n个字符，用<code>{n,m}</code>表示n-m个字符：<br> 来看一个复杂的例子：<code>\d{3}\s+\d{3,8}</code>。<br> 1、<code>\d{3}</code>表示匹配3个数字，例如<code>&#39;010&#39;</code>；<br> 2、<code>\s</code>可以匹配一个空格（也包括Tab等空白符），所以<code>\s+</code>表示至少有一个空格，例如匹配<code>&#39; &#39;</code>，<code>&#39;\t\t&#39;</code>等；<br> 3、<code>\d{3,8}</code>表示3-8个数字，例如<code>&#39;1234567&#39;</code>。<br> 综合起来，上面的正则表达式可以匹配以任意个空格隔开的带区号的电话号码。<br> 如果要匹配<code>&#39;010-12345&#39;</code>这样的号码呢？由于<code>&#39;-&#39;</code>是特殊字符，在正则表达式中，要用<code>&#39;\&#39;</code>转义，所以，上面的正则是<code>\d{3}\-\d{3,8}</code>。</li>
<li>要做更精确地匹配，可以用<code>[]</code>表示范围，比如：<br> 1、<code>[0-9a-zA-Z\_]</code>可以匹配一个数字、字母或者下划线；<br> 2、<code>[0-9a-zA-Z\_]+</code>可以匹配至少由一个数字、字母或者下划线组成的字符串，比如<code>&#39;a100&#39;</code>，<code>&#39;0_Z&#39;</code>，<code>&#39;js2015&#39;</code>等等；<br> 3、<code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]*</code>可以匹配由字母或下划线、$开头，后接任意个由一个数字、字母或者下划线、$组成的字符串，也就是JavaScript允许的变量名；<br> 4、<code>[a-zA-Z\_\$][0-9a-zA-Z\_\$]{0, 19}</code>更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）。</li>
<li><code>A|B</code>可以匹配A或B，所以<code>[J|j]ava[S|s]cript</code>可以匹配<code>&#39;JavaScript&#39;</code>、<code>&#39;Javascript&#39;</code>、<code>&#39;javaScript&#39;</code>或者<code>&#39;javascript&#39;</code></li>
<li><code>^</code>表示行的开头，<code>^\d</code>表示必须以数字开头。</li>
<li><code>$</code>表示行的结束，<code>\d$</code>表示必须以数字结束。</li>
</ul>
</li>
<li><p>在JS中使用正则表达式</p>
<ul>
<li><p>定义与使用<br>第一种方式是直接通过<code>/正则表达式/</code>写出来，第二种方式是通过<code>new RegExp(&#39;正则表达式&#39;)</code>创建一个RegExp对象。</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> re1 = <span class="regexp">/ABC\-001/</span>;</div><div class="line">          <span class="keyword">var</span> re2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'ABC\\-001'</span>);</div></pre></td></tr></table></figure>
<p>简单使用：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> re = <span class="regexp">/^\d&#123;3&#125;\-\d&#123;3,8&#125;$/</span>;</div><div class="line">          re.test(<span class="string">'010-12345'</span>); <span class="comment">// true</span></div><div class="line">          re.test(<span class="string">'010-1234x'</span>); <span class="comment">// false</span></div><div class="line">          re.test(<span class="string">'010 12345'</span>); <span class="comment">// false</span></div></pre></td></tr></table></figure>
</li>
<li><p>切分字符串</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">          <span class="string">'a b   c'</span>.split(<span class="string">' '</span>); <span class="comment">// ['a', 'b', '', '', 'c']</span></div><div class="line">          <span class="string">'a b   c'</span>.split(<span class="regexp">/\s+/</span>); <span class="comment">// ['a', 'b', 'c']   /\s+/表示一个或多个空格</span></div><div class="line">          <span class="string">'a,b, c  d'</span>.split(<span class="regexp">/[\s\,]+/</span>); <span class="comment">// ['a', 'b', 'c', 'd']  /[\s\,]+/表示一个或多个空格或者逗号</span></div><div class="line">          <span class="string">'a,b;; c  d'</span>.split(<span class="regexp">/[\s\,\;]+/</span>); <span class="comment">// ['a', 'b', 'c', 'd']</span></div></pre></td></tr></table></figure>
</li>
<li><p>分组<br> 除了简单地判断是否匹配之外，正则表达式还有提取子串的强大功能。用<code>()</code>表示的就是要提取的分组（Group）。比如：<br> <code>^(\d{3})-(\d{3,8})$</code>分别定义了两个组，可以直接从匹配的字符串中提取出区号和本地号码：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">            <span class="keyword">var</span> re = <span class="regexp">/^(\d&#123;3&#125;)-(\d&#123;3,8&#125;)$/</span>;</div><div class="line">            re.exec(<span class="string">'010-12345'</span>); <span class="comment">// ['010-12345', '010', '12345']</span></div><div class="line">            re.exec(<span class="string">'010 12345'</span>); <span class="comment">// null</span></div></pre></td></tr></table></figure>
<p> 如果正则表达式中定义了组，就可以在<code>RegExp</code>对象上用<code>exec()</code>方法提取出子串来。<br> <code>exec()</code>方法在匹配成功后，会返回一个<code>Array</code>，第一个元素是正则表达式匹配到的整个字符串，后面的字符串表示匹配成功的子串。<code>exec()</code>方法在匹配失败时返回<code>null</code>。<br> 提取子串非常有用。来看一个更凶残的例子：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">            <span class="keyword">var</span> re = <span class="regexp">/^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/</span>;</div><div class="line">            re.exec(<span class="string">'19:05:30'</span>); <span class="comment">// ['19:05:30', '19', '05', '30']</span></div></pre></td></tr></table></figure>
</li>
<li><p>贪婪匹配<br>需要特别指出的是，正则匹配默认是贪婪匹配，也就是匹配尽可能多的字符。举例如下，匹配出数字后面的0：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">        <span class="keyword">var</span> re = <span class="regexp">/^(\d+)(0*)$/</span>;</div><div class="line">        re.exec(<span class="string">'102300'</span>); <span class="comment">// ['102300', '102300', '']</span></div></pre></td></tr></table></figure>
<p>由于<code>\d+</code>采用贪婪匹配，直接把后面的<code>0</code>全部匹配了，结果<code>0*</code>只能匹配空字符串了。<br>必须让<code>\d+</code>采用非贪婪匹配（也就是尽可能少匹配），才能把后面的<code>0</code>匹配出来，加个<code>?</code>就可以让<code>\d+</code>采用非贪婪匹配：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">        <span class="keyword">var</span> re = <span class="regexp">/^(\d+?)(0*)$/</span>;</div><div class="line">        re.exec(<span class="string">'102300'</span>); <span class="comment">// ['102300', '1023', '00']</span></div></pre></td></tr></table></figure>
</li>
<li><p>全局搜索<br>JavaScript的正则表达式还有几个特殊的标志，最常用的是<code>g</code>，表示全局匹配<br>全局匹配可以多次执行<code>exec()</code>方法来搜索一个匹配的字符串。当我们指定<code>g</code>标志后，每次运行<code>exec()</code>，正则表达式本身会更新<code>lastIndex</code>属性，表示上次匹配到的最后索引：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">        <span class="keyword">var</span> s = <span class="string">'JavaScript, VBScript, JScript and ECMAScript'</span>;</div><div class="line">        <span class="keyword">var</span> re=<span class="regexp">/[a-zA-Z]+Script/g</span>;</div><div class="line">        <span class="comment">// 使用全局匹配:</span></div><div class="line">        re.exec(s); <span class="comment">// ['JavaScript']</span></div><div class="line">        re.lastIndex; <span class="comment">// 10 </span></div><div class="line">        re.exec(s); <span class="comment">// ['VBScript']</span></div><div class="line">        re.lastIndex; <span class="comment">// 20</span></div><div class="line">        re.exec(s); <span class="comment">// ['JScript']</span></div><div class="line">        re.lastIndex; <span class="comment">// 29 </span></div><div class="line">        re.exec(s); <span class="comment">// ['ECMAScript']</span></div><div class="line">        re.lastIndex; <span class="comment">// 44 </span></div><div class="line">        re.exec(s); <span class="comment">// null，直到结束仍没有匹配到</span></div></pre></td></tr></table></figure>
<p>正则表达式还可以指定i标志，表示忽略大小写，m标志，表示执行多行匹配。</p>
</li>
</ul>
</li>
</ul>
<h2 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h2><ul>
<li><p>序列化</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">            <span class="keyword">var</span> xiaoming = &#123;                name: <span class="string">'小明'</span>,</div><div class="line">               age: <span class="number">14</span>,</div><div class="line">                 gender: <span class="literal">true</span>,</div><div class="line">                 height: <span class="number">1.65</span>,</div><div class="line">                 grade: <span class="literal">null</span>,</div><div class="line">                <span class="string">'middle-school'</span>: <span class="string">'\"W3C\" Middle School'</span>,</div><div class="line">                 skills: [<span class="string">'JavaScript'</span>, <span class="string">'Java'</span>, <span class="string">'Python'</span>, <span class="string">'Lisp'</span>]</div><div class="line">             &#125;; </div><div class="line">            <span class="built_in">JSON</span>.stringify(xiaoming); <span class="comment">// '&#123;"name":"小明","age":14,"gender":true,"height":1.65,"grade":null,"middle-school":"\"W3C\" Middle School","skills":["JavaScript","Java","Python","Lisp"]&#125;'</span></div></pre></td></tr></table></figure>
<p>要输出得好看一些，可以加上参数，按缩进输出：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">            <span class="built_in">JSON</span>.stringify(xiaoming, <span class="literal">null</span>, <span class="string">'  '</span>);</div></pre></td></tr></table></figure>
<p>第二个参数用于控制如何筛选对象的键值，如果我们只想输出指定的属性，可以传入Array：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">            <span class="built_in">JSON</span>.stringify(xiaoming, [<span class="string">'name'</span>, <span class="string">'skills'</span>], <span class="string">'  '</span>);</div></pre></td></tr></table></figure>
<p>还可以传入一个函数，这样对象的每个键值对都会被函数先处理：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">             <span class="function"><span class="keyword">function</span> <span class="title">convert</span>(<span class="params">key, value</span>) </span>&#123;</div><div class="line">                    <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">'string'</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> value.toUpperCase();</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">return</span> value;</div><div class="line">               &#125;</div><div class="line">               <span class="built_in">JSON</span>.stringify(xiaoming, convert, <span class="string">'  '</span>);</div></pre></td></tr></table></figure>
</li>
<li><p>反序列化<br>拿到一个JSON格式的字符串，我们直接用JSON.parse()把它变成一个JavaScript对象：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">               <span class="built_in">JSON</span>.parse(<span class="string">'[1,2,3,true]'</span>); <span class="comment">// [1, 2, 3, true]</span></div><div class="line">               <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"name":"小明","age":14&#125;'</span>); <span class="comment">// Object &#123;name: '小明', age: 14&#125;</span></div><div class="line">               <span class="built_in">JSON</span>.parse(<span class="string">'true'</span>); <span class="comment">// true</span></div><div class="line">               <span class="built_in">JSON</span>.parse(<span class="string">'123.45'</span>); <span class="comment">// 123.45</span></div></pre></td></tr></table></figure>
<p>还可以接收一个函数，用来转换解析出的属性：</p>
   <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">               <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"name":"小明","age":14&#125;'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</div><div class="line">                    <span class="comment">// 把number * 2:</span></div><div class="line">                    <span class="keyword">if</span> (key === <span class="string">'name'</span>) &#123;</div><div class="line">                        <span class="keyword">return</span> value + <span class="string">'同学'</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">return</span> value;</div><div class="line">               &#125;); <span class="comment">// Object &#123;name: '小明同学', age: 14&#125;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><hr>
<p>JavaScript不区分类和实例的概念，而是通过原型（prototype）来实现面向对象编程。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">     <span class="keyword">var</span> Student = &#123;</div><div class="line">          name: <span class="string">'Robot'</span>,</div><div class="line">          height: <span class="number">1.2</span>,</div><div class="line">          run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">              <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is running...'</span>);</div><div class="line">          &#125;</div><div class="line">     &#125;;  </div><div class="line">     <span class="keyword">var</span> xiaoming = &#123;</div><div class="line">          name: <span class="string">'小明'</span></div><div class="line">     &#125;;  </div><div class="line">     xiaoming.__proto__ = Student;</div></pre></td></tr></table></figure></p>
<p>注意最后一行代码把<code>xiaoming</code>的原型指向了对象<code>Student</code>，看上去<code>xiaoming</code>仿佛是从<code>Student</code>继承下来的：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">     xiaoming.name; <span class="comment">// '小明'</span></div><div class="line">     xiaoming.run(); <span class="comment">// 小明 is running...</span></div></pre></td></tr></table></figure></p>
<p><code>xiaoming</code>有自己的<code>name</code>属性，但并没有定义<code>run()</code>方法。不过，由于小明是从<code>Student</code>继承而来，只要<code>Student</code>有<code>run()</code>方法，<code>xiaoming</code>也可以调用：<br><b style="color:red;">请注意</b>，上述代码仅用于演示目的。在编写JavaScript代码时，不要直接用<code>obj.__proto__</code>去改变一个对象的原型，并且，低版本的IE也无法使用<code>__proto__</code>。<code>Object.create()</code>方法可以传入一个原型对象，并创建一个基于该原型的新对象，但是新对象什么属性都没有，因此，我们可以编写一个函数来创建<code>xiaoming</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">     <span class="comment">// 原型对象:</span></div><div class="line">     <span class="keyword">var</span> Student = &#123;</div><div class="line">          name: <span class="string">'Robot'</span>,</div><div class="line">          height: <span class="number">1.2</span>,</div><div class="line">          run: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">              <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">' is running...'</span>);</div><div class="line">          &#125;</div><div class="line">     &#125;;  </div><div class="line">     <span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">          <span class="comment">// 基于Student原型创建一个新对象:</span></div><div class="line">          <span class="keyword">var</span> s = <span class="built_in">Object</span>.create(Student);</div><div class="line">          <span class="comment">// 初始化新对象:</span></div><div class="line">          s.name = name;</div><div class="line">          <span class="keyword">return</span> s;</div><div class="line">     &#125;  </div><div class="line">     <span class="keyword">var</span> xiaoming = createStudent(<span class="string">'小明'</span>);</div><div class="line">     xiaoming.run(); <span class="comment">// 小明 is running...</span></div><div class="line">     xiaoming.__proto__ === Student; <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>这是创建原型继承的一种方法，JavaScript还有其他方法来创建对象，我们在后面会一一讲到。</p>
<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>JavaScript对每个创建的对象都会设置一个原型，指向它的原型对象。<br>当我们用<code>obj.xxx</code>访问一个对象的属性时，JavaScript引擎先在当前对象上查找该属性，如果没有找到，就到其原型对象上找，如果还没有找到，就一直上溯到<code>Object.prototype</code>对象，最后，如果还没有找到，就只能返回<code>undefined</code>。<br>例如，创建一个Array对象：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">    <span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div></pre></td></tr></table></figure></p>
<p>其原型链是：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">    arr ----&gt; <span class="built_in">Array</span>.prototype ----&gt; <span class="built_in">Object</span>.prototype ----&gt; <span class="literal">null</span></div></pre></td></tr></table></figure></p>
<p><code>Array.prototype</code>定义了<code>indexOf()</code>、<code>shift()</code>等方法，因此你可以在所有的<code>Array</code>对象上直接调用这些方法。<br>当我们创建一个函数时：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">     <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">     &#125;</div></pre></td></tr></table></figure></p>
<p>函数也是一个对象，它的原型链是：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">    foo ----&gt; <span class="built_in">Function</span>.prototype ----&gt; <span class="built_in">Object</span>.prototype ----&gt; <span class="literal">null</span></div></pre></td></tr></table></figure></p>
<p>由于<code>Function.prototype</code>定义了<code>apply()</code>等方法，因此，所有函数都可以调用<code>apply()</code>方法。<br>很容易想到，如果原型链很长，那么访问一个对象的属性就会因为花更多的时间查找而变得更慢，因此要注意不要把原型链搞得太长。</p>
<ul>
<li><p>构造函数<br>除了直接用<code>{ ... }</code>创建一个对象外，JavaScript还可以用一种构造函数的方法来创建对象。它的用法是，先定义一个构造函数：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">       <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">            <span class="keyword">this</span>.name = name;</div><div class="line">            <span class="keyword">this</span>.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">            &#125;</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p> 在JavaScript中，可以用关键字new来调用这个函数，并返回一个对象：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">          <span class="keyword">var</span> xiaoming = <span class="keyword">new</span> Student(<span class="string">'小明'</span>);</div><div class="line">          xiaoming.name; <span class="comment">// '小明'</span></div><div class="line">          xiaoming.hello(); <span class="comment">// Hello, 小明!</span></div></pre></td></tr></table></figure>
<p><b style="color:red;">注意</b>，如果不写<code>new</code>，这就是一个普通函数，它返回<code>undefined</code>。但是，如果写了<code>new</code>，它就变成了一个构造函数，它绑定的<code>this</code>指向新创建的对象，并默认返回<code>this</code>，也就是说，不需要在最后写<code>return this;</code>。<br>新创建的<code>xiaoming</code>的原型链是：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          xiaoming ----&gt; Student.prototype ----&gt; <span class="built_in">Object</span>.prototype ----&gt; <span class="literal">null</span></div></pre></td></tr></table></figure>
<p>也就是说，<code>xiaoming</code>的原型指向函数<code>Student</code>的原型。如果你又创建了<code>xiaohong</code>、<code>xiaojun</code>，那么这些对象的原型与<code>xiaoming</code>是一样的。<br>用<code>new Student()</code>创建的对象还从原型上获得了一个<code>constructor</code>属性，它指向函数<code>Student</code>本身。<br><b style="color:red;">总结：</b>函数<code>Student</code>恰好有个属性<code>prototype</code>指向<code>xiaoming</code>、<code>xiaohong</code>的原型对象，而且这个原型对象自己还有个属性<code>constructor</code>，指向<code>Student</code>函数本身。但是<code>xiaoming</code>、<code>xiaohong</code>这些对象可没有<code>prototype</code>这个属性，不过可以用<code>__proto__</code>这个非标准用法来查看。另外，要让创建的对象共享一个<code>hello</code>函数，根据对象的属性查找原则，我们只要把<code>hello</code>函数移动到<code>xiaoming</code>、<code>xiaohong</code>这些对象共同的原型上就可以了，也就是<code>Student.prototype</code>：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">               <span class="keyword">this</span>.name = name;</div><div class="line">           &#125;  </div><div class="line">          Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">               alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">          &#125;;</div></pre></td></tr></table></figure>
</li>
<li><p>忘记写<code>new</code>怎么办<br>在strict模式下，<code>this.name = name</code>将报错，因为<code>this</code>绑定为<code>undefined</code>，在非strict模式下，<code>this.name = name</code>不报错，因为<code>this</code>绑定为<code>window</code>，于是无意间创建了全局变量<code>name</code>，并且返回<code>undefined</code>，这个结果更糟糕。 所以，调用构造函数千万不要忘记写<code>new</code>。为了区分普通函数和构造函数，按照约定，构造函数首字母应当大写，而普通函数首字母应当小写，这样，一些语法检查工具如jslint将可以帮你检测到漏写的<code>new</code>。<br>最后，我们还可以编写一个<code>createStudent()</code>函数，在内部封装所有的<code>new</code>操作。一个常用的编程模式像这样：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">               <span class="keyword">this</span>.name = props.name || <span class="string">'匿名'</span>; <span class="comment">// 默认值为'匿名'</span></div><div class="line">               <span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>; <span class="comment">// 默认值为1</span></div><div class="line">          &#125;  </div><div class="line">          Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">               alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">          &#125;;  </div><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">createStudent</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> <span class="keyword">new</span> Student(props || &#123;&#125;)</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h2><p>JavaScript的原型继承实现方式就是：</p>
<ul>
<li>定义新的构造函数，并在内部用<code>call()</code>调用希望“继承”的构造函数，并绑定<code>this</code>；</li>
<li>借助中间函数<code>F</code>实现原型链继承，最好通过封装的<code>inherits</code>函数完成；</li>
<li>继续在新的构造函数的原型上定义新方法。<br>示例，创建一个子类<code>PrimaryStudent</code>继承自<code>Student</code>类: <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">               <span class="keyword">this</span>.name = props.name || <span class="string">'Unnamed'</span>;</div><div class="line">          &#125;</div><div class="line">          Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">               alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">          &#125;  </div><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">PrimaryStudent</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">              <span class="comment">//调用Student类的构造函数,此时Student的this表示当前对象。</span></div><div class="line"></div><div class="line">              Student.call(<span class="keyword">this</span>, props);</div><div class="line">              <span class="keyword">this</span>.grade = props.grade || <span class="number">1</span>;</div><div class="line">          &#125;  </div><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">inherits</span>(<span class="params">Child, Parent</span>) </span>&#123;</div><div class="line">               <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</div><div class="line">               F.prototype = Parent.prototype;</div><div class="line">               Child.prototype = <span class="keyword">new</span> F();</div><div class="line">               Child.prototype.constructor = Child;</div><div class="line">          &#125;</div><div class="line">          <span class="comment">// 实现原型继承链:</span></div><div class="line">          inherits(PrimaryStudent, Student);</div><div class="line">          <span class="comment">// 绑定其他方法到PrimaryStudent原型:</span></div><div class="line">          PrimaryStudent.prototype.getGrade = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">               <span class="keyword">return</span> <span class="keyword">this</span>.grade;</div><div class="line">          &#125;;</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="class继承-ES6引入"><a href="#class继承-ES6引入" class="headerlink" title="class继承(ES6引入)"></a>class继承(ES6引入)</h2><p>新的关键字class从ES6开始正式被引入到JavaScript中。class的目的就是让定义类更简单。</p>
<ul>
<li><p>函数定义<br>用函数实现Student的方法：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          <span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">                <span class="keyword">this</span>.name = name;</div><div class="line">          &#125;</div><div class="line">          Student.prototype.hello = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">           &#125;</div></pre></td></tr></table></figure>
<p>如果用新的class关键字来编写<code>Student</code>，可以这样写：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">          <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">               <span class="keyword">constructor</span>(name) &#123;</div><div class="line">                   <span class="keyword">this</span>.name = name;</div><div class="line">               &#125;</div><div class="line">               hello() &#123;</div><div class="line">                   alert(<span class="string">'Hello, '</span> + <span class="keyword">this</span>.name + <span class="string">'!'</span>);</div><div class="line">               &#125;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
</li>
<li><p>class继承<br>用class定义对象的另一个巨大的好处是继承更方便了。想一想我们从Student派生一个PrimaryStudent需要编写的代码量。现在，原型继承的中间对象，原型对象的构造函数等等都不需要考虑了，直接通过extends来实现：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">          <span class="class"><span class="keyword">class</span> <span class="title">PrimaryStudent</span> <span class="keyword">extends</span> <span class="title">Student</span> </span>&#123;</div><div class="line">               <span class="keyword">constructor</span>(name, grade) &#123;</div><div class="line">                   <span class="keyword">super</span>(name); <span class="comment">// 记得用super调用父类的构造方法!</span></div><div class="line">                   <span class="keyword">this</span>.grade = grade;</div><div class="line">               &#125;</div><div class="line">               myGrade() &#123;</div><div class="line">                   alert(<span class="string">'I am at grade '</span> + <span class="keyword">this</span>.grade);</div><div class="line">               &#125;</div><div class="line">          &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h1><hr>
<p>目前主流的浏览器分这么几种：</p>
<ul>
<li>IE 6~11：国内用得最多的IE浏览器，历来对W3C标准支持差。从IE10开始支持ES6标准；</li>
<li>Chrome：Google出品的基于Webkit内核浏览器，内置了非常强悍的JavaScript引擎——V8。由于Chrome一经安装就时刻保持自升级，所以不用管它的版本，最新版早就支持ES6了；</li>
<li>Safari：Apple的Mac系统自带的基于Webkit内核的浏览器，从OS X 10.7 Lion自带的6.1版本开始支持ES6，目前最新的OS X 10.11 El Caption自带的Safari版本是9.x，早已支持ES6；</li>
<li>Firefox：Mozilla自己研制的Gecko内核和JavaScript引擎OdinMonkey。早期的Firefox按版本发布，后来终于聪明地学习Chrome的做法进行自升级，时刻保持最新；</li>
<li>移动设备上目前iOS和Android两大阵营分别主要使用Apple的Safari和Google的Chrome，由于两者都是Webkit核心，结果HTML5首先在手机上全面普及（桌面绝对是Microsoft拖了后腿），对JavaScript的标准支持也很好，最新版本均支持ES6。</li>
</ul>
<h2 id="浏览器对象"><a href="#浏览器对象" class="headerlink" title="浏览器对象"></a>浏览器对象</h2><p>JavaScript可以获取浏览器提供的很多对象，并进行操作。</p>
<ul>
<li>window<br><code>window</code>对象不但充当全局作用域，而且表示浏览器窗口。<br><code>window</code>对象有<code>innerWidth</code>和<code>innerHeight</code>属性，可以获取浏览器窗口的内部宽度和高度。内部宽高是指除去菜单栏、工具栏、边框等占位元素后，用于显示网页的净宽高。对应的，还有一个<code>outerWidth</code>和<code>outerHeight</code>属性，可以获取浏览器窗口的整个宽高。</li>
<li>navigator<br>navigator对象表示浏览器的信息，最常用的属性包括：<ul>
<li>navigator.appName：浏览器名称；</li>
<li>navigator.appVersion：浏览器版本；</li>
<li>navigator.language：浏览器设置的语言；</li>
<li>navigator.platform：操作系统类型；</li>
<li>navigator.userAgent：浏览器设定的User-Agent字符串。</li>
</ul>
</li>
<li>screen<br>   <code>screen</code>对象表示屏幕的信息，常用的属性有：<ul>
<li>screen.width：屏幕宽度，以像素为单位；</li>
<li>screen.height：屏幕高度，以像素为单位；</li>
<li>screen.colorDepth：返回颜色位数，如8、16、24。</li>
</ul>
</li>
<li><p>location<br>  <code>location</code>对象表示当前页面的URL信息。<br>  可以用<code>location.href</code>获取完整URL。要获得URL各个部分的值，可以这么写：</p>
 <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">          location.protocol; <span class="comment">// 'http'</span></div><div class="line">          location.host; <span class="comment">// 'www.example.com'</span></div><div class="line">          location.port; <span class="comment">// '8080'</span></div><div class="line">          location.pathname; <span class="comment">// '/path/index.html'</span></div><div class="line">          location.search; <span class="comment">// '?a=1&amp;b=2'</span></div><div class="line">          location.hash; <span class="comment">// 'TOP'</span></div></pre></td></tr></table></figure>
<p> 要加载一个新页面，可以调用<code>location.assign()</code>。如果要重新加载当前页面，调用location.reload()方法非常方便。</p>
</li>
<li><p>document<br>  <code>document</code>对象表示当前页面。由于HTML在浏览器中以DOM形式表示为树形结构，<code>document</code>对象就是整个DOM树的根节点。<br>  document的title属性是从HTML文档中的<title>xxx</title>读取的，但是可以动态改变<br>  要查找DOM树的某个节点，需要从document对象开始查找。最常用的查找是根据ID和Tag Name。<br>  <code>document</code>对象还有一个<code>cookie</code>属性，可以获取当前页面的Cookie。<br>  Cookie是由服务器发送的key-value标示符。因为HTTP协议是无状态的，但是服务器要区分到底是哪个用户发过来的请求，就可以用Cookie来区分。当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如<code>user=ABC123XYZ(加密的字符串)</code>…，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。<br>  JavaScript可以通过<code>document.cookie</code>读取到当前页面的Cookie：</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">          <span class="built_in">document</span>.cookie; <span class="comment">// 'v=123; remember=true; prefer=zh'</span></div></pre></td></tr></table></figure>
<p>  由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，这是因为在HTML页面中引入第三方的JavaScript代码是允许的：</p>
  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">          <span class="comment">&lt;!-- 当前页面在wwwexample.com --&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">               <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">                   <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://www.foo.com/jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">               <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">              ...</div><div class="line">          <span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>  如果引入的第三方的JavaScript中存在恶意代码，则<code>www.foo.com</code>网站将直接获取到<code>www.example.com</code>网站的用户登录信息。<br>  为了解决这个问题，服务器在设置Cookie时可以使用httpOnly，设定了httpOnly的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持httpOnly选项，IE从IE6 SP1开始支持。</p>
</li>
<li>history<br>  <code>history</code>对象保存了浏览器的历史记录，JavaScript可以调用<code>history</code>对象的<code>back()</code>或<code>forward ()</code>，相当于用户点击了浏览器的“后退”或“前进”按钮。但，任何情况，你都不应该使用history这个对象了。</li>
</ul>
<h2 id="操作DOM"><a href="#操作DOM" class="headerlink" title="操作DOM"></a>操作DOM</h2><p>DOM是一个树形结构。操作一个DOM节点实际上就是这么几个操作：</p>
<ul>
<li>更新：更新该DOM节点的内容，相当于更新了该DOM节点表示的HTML的内容；</li>
<li>遍历：遍历该DOM节点下的子节点，以便进行进一步操作；</li>
<li>添加：在该DOM节点下新增一个子节点，相当于动态增加了一个HTML节点；</li>
<li>删除：将该节点从HTML中删除，相当于删掉了该DOM节点的内容以及它包含的所有子节点。</li>
</ul>
<p>由于ID在HTML文档中是唯一的，所以<code>document.getElementById()</code>可以直接定位唯一的一个DOM节点。<code>document.getElementsByTagName()</code>和<code>document.getElementsByClassName()</code>总是返回一组DOM节点。要精确地选择DOM，可以先定位父节点，再从父节点开始选择，以缩小范围。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">// 返回ID为&apos;test&apos;的节点：</div><div class="line">var test = document.getElementById(&apos;test&apos;);</div><div class="line"></div><div class="line">// 先定位ID为&apos;test-table&apos;的节点，再返回其内部所有tr节点：</div><div class="line">var trs = document.getElementById(&apos;test-table&apos;).getElementsByTagName(&apos;tr&apos;);</div><div class="line"></div><div class="line">// 先定位ID为&apos;test-div&apos;的节点，再返回其内部所有class包含red的节点：</div><div class="line">var reds = document.getElementById(&apos;test-div&apos;).getElementsByClassName(&apos;red&apos;);</div><div class="line"></div><div class="line">// 获取节点test下的所有直属子节点:</div><div class="line">var cs = test.children;</div><div class="line"></div><div class="line">// 获取节点test下第一个、最后一个子节点：</div><div class="line">var first = test.firstElementChild;</div><div class="line">var last = test.lastElementChild;</div></pre></td></tr></table></figure></p>
<p>第二种方法是使用<code>querySelector()</code>和<code>querySelectorAll()</code>，需要了解selector语法，然后使用条件来获取节点，更加方便：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">// 通过querySelector获取ID为q1的节点：</div><div class="line">var q1 = document.querySelector(&apos;#q1&apos;);</div><div class="line"></div><div class="line">// 通过querySelectorAll获取q1节点内的符合条件的所有节点：</div><div class="line">var ps = q1.querySelectorAll(&apos;div.highlighted &gt; p&apos;);</div></pre></td></tr></table></figure></p>
<p>注意：低版本的IE&lt;8不支持<code>querySelector</code>和<code>querySelectorAll</code>。IE8仅有限支持。</p>
<h3 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h3><ul>
<li><p>创建元素：<code>document.createElement()</code><br>  使用<code>document.createElement()</code>可以创建新元素。这个方法只接受一个参数，即要创建元素的标签名。这个标签名在<code>HTML</code>文档中不区分大小写，在<code>XHTML</code>中区分大小写。<br>  此时，新元素尚未被添加到文档树中，因此设置各种特性均不会影响浏览器的显示。要添加到文档树，可用<code>appendChild()、insertBefore()、replaceChild()</code>。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var div = document.createElement(&quot;div&quot;);</div><div class="line">div.id = &quot;myDiv&quot;;</div><div class="line">div.className = &quot;div1&quot;;</div><div class="line">document.body.appendChild(div);</div></pre></td></tr></table></figure>
<p>  在<code>IE</code>中可以为<code>createElement()</code>方法传入完整的元素标签和属性。(只在<code>IE</code>中兼容)</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var div = document.createElement(&quot;&lt;div id=\&quot;mydiv\&quot; class=\&quot;div1\&quot;&gt;&lt;/div&gt;&quot;);</div><div class="line">不能再标签里加其他元素节点或者文本节点，如下的方式和上面的得出的节点一样</div><div class="line">var div = document.createElement(&quot;&lt;div id=\&quot;mydiv\&quot; class=\&quot;div1\&quot;&gt;12212&lt;/div&gt;&quot;);</div></pre></td></tr></table></figure>
</li>
<li><p>创建文本节点 ：<code>document.createTextNode</code><br>使用<code>document.createTextNode()</code>来创建文本节点，这个方法接受一个参数：要插入节点的文本。与设置已有文本节点的值一样，作为参数的文本将按照<code>HTML</code>或<code>XML</code>的格式进行编码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.createTextNode(&quot;121212&quot;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h3><p>（<code>IE9</code>以前不将换行和空格看做文本节点，其他浏览器会）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;div1&quot;&gt;</div><div class="line">    &lt;div id=&quot;div2&quot;&gt;2&lt;/div&gt;</div><div class="line">    &lt;div id=&quot;div3&quot;&gt;3&lt;/div&gt;</div><div class="line">    &lt;div id=&quot;div4&quot;&gt;4&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<ul>
<li><code>parentNode</code>是指定节点的父节点.</li>
<li><p><code>childNodes</code> 返回包含指定节点的子节点的集合，该集合为即时更新的集合（<code>live collection</code>）。<br>即时更新就是对节点元素的任意修改都会立即反映到结果里。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var child2 = document.getElementById(&quot;div2&quot;);</div><div class="line">    var parent = child2.parentNode;</div><div class="line">    var allChilds = parent.childNodes;</div><div class="line">    console.log(allChilds.length) // IE下是3，其他浏览器是7</div><div class="line"></div><div class="line">    var nodeAdd = document.createElement(&quot;div&quot;);</div><div class="line">    var textAdd = document.createTextNode(&quot;这是添加的文本节点&quot;);</div><div class="line">    nodeAdd.appendChild(textAdd);</div><div class="line">    parent.appendChild(nodeAdd);</div><div class="line">    console.log(allChilds.length);// IE下是4，其他浏览器是8</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
<li><p><code>nextSibling</code>返回某节点的下一个兄弟节点，<code>previousSibling</code>返回某节点的上一个兄弟节点，没有的话返回<code>null</code>。<br><strong>注意：</strong>可能因为元素换行的原因返回的是<code>text</code>节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    var child3 = document.getElementById(&quot;div3&quot;);</div><div class="line">    var next = child3.nextSibling;</div><div class="line">    var previous = child3.previousSibling;</div><div class="line">    console.log(next); // IE下返回div4，其他返回text</div><div class="line">    console.log(previous)  // IE下返回div2，其他返回text</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
</li>
<li><p><code>firstChild</code>返回<code>node</code>的子节点中的第一个节点的引用，没有返回<code>null</code></p>
</li>
<li><p><code>lastChild</code>返回<code>node</code>的子节点中的最后一个节点的引用，没有返回<code>null</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    	var child3 = document.getElementById(&quot;div3&quot;);</div><div class="line">    	var parent = child3.parentNode;</div><div class="line">    	var first = parent.firstChild; // IE是div2，其他是text</div><div class="line">    	var last = parent.lastChild; // IE是div4，其他是text</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>  <strong>注意：</strong>childNodes返回指定元素的子元素集合，包括HTML节点，所有属性，文本节点。可以通过nodeType来判断是哪种类型的节点，只有当nodeType==1时才是元素节点，2是属性节点，3是文本节点。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//获取第一个子元素</div><div class="line">function getFirst(elem)&#123;</div><div class="line">   		for(var i=0,e;e=elem.childNodes[i++];)&#123;</div><div class="line">        	if(e.nodeType==1)</div><div class="line">            	return e;</div><div class="line">    	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="节点元素关系"><a href="#节点元素关系" class="headerlink" title="节点元素关系"></a>节点元素关系</h3><p>以下方法只算元素，不算文本节点。<br>以下三个方法用法和节点关系完全一样，只是这三个方法只看元素节点，不管因为空格、换行造成的文本节点或者手动加上去的文本节点。</p>
<ul>
<li><code>children</code>： 返回所有元素子节点（<code>IE5+、ff3.5、opera3、chrome</code>，但在<code>IE8</code>及以下会将注释节点看成一个元素节点）<br>以下两个<code>IE9+</code>才支持</li>
<li><code>nextElementSibling</code>：返回元素的下一个兄弟元素节点</li>
<li><code>previousElementSibling</code>: 返回元素的上一个兄弟元素节点</li>
</ul>
<h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><ul>
<li><p><code>appendChild()</code>用于向<code>childNodes</code>列表的末尾添加一个节点，并且返回这个新增的节点。<br>如果传入到<code>appendChild()</code>里的节点已经是文档的一部分了，那结果就是将节点从原来的位置转移到新位置，任何一个节点不能同时出现在文档中的多个位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var returnNode = someNode.appendChild(someNode.firstChild); // 返回第一个节点</div><div class="line">    console.log(returnNode === someNode.firstChild); // false</div><div class="line">    console.log(returnNode === someNode.lastChild); // true</div></pre></td></tr></table></figure>
</li>
<li><p><code>insetBefore()</code>可以将节点插入到某个特定的位置。这个方法接受两个参数：要插入的节点和作为参照的节点。<br>插入节点后，被插入的节点变成参照节点的前一个同胞节点，同时被方法返回。 如果参照节点是<code>null</code>，则与</p>
</li>
<li><p><code>appendChild()</code>执行相同的操作。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"> // 插入后成为最后一个子节点</div><div class="line">    var returnNode = someNode.insetBefore(newNode, null);</div><div class="line">    console.log(returnNode === someNode.lastChild); // true</div><div class="line"></div><div class="line">    // 插入后成为第一个子节点</div><div class="line">    var returnNode = someNode.insetBefore(newNode, someNode.firstChild);</div><div class="line">    console.log(returnNode === newNode); // true</div><div class="line">    console.log(returnNode === someNode.firstChild); // true</div><div class="line"></div><div class="line">    // 插入到最后一个子节点的前面</div><div class="line">    var returnNode = someNode.insetBefore(newNode, someNode.lastChild);</div><div class="line">    console.log(returnNode === someNode.childNodes[someNode.childnodes.length - 2]) // true</div></pre></td></tr></table></figure>
</li>
<li><p><code>replaceChild()</code>接受两个参数：要插入的节点和要被替换的节点。被替换的节点将由这个方法返回并从文档中被移除，同时由要插入的节点占据其位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 替换第一个子节点</div><div class="line">    var returnNode = someNode.replaceChild(newNode, someNode.firstChild);</div></pre></td></tr></table></figure>
</li>
<li><p><code>removeChild()</code>该方法移除节点，接受一个参数，即要移除的节点，同时该方法返回被移除的节点。只能是一个节点，不能是一组节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> // 移除第一个子节点</div><div class="line">    var returnNode = someNode.removeChild(someNode.firstChild);</div></pre></td></tr></table></figure>
</li>
<li><p><code>cloneNode(deep)</code>返回调用该方法的节点的一个副本。参数表示是否采用深度克隆,如果为<code>true</code>,则该节点的所有后代节点也都会被克隆,如果为<code>false</code>,则只克隆该节点本身，文本或者换行、空格这些不会复制，因为他们都是一个<code>textNode</code>。<br><code>deep</code>是一个可选参数. 如果省略的话, <code>deep</code>参数的默认值为<code>true</code>,也就是说,深度克隆是默认的.如果想使用浅克隆, 你需要将该参数指定为<code>false</code>。<br>克隆一个元素节点会拷贝它所有的属性以及属性值,当然也就包括了属性上绑定的事件(比如<code>onclick=&quot;alert(1)&quot;</code>),但不会拷贝那些使用<code>addEventListener()</code>方法或者<code>node.onclick = fn</code>这种用<code>JavaScript</code>动态绑定的事件。</p>
</li>
</ul>
<h3 id="元素选择"><a href="#元素选择" class="headerlink" title="元素选择"></a>元素选择</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;div1&quot;&gt;</div><div class="line">        &lt;p id=&quot;div2&quot; class=&quot;one&quot; name=&quot;nameone&quot;&gt;2&lt;/p&gt;</div><div class="line">        &lt;div id=&quot;div3&quot;&gt;3&lt;/div&gt;</div><div class="line">        &lt;div id=&quot;div4&quot; name=&quot;div2&quot;&gt;4&lt;/div&gt;</div><div class="line">    &lt;/div&gt;</div></pre></td></tr></table></figure>
<ul>
<li><code>DOMObject.querySelector</code>返回节点子树内与之相匹配的第一个<code>Element</code>节点。如果没有匹配的节点，则返回<code>null</code>。</li>
<li><p><code>DOMObject.querySelectorAll</code>返回一个包含节点子树内所有与之相匹配的<code>Element</code>节点列表，如果没有相匹配的，则返回一个空节点列表<br>  <strong>注意：</strong>由 <code>querySelector()</code>、<code>querySelectorAll()</code>返回的节点列表不是动态实时的（非<code>live Collection</code>）。这和其他<code>DOM</code>查询方法返回动态实时节点列表不一样。<br>  选择器方法接受一个或多个用逗号分隔的选择器来确定需要被返回的元素。例如，要选择文档中所有<code>CSS</code>的类(<code>class</code>)是<code>warning</code>或者<code>note</code>的段落(<code>p</code>)元素,可以这样写：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var special = document.querySelectorAll( &quot;p.warning, p.note&quot; );</div></pre></td></tr></table></figure>
<p>  也可以通过ID来查询，例如：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var el = document.querySelector( &quot;#main, #basic, #exclamation&quot; );</div></pre></td></tr></table></figure>
<p>  执行上面的代码后，<code>el</code>就包含了文档中元素的<code>ID</code>是<code>main</code>，<code>basic</code>或<code>exclamation</code>的所有元素中的第一个元素。</p>
</li>
<li><code>document.getElementById()</code>也是<strong>非</strong>live collection<br><strong>注意：</strong>getElementById方法只有document对象才有</li>
<li><p><code>DOMObject.getElementsByTagName()</code> 方法返回一个实时的包含具有给出标签名的元素们的<code>HTMLCollection</code>。指定的元素的子树会被搜索，包括元素自己。返回的 <code>list</code> 是实时的（<code>live collection</code>），意味着它会随着<code>DOM</code>树的变化自动更新。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var live = document.getElementsByTagName(&quot;p&quot;);</div><div class="line">    console.log(live[0].innerHTML);</div><div class="line">    document.getElementById(&quot;div1&quot;).removeChild(document.getElementById(&quot;div2&quot;));</div><div class="line">    console.log(live[0].innerHTML);</div><div class="line">    // 第一个输出2，第二个报错，因为无法引用到p标签</div></pre></td></tr></table></figure>
</li>
<li><p><code>document.getElementsByName()</code>该方法返回一个实时的<code>nodelist collection</code>，包含文档中所有<code>name</code>属性匹配的标签。这是一个<strong>live collection</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">    var live = document.getElementsByName(&quot;div2&quot;);</div><div class="line">    console.log(live[0].innerHTML);</div><div class="line">    document.getElementById(&quot;div1&quot;).removeChild(document.getElementById(&quot;div2&quot;));</div><div class="line">    console.log(live[0].innerHTML);</div><div class="line">    // chrome下：全部输出4</div><div class="line">    // IE下： 第一个输出2，第二个报错。</div></pre></td></tr></table></figure>
</li>
<li><p><code>DOMObject.getElementsByClassName()</code>该方法返回一个即时更新的（<code>live</code>） <code>HTMLCollection</code>，包含了所有拥有指定 <code>class</code> 的子元素。当在 <code>document</code> 对象上调用此方法时，会检索整个文档，包括根元素。(<code>IE9</code>以下不支持)<br>要匹配多个<code>class</code>，则<code>className</code>用空格分开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">getElementsByClassName(&quot;class1 class2&quot;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3><ul>
<li><p><code>DOMObject.setAttribute()</code>添加一个新属性（<code>attribute</code>）到元素上，或改变元素上已经存在的属性的值。<br>如果指定的属性已经存在，则其值变为传递的值。如果不存在，则创建指定的属性。也可指定为<code>null</code>。如果设置为<code>null</code>，最好使用<code>removeAttribute()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var div2 = document.getElementById(&quot;div2&quot;);</div><div class="line">    div2.setAttribute(&quot;class&quot;, &quot;new_class&quot;);</div><div class="line">    div2.setAttribute(&quot;id&quot;, &quot;new_id&quot;);</div></pre></td></tr></table></figure>
</li>
<li><p><code>DOMObject.removeAttribute()</code>该方法用于移除元素的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> var div2 = document.getElementById(&quot;div2&quot;);</div><div class="line">    div2.removeAttribute(&quot;class&quot;);</div></pre></td></tr></table></figure>
</li>
<li><p><code>DOMObject.getAttribute()</code>该方法返回元素上指定属性（<code>attribute</code>）的值。如果指定的属性不存在，则返回 <code>null</code> 或 <code>&quot;&quot;</code> （空字符串）（<code>IE5+</code>都返回<code>null</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var div2 = document.getElementById(&quot;div2&quot;);</div><div class="line">    var attr = div2.getAttribute(&quot;class&quot;);</div><div class="line">    console.log(attr);</div></pre></td></tr></table></figure>
</li>
<li><p><code>DOMObject.hasAttribute()</code>返回一个布尔值，指示该元素是否包含有指定的属性（<code>attribute</code>）。</p>
</li>
<li><p>自定义属性<code>data-*</code><br>  <code>html5</code>里有一个<code>data-*</code>去设置获取元素的自定义属性值。</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;div1&quot; data-aa=&quot;11&quot;&gt;</div></pre></td></tr></table></figure>
<p>  利用<code>div1.dataset</code>可以获得一个<code>DOMStringMap</code>，包含了元素的所有<code>data-*</code>。使用<code>div1.dataset.aa</code>就可以获取<code>11</code>的值。同样，通过设置<code>div1.dataset.bb = &quot;22&quot;</code>就可以设置一个自定义属性值。在不兼容的浏览器里，就使用<code>getAttribute</code>和<code>setAttribute</code></p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">	  var div1 = document.getElementById(&quot;div1&quot;);</div><div class="line">	    var a = null;</div><div class="line">	    if (div1.dataset) &#123;</div><div class="line">	        a = div1.dataset.aa;</div><div class="line">	        div1.dataset.bb = &quot;222&quot;;</div><div class="line">	    &#125; else &#123;</div><div class="line">	        a = div1.getAttribute(&quot;data-aa&quot;);</div><div class="line">	        div1.setAttribute(&quot;data-bb&quot;, &quot;2222&quot;);</div><div class="line">	    &#125;</div><div class="line">	    console.log(a);</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="操作文件"><a href="#操作文件" class="headerlink" title="操作文件"></a>操作文件</h2><p>在HTML表单中，可以上传文件的唯一控件就是<code>&lt;input type=&quot;file&quot;&gt;</code>。<br><em>注意</em>：当一个表单包含<code>&lt;input type=&quot;file&quot;&gt;</code>时，表单的<code>enctype</code>必须指定为<code>multipart/form-data</code>，<code>method</code>必须指定为<code>post</code>，浏览器才能正确编码并以<code>multipart/form-data</code>格式发送表单的数据。<br>通常，上传的文件都由后台服务器处理，JavaScript可以在提交表单时对文件扩展名做检查，以便防止用户上传无效格式的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var f = document.getElementById(&apos;test-file-upload&apos;);</div><div class="line">var filename = f.value; // &apos;C:\fakepath\test.png&apos;</div><div class="line">if (!filename || !(filename.endsWith(&apos;.jpg&apos;) || filename.endsWith(&apos;.png&apos;) || filename.endsWith(&apos;.gif&apos;))) &#123;</div><div class="line">    alert(&apos;Can only upload image file.&apos;);</div><div class="line">    return false;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li><p>FileAPI<br>  HTML5的File API提供了<code>File</code>和<code>FileReader</code>两个主要对象，可以获得文件信息并读取文件。<br>  下面的例子演示了如何读取用户选取的图片文件，并在一个<code>&lt;div&gt;</code>中预览图像：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">var</div><div class="line">    fileInput = document.getElementById(&apos;test-image-file&apos;),</div><div class="line">    info = document.getElementById(&apos;test-file-info&apos;),</div><div class="line">    preview = document.getElementById(&apos;test-image-preview&apos;);</div><div class="line">// 监听change事件:</div><div class="line">fileInput.addEventListener(&apos;change&apos;, function () &#123;</div><div class="line">    // 清除背景图片:</div><div class="line">    preview.style.backgroundImage = &apos;&apos;;</div><div class="line">    // 检查文件是否选择:</div><div class="line">    if (!fileInput.value) &#123;</div><div class="line">        info.innerHTML = &apos;没有选择文件&apos;;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    // 获取File引用:</div><div class="line">    var file = fileInput.files[0];</div><div class="line">    // 获取File信息:</div><div class="line">    info.innerHTML = &apos;文件: &apos; + file.name + &apos;&lt;br&gt;&apos; +</div><div class="line">                     &apos;大小: &apos; + file.size + &apos;&lt;br&gt;&apos; +</div><div class="line">                     &apos;修改: &apos; + file.lastModifiedDate;</div><div class="line">    if (file.type !== &apos;image/jpeg&apos; &amp;&amp; file.type !== &apos;image/png&apos; &amp;&amp; file.type !== &apos;image/gif&apos;) &#123;</div><div class="line">        alert(&apos;不是有效的图片文件!&apos;);</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    // 读取文件:</div><div class="line">    var reader = new FileReader();</div><div class="line">    reader.onload = function(e) &#123;</div><div class="line">        var</div><div class="line">            data = e.target.result; // &apos;data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...&apos;            </div><div class="line">        preview.style.backgroundImage = &apos;url(&apos; + data + &apos;)&apos;;</div><div class="line">    &#125;;</div><div class="line">    // 以DataURL的形式读取文件:</div><div class="line">    reader.readAsDataURL(file);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>  上面的代码演示了如何通过HTML5的File API读取文件内容。以DataURL的形式读取到的文件是一个字符串，类似于<code>data:image/jpeg;base64,/9j/4AAQSk...(base64编码)...</code>，常用于设置图像。如果需要服务器端处理，把字符串<code>base64,</code>后面的字符发送给服务器并用Base64解码就可以得到原始文件的二进制内容。</p>
</li>
</ul>
<h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><p>在现代浏览器上写AJAX主要依靠<code>XMLHttpRequest</code>对象，对于低版本的IE，需要换一个<code>ActiveXObject</code>对象，下面的写法能兼容主流浏览器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">function success(text) &#123;</div><div class="line">    var textarea = document.getElementById(&apos;test-ie-response-text&apos;);</div><div class="line">    textarea.value = text;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function fail(code) &#123;</div><div class="line">    var textarea = document.getElementById(&apos;test-ie-response-text&apos;);</div><div class="line">    textarea.value = &apos;Error code: &apos; + code;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var request;</div><div class="line">if (window.XMLHttpRequest) &#123;</div><div class="line">    request = new XMLHttpRequest();</div><div class="line">&#125; else &#123;</div><div class="line">    request = new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">request.onreadystatechange = function () &#123; // 状态发生变化时，函数被回调</div><div class="line">    if (request.readyState === 4) &#123; // 成功完成</div><div class="line">        // 判断响应结果:</div><div class="line">        if (request.status === 200) &#123;</div><div class="line">            // 成功，通过responseText拿到响应的文本:</div><div class="line">            return success(request.responseText);</div><div class="line">        &#125; else &#123;</div><div class="line">            // 失败，根据响应码判断失败原因:</div><div class="line">            return fail(request.status);</div><div class="line">        &#125;</div><div class="line">    &#125; else &#123;</div><div class="line">        // HTTP请求还在继续...</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 发送请求:</div><div class="line">request.open(&apos;GET&apos;, &apos;/api/categories&apos;);</div><div class="line">request.send();</div><div class="line"></div><div class="line">alert(&apos;请求已发送，请等待响应...&apos;);</div></pre></td></tr></table></figure></p>
<p><code>XMLHttpRequest</code>对象的<code>open()</code>方法有3个参数，第一个参数指定是<code>GET</code>还是<code>POST</code>，第二个参数指定URL地址，第三个参数指定是否使用异步，默认是<code>true</code>，所以不用写。<br><em>注意</em>，千万不要把第三个参数指定为<code>false</code>，否则浏览器将停止响应，直到AJAX请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态。<br>最后调用<code>send()</code>方法才真正发送请求。<code>GET</code>请求不需要参数，<code>POST</code>请求需要把body部分以字符串或者<code>FormData</code>对象传进去。</p>
<ul>
<li><p>安全限制(JSONP)<br>  上面代码的URL使用的是相对路径。如果你把它改为<code>&#39;http://www.sina.com.cn/&#39;</code>，再运行，肯定报错。在Chrome的控制台里，还可以看到错误信息。<br>  这是因为浏览器的同源策略导致的。默认情况下，JavaScript在发送AJAX请求时，URL的域名必须和当前页面完全一致。<br>  JS 解决跨域问题的方法–JSONP：<br>  实现原理：凡是拥有”src”这个属性的标签都拥有跨域的能力，比如<code>&lt;script&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;iframe&gt;</code>，可以在script标签内请求服务器，服务器返回函数调用的字符串（数据作为函数的参数），客户端就会把这段字符串作为JS代码执行，由此客户端就能获取服务器端的数据。<br>  示例代码：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">    // 得到航班信息查询结果后的回调函数</div><div class="line">    var flightHandler = function(data)&#123;</div><div class="line">        alert(&apos;你查询的航班结果是：票价 &apos; + data.price + &apos; 元，&apos; + &apos;余票 &apos; + data.tickets + &apos; 张。&apos;);</div><div class="line">    &#125;; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码）</div><div class="line">    var url = &quot;http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler&quot;; // 创建script标签，设置其属性</div><div class="line">    var script = document.createElement(&apos;script&apos;);</div><div class="line">    script.setAttribute(&apos;src&apos;, url); // 把script标签加入head，此时调用开始</div><div class="line"> document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script); </div><div class="line"> &lt;/script&gt;</div></pre></td></tr></table></figure>
<p>   我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flightHandler(&#123; &quot;code&quot;: &quot;CA1998&quot;, &quot;price&quot;: 1780, &quot;tickets&quot;: 5 &#125;);</div></pre></td></tr></table></figure>
<p>  然后页面就会把返回的字符串作为JS代码执行。<br>  <strong>注意：ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加<code>&lt;script&gt;</code>标签来调用服务器提供的js脚本。</strong></p>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[CSS hack解决浏览器兼容性问题]]></title>
      <url>https://heji1993.github.io/2016/08/22/%E5%B8%B8%E7%94%A8CSS%20hack/</url>
      <content type="html"><![CDATA[<p>由于不同的浏览器，甚至同一浏览器的不同版本对CSS的解析认识不一样，导致生成的页面效果不一致，写出针对不同浏览器CSS code就称为CSS hack。</p>
<a id="more"></a>
<h2 id="CSS内部hack"><a href="#CSS内部hack" class="headerlink" title="CSS内部hack"></a>CSS内部hack</h2><hr>
<p>在CSS3中常见一些这样的写法<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/*Mozilla内核浏览器：firefox3.5+*/</div><div class="line"> -moz-transform: rotate | scale | skew | translate ;</div><div class="line">/*Webkit内核浏览器：Safari and Chrome*/</div><div class="line"> -webkit-transform: rotate | scale | skew | translate ;</div><div class="line">/*Opera*/</div><div class="line"> -o-transform: rotate | scale | skew | translate ;</div><div class="line">/*IE9*/</div><div class="line"> -ms-transform: rotate | scale | skew | translate ;</div><div class="line">/*W3C标准*/</div><div class="line"> transform: rotate | scale | skew | translate ;</div></pre></td></tr></table></figure></p>
<p>因为CSS3目前标准还没有统一，各个浏览器都有自己的表现方式，甚至有的实现，有的未实现，在前面加一些前缀以表示支持某个特定浏览器，这也是CSS 内部hack的基本原理，向上面这些简单易懂，但是真正的CSS hack 远远不止于此，因为有不死的IE6及其各种奇葩的兄弟版本。<br>CSS 内部hack 语法是这样的：<code>selector{&lt;hack&gt;?property:value&lt;hack&gt;?;}</code> ，上面代码所示的是在属性名称之前的hack。</p>
<ul>
<li><p>例1：属性前面加个“*”这样的写法只会对IE6、7生效，其它版本IE及现代浏览器会忽略这条指令（没有特殊说明，本文所有hack都是指在声明了DOCTYPE的文档的效果）</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">*<span class="selector-tag">background-color</span><span class="selector-pseudo">:green</span>; <span class="comment">/*仅IE6、7下有效*/</span></div></pre></td></tr></table></figure>
</li>
<li><p>例2：在属性值后面加上<code>\9</code>，在IE下都支持；在属性值后面加上<code>\0</code>，IE8、9、10支持；在属性值后加上<code>\9\0</code>，IE9、10支持</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background-color</span><span class="selector-pseudo">:green</span>\9;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>CSS 内部hack一览<br><img src="index_files/a176bb84-e699-40a6-87fe-91ca5126a8d7.png" alt=""></p>
<h2 id="选择器hack"><a href="#选择器hack" class="headerlink" title="选择器hack"></a>选择器hack</h2><hr>
<p>选择器hanck主要是针对IE浏览器，其实并不怎么常用，语法是这样的：<code>&lt;hack&gt; selector{ sRules }</code><br><img src="index_files/645de664-4e6b-47a8-9250-e22fb60f8214.png" alt=""><br>针对IE9的hack可以这么写<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-pseudo">:root</span> <span class="selector-class">.test</span> &#123; <span class="attribute">background-color</span>:green;&#125;</div></pre></td></tr></table></figure></p>
<h2 id="CSS条件注释-常用"><a href="#CSS条件注释-常用" class="headerlink" title="CSS条件注释(常用)"></a>CSS条件注释(常用)</h2><hr>
<p>HTML头部引用就比较特殊了，类似于程序语句，只能使用在HTML文件里，而不能在CSS文件中使用，并且只有在IE浏览器下才能执行，这个代码在非IE浏览下非单不是执行该条件下的定义，而是当做注释视而不见。<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&lt;!– 默认先调用css.css样式表 –&gt;</div><div class="line">&lt;link rel="stylesheet" type="text/css" href="css.css" /&gt;</div><div class="line">&lt;!–[if IE 7]&gt;</div><div class="line">&lt;!– 如果IE浏览器版是7,调用ie7.css样式表 –&gt;</div><div class="line">&lt;link rel="stylesheet" type="text/css" href="ie7.css" /&gt;</div><div class="line">&lt;![endif]–&gt;</div><div class="line">&lt;!–[if lte IE 6]&gt;</div><div class="line">&lt;!– 如果IE浏览器版本小于等于6,调用ie.css样式表 –&gt;</div><div class="line">&lt;link rel="stylesheet" type="text/css" href="ie.css" /&gt;</div><div class="line">&lt;![endif]–&gt;</div></pre></td></tr></table></figure></p>
<p>lte：就是Less than or equal to的简写，也就是小于或等于的意思。<br>lt ：就是Less than的简写，也就是小于的意思。<br>gte：就是Greater than or equal to的简写，也就是大于或等于的意思。<br>gt ：就是Greater than的简写，也就是大于的意思。<br>! ：就是不等于的意思，跟<a href="http://js8.in/category/front-end/javascript-front-end-2" target="_blank" rel="external">javascript</a>里的不等于判断符相同。</p>
<h2 id="书写顺序"><a href="#书写顺序" class="headerlink" title="书写顺序"></a>书写顺序</h2><hr>
<p>看个例子：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">_<span class="selector-tag">background-color</span><span class="selector-pseudo">:red</span>;</div><div class="line"><span class="selector-tag">background-color</span><span class="selector-pseudo">:green</span>;</div></pre></td></tr></table></figure></p>
<p>如果希望DIV在IE6上是红色，其它是绿色，上面的写法可不可以呢？试一下发现所有浏览器上都是绿色，因为在IE6解析的时候，第一句能够识别，背景设为红色，但是第二句所有浏览器都识别，IE6也不例外，背景颜色又被设为绿色，所以得反过来写<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background-color</span><span class="selector-pseudo">:green</span>;</div><div class="line">_<span class="selector-tag">background-color</span><span class="selector-pseudo">:red</span>;</div></pre></td></tr></table></figure></p>
<p>总结出的规律就是：先一般，再特殊。有兴趣的同学可以试试试试下面CSS，看看和你想的效果是否一样：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background-color</span><span class="selector-pseudo">:blue</span>; <span class="comment">/*所有浏览器*/</span></div><div class="line"><span class="selector-tag">background-color</span><span class="selector-pseudo">:red</span>\9;<span class="comment">/*所有的ie*/</span> </div><div class="line"><span class="selector-tag">background-color</span><span class="selector-pseudo">:yellow</span>\0; <span class="comment">/* ie8+*/</span> </div><div class="line">+<span class="selector-tag">background-color</span><span class="selector-pseudo">:pink</span>; <span class="comment">/*+ ie7*/</span></div></pre></td></tr></table></figure></p>
<p><strong>Ps:CSS hack的写法在迫不得已的情况下才考虑使用</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Oracle常用知识点]]></title>
      <url>https://heji1993.github.io/2016/08/19/Oracle%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      <content type="html"><![CDATA[<p>oracle常用易忘知识点<br><a id="more"></a></p>
<h2 id="使用sqlplus连接远程数据库"><a href="#使用sqlplus连接远程数据库" class="headerlink" title="使用sqlplus连接远程数据库"></a>使用sqlplus连接远程数据库</h2><hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sqlplus U_HJYJ_ZJ/U_HJYJ_ZJ@192.168.40.40:1521/hjyj</div></pre></td></tr></table></figure>
<h2 id="使用PL-SQL-Developer连接数据库"><a href="#使用PL-SQL-Developer连接数据库" class="headerlink" title="使用PL/SQL Developer连接数据库"></a>使用PL/SQL Developer连接数据库</h2><hr>
<p>1、安装Oracle<br>2、解压PL/SQL Developer中文绿化版<br>3、解压32位Oracle客户端(即instantclient_11_2)，覆盖PL/SQL Developer中的同名文件夹。然后在instantclient_11_2下创建NETWORK/ADMIN/。拷贝tnsnames.ora到该路径下<br>4、启动plsqlDev 。首选项–&gt;选择OCI库为PL/SQL Developer中客户端的OCI库–&gt;重启plsqlDev<br><strong>tnsnames.ora</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">LocalName =</div><div class="line">  (DESCRIPTION =</div><div class="line">    (ADDRESS_LIST =</div><div class="line">      (ADDRESS = (PROTOCOL = TCP)(HOST = 127.0.0.1)(PORT = 1521))</div><div class="line">    )</div><div class="line">    (CONNECT_DATA =</div><div class="line">      (SERVICE_NAME = orcl)</div><div class="line">    )</div><div class="line">  )</div><div class="line">#LOCALNAME: 本地名称</div><div class="line">#ADDRESS: 服务器地址</div><div class="line">#PROTOCOL: 使用协议</div><div class="line">#HOST: IP地址</div><div class="line">#PORT: 监听端口</div><div class="line">#SERVICE_NAME: 数据库服务名称</div></pre></td></tr></table></figure></p>
<p><b style="color:red;">PL/SQL Developer乱码问题：设置一个名为NLS_LANG的系统环境变量，设置其值为“SIMPLIFIED CHINESE_CHINA.ZHS16GBK”，然后重新启动 pl/sql developer</b></p>
<h2 id="为字段添加注释"><a href="#为字段添加注释" class="headerlink" title="为字段添加注释"></a>为字段添加注释</h2><hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> T_HJYJ_YJCZ_JJXX  <span class="keyword">ADD</span> (SSZYRS <span class="built_in">NUMBER</span>(<span class="number">16</span>),JJSS <span class="built_in">NUMBER</span>(<span class="number">16</span>),STGN <span class="keyword">NVARCHAR2</span>(<span class="number">200</span>),GJZDBHWZ <span class="keyword">NVARCHAR2</span>(<span class="number">200</span>));</div><div class="line">//添加注释</div><div class="line">COMMENT ON COLUMN T_HJYJ_YJCZ_JJXX.SSZYRS IS  '疏散转移人数';</div><div class="line">COMMENT ON COLUMN T_HJYJ_YJCZ_JJXX.JJSS IS  '经济损失';</div><div class="line">COMMENT ON COLUMN T_HJYJ_YJCZ_JJXX.STGN IS  '生态功能';</div><div class="line">COMMENT ON COLUMN T_HJYJ_YJCZ_JJXX.GJZDBHWZ IS  '国家重点保护物种';</div></pre></td></tr></table></figure>
<h2 id="从dmp导入数据库"><a href="#从dmp导入数据库" class="headerlink" title="从dmp导入数据库"></a>从dmp导入数据库</h2><hr>
<p>1、删除原有用户及其下所有表<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">drop</span> <span class="keyword">user</span> user_name <span class="keyword">cascade</span>;</div></pre></td></tr></table></figure></p>
<p>2、按照要导入的数据库创建用户及表空间<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLESPACE</span> TBS_HJYJ_ZJ <span class="keyword">DATAFILE</span> <span class="string">'U_HJYJ_ZJ'</span> <span class="keyword">SIZE</span> <span class="number">500</span>m <span class="keyword">AUTOEXTEND</span> <span class="keyword">ON</span>;</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> U_HJYJ_ZJ <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> U_HJYJ_ZJ <span class="keyword">DEFAULT</span> <span class="keyword">TABLESPACE</span> TBS_HJYJ_ZJ;</div><div class="line"><span class="keyword">GRANT</span> DBA <span class="keyword">TO</span> U_HJYJ_ZJ</div></pre></td></tr></table></figure></p>
<p>3、在命令提示符输入imp 用户名/密码@ip:端口号/orcl  full=y file=F:\U_HJYJ_ZJ.dmp ignore=y</p>
<h2 id="导出数据库到dmp文件"><a href="#导出数据库到dmp文件" class="headerlink" title="导出数据库到dmp文件"></a>导出数据库到dmp文件</h2><hr>
<p>exp 用户名/密码@192.168.40.40:1521/hjyj [owner=用户名] file=f:\U_HJYJ_ZJ.dmp [full=y]<br><strong>注意:如果想要连空表也导出,需要执行sql:</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="string">'alter table '</span> || TABLE_NAME || <span class="string">' allocate extent;'</span> <span class="keyword">FROM</span> USER_TABLES <span class="keyword">WHERE</span> NUM_ROWS = <span class="number">0</span></div></pre></td></tr></table></figure></p>
<h2 id="union和union-all"><a href="#union和union-all" class="headerlink" title="union和union all"></a>union和union all</h2><hr>
<p>UNION 指令的目的是将两个 SQL 语句的结果合并起来,可以查看你要的查询结果，例如union和union all的区别<br>union all效率更高，但是不会自动去除重复数据。union效率相对较低，但是能去除重复数据</p>
<h2 id="oracle创建视图"><a href="#oracle创建视图" class="headerlink" title="oracle创建视图"></a>oracle创建视图</h2><hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">create</span> <span class="keyword">or</span> <span class="keyword">replace</span> <span class="keyword">view</span> dept_sum_vw <span class="keyword">as</span> <span class="keyword">select</span> d.dname <span class="keyword">name</span>,<span class="keyword">min</span>(e.sal) minsal,<span class="keyword">max</span>(e.sal) maxsal,<span class="keyword">avg</span>(e.sal) avgsal <span class="keyword">from</span> emp e,dept d <span class="keyword">where</span> e.deptno = d.deptno <span class="keyword">group</span> <span class="keyword">by</span> d.dname</div></pre></td></tr></table></figure>
<h2 id="添加、删除、修改字段"><a href="#添加、删除、修改字段" class="headerlink" title="添加、删除、修改字段"></a>添加、删除、修改字段</h2><hr>
<p>添加字段的语法：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename <span class="keyword">add</span> (<span class="keyword">column</span> datatype [<span class="keyword">default</span> <span class="keyword">value</span>][<span class="literal">null</span>/<span class="keyword">not</span> <span class="literal">null</span>],….);</div></pre></td></tr></table></figure></p>
<p>修改字段的语法：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename <span class="keyword">modify</span> (<span class="keyword">column</span> datatype [<span class="keyword">default</span> <span class="keyword">value</span>][<span class="literal">null</span>/<span class="keyword">not</span> <span class="literal">null</span>],….);</div></pre></td></tr></table></figure></p>
<p>删除字段的语法：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tablename <span class="keyword">drop</span> (<span class="keyword">column</span>);</div></pre></td></tr></table></figure></p>
<p>添加、修改、删除多列的话，用逗号隔开。</p>
<h2 id="从Excel导入数据到oracle"><a href="#从Excel导入数据到oracle" class="headerlink" title="从Excel导入数据到oracle"></a>从Excel导入数据到oracle</h2><hr>
<h4 id="CSV格式文件导入"><a href="#CSV格式文件导入" class="headerlink" title="CSV格式文件导入"></a>CSV格式文件导入</h4><p>1、创建sql*loader控制文件**.ctl<br><img src="index_files/clipboard.png" alt=""><br>2、在命令行输入命令<br><img src="index_files/2cb67420-47b9-4578-8d44-495c3fa45fb8.png" alt=""><br>system/manager改为对应的用户名/密码</p>
<h4 id="Excel格式导入"><a href="#Excel格式导入" class="headerlink" title="Excel格式导入"></a>Excel格式导入</h4><p>1、工具–&gt;ODBC导入器<br>2、选择Excel文件<br><img src="index_files/fcf88952-2961-4d28-bd4b-be1b20eb3a90.png" alt=""><br>3、选择要导入的表<br><img src="index_files/bd92eca3-3c62-4acf-9836-93ddf1ebd08c.png" alt=""><br>4、导入</p>
<h2 id="oracle函数"><a href="#oracle函数" class="headerlink" title="oracle函数"></a>oracle函数</h2><hr>
<h3 id="decode函数"><a href="#decode函数" class="headerlink" title="decode函数"></a>decode函数</h3><p>语法：<code>decode(条件,值1,返回值1,值2,返回值2,...值n,返回值n,缺省值)</code> 例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">decode</span>(SEX,<span class="string">'女'</span>,<span class="number">1</span>,<span class="string">'男'</span>,<span class="number">0</span>） sex  <span class="keyword">from</span> T_PERSON</div></pre></td></tr></table></figure></p>
<h3 id="case-when函数"><a href="#case-when函数" class="headerlink" title="case when函数"></a>case when函数</h3><p>语法：<code>CASE WHEN 条件 THEN 操作 WHEN 条件2 THEN 操作2 ELSE 操作3 END</code>，例如：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span>   grade, <span class="keyword">COUNT</span> (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex =<span class="number">1</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span>) 男生数,</div><div class="line">                <span class="keyword">COUNT</span> (<span class="keyword">CASE</span> <span class="keyword">WHEN</span> sex =<span class="number">2</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="literal">NULL</span> <span class="keyword">END</span>) 女生数</div><div class="line">                <span class="keyword">FROM</span> students GROUPBY grade;</div></pre></td></tr></table></figure></p>
<h3 id="replace函数"><a href="#replace函数" class="headerlink" title="replace函数"></a>replace函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span>  T_ADMIN_RMS_CD t <span class="keyword">SET</span> BZ = <span class="keyword">REPLACE</span>((<span class="keyword">SELECT</span> BZ <span class="keyword">FROM</span> T_ADMIN_RMS_CD <span class="keyword">WHERE</span> SSXT = <span class="string">'2013101017042563d7662ffd17471eb2fdb8956d7bed48'</span>),<span class="string">'10.33.106.51:8010'</span>,<span class="string">'服务器ip:端口号'</span>) <span class="keyword">WHERE</span> SSXT = <span class="string">'2013101017042563d7662ffd17471eb2fdb8956d7bed48'</span></div></pre></td></tr></table></figure>
<h3 id="substring函数"><a href="#substring函数" class="headerlink" title="substring函数"></a>substring函数</h3><p>语法：<code>substring(string,pos,len)</code><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> T_HJYJ_FXY_JBXX a <span class="keyword">SET</span> a.SHENG = (<span class="keyword">SELECT</span> <span class="keyword">SUBSTR</span>(SHENG,<span class="number">0</span>,<span class="number">2</span>) <span class="keyword">FROM</span> T_HJYJ_FXY_JBXX b <span class="keyword">WHERE</span> b.XH = a.XH)</div></pre></td></tr></table></figure></p>
<h3 id="截取字符串"><a href="#截取字符串" class="headerlink" title="截取字符串"></a>截取字符串</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">UPDATE</span> T_HJYJ_JC_WRYJBXX JBXX <span class="keyword">SET</span> JBXX.LATITUDE = (</div><div class="line">       <span class="keyword">SELECT</span> JDD+JDF/<span class="number">60</span>+JDM/<span class="number">3600</span> <span class="keyword">FROM</span> (</div><div class="line">              <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (</div><div class="line">                <span class="keyword">SELECT</span> INNER_ENT_ID, </div><div class="line">                       <span class="keyword">SUBSTR</span>(LATITUDE, <span class="number">0</span>, <span class="keyword">INSTR</span>(LATITUDE, <span class="string">'.'</span>, <span class="number">1</span>, <span class="number">1</span>) - <span class="number">1</span>) <span class="keyword">AS</span> JDD,</div><div class="line">                       <span class="keyword">SUBSTR</span>(LATITUDE,</div><div class="line">                               <span class="keyword">INSTR</span>(LATITUDE, <span class="string">'.'</span>, <span class="number">1</span>, <span class="number">1</span>) + <span class="number">1</span>,</div><div class="line">                               <span class="keyword">INSTR</span>(LATITUDE, <span class="string">'.'</span>, <span class="number">1</span>, <span class="number">2</span>) - <span class="keyword">INSTR</span>(LATITUDE, <span class="string">'.'</span>, <span class="number">1</span>, <span class="number">1</span>) - <span class="number">1</span>) <span class="keyword">AS</span> JDF,</div><div class="line">                       <span class="keyword">SUBSTR</span>(LATITUDE,</div><div class="line">                               <span class="keyword">INSTR</span>(LATITUDE, <span class="string">'.'</span>, <span class="number">1</span>, <span class="number">2</span>) + <span class="number">1</span>,</div><div class="line">                               <span class="keyword">LENGTH</span>(LATITUDE) - <span class="number">1</span>)  <span class="keyword">AS</span> JDM,</div><div class="line">                       LATITUDE</div><div class="line">                  <span class="keyword">FROM</span> T_HJYJ_JC_WRYJBXX </div><div class="line">                  ) TMP  <span class="keyword">WHERE</span> TMP.JDD <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">AND</span> TMP.JDF <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">AND</span> TMP.JDM <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></div><div class="line">       ) <span class="keyword">WHERE</span> INNER_ENT_ID = JBXX.INNER_ENT_ID</div><div class="line">)</div></pre></td></tr></table></figure>
<h2 id="进行查询并更新操作"><a href="#进行查询并更新操作" class="headerlink" title="进行查询并更新操作"></a>进行查询并更新操作</h2><hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> T_ADMIN_RMS_YH <span class="keyword">WHERE</span> YHID = <span class="string">'nbsshy'</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></div></pre></td></tr></table></figure>
<h2 id="查询用户表空间"><a href="#查询用户表空间" class="headerlink" title="查询用户表空间"></a>查询用户表空间</h2><hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> username,default_tablespace <span class="keyword">from</span> user_users;</div></pre></td></tr></table></figure>
<h2 id="向一张表导入另一张表的部分数据"><a href="#向一张表导入另一张表的部分数据" class="headerlink" title="向一张表导入另一张表的部分数据"></a>向一张表导入另一张表的部分数据</h2><hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> T_HJYJ_FXY_FXYML_BAK(XH,FXYXH,FXYMC,NF,CZBM,FLAG,SFYX,ITEM1,ITEM2,ITEM3,ITEM4,ITEM5,BZ,ORGID,CJR,CJSJ,XGR,XGSJ,JDJCSJ,SHENG,SHI,QX,CZR,CZSJ,CZ) <span class="keyword">select</span> t.*,<span class="string">'hj'</span> <span class="keyword">AS</span> CZR,<span class="keyword">SYSDATE</span> <span class="keyword">AS</span> CZSJ,<span class="string">'sz'</span> <span class="keyword">AS</span> CZ <span class="keyword">from</span> T_HJYJ_FXY_FXYML t <span class="keyword">WHERE</span> XH = <span class="string">'1'</span></div></pre></td></tr></table></figure>
<h2 id="查询数据表中重复的数据-以DMNR字段判断是否重复"><a href="#查询数据表中重复的数据-以DMNR字段判断是否重复" class="headerlink" title="查询数据表中重复的数据(以DMNR字段判断是否重复)"></a>查询数据表中重复的数据(以DMNR字段判断是否重复)</h2><hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> GGDMZ.DMNR,<span class="keyword">COUNT</span>(<span class="number">1</span>) <span class="keyword">FROM</span> T_COMN_GGDMZ GGDMZ <span class="keyword">WHERE</span> GGDMZ.DMJBH = <span class="string">'HJKQHFQ'</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span> GGDMZ.DMNR <span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(<span class="number">1</span>)&gt;<span class="number">1</span></div></pre></td></tr></table></figure>
<h2 id="oracle中修改类型为clob"><a href="#oracle中修改类型为clob" class="headerlink" title="oracle中修改类型为clob"></a>oracle中修改类型为clob</h2><hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> T_COMN_VIEW <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> STNR;</div><div class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> T_COMN_VIEW <span class="keyword">ADD</span>  STNR <span class="keyword">CLOB</span>;COMMENT ON COLUMN  T_COMN_VIEW.STNR IS '视图内容'</div></pre></td></tr></table></figure>
<h2 id="sqlplus需要执行commit命令才能提交事务。"><a href="#sqlplus需要执行commit命令才能提交事务。" class="headerlink" title="sqlplus需要执行commit命令才能提交事务。"></a>sqlplus需要执行commit命令才能提交事务。</h2><hr>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">delete</span> <span class="keyword">from</span> T_COMN_XZQHDM;</div><div class="line"><span class="keyword">commit</span>;</div></pre></td></tr></table></figure>
<h2 id="ORACLE导出空表需要先执行的语句"><a href="#ORACLE导出空表需要先执行的语句" class="headerlink" title="ORACLE导出空表需要先执行的语句"></a>ORACLE导出空表需要先执行的语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="string">'alter table '</span> || TABLE_NAME || <span class="string">' allocate extent;'</span> <span class="keyword">FROM</span> USER_TABLES <span class="keyword">WHERE</span> NUM_ROWS = <span class="number">0</span></div></pre></td></tr></table></figure>
<h2 id="Oracle关于连接数的问题"><a href="#Oracle关于连接数的问题" class="headerlink" title="Oracle关于连接数的问题"></a>Oracle关于连接数的问题</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> v$process <span class="comment">--当前的数据库连接数</span></div><div class="line"><span class="keyword">select</span> <span class="keyword">value</span> <span class="keyword">from</span> v$parameter <span class="keyword">where</span> <span class="keyword">name</span> =<span class="string">'processes'</span><span class="comment">--数据库允许的最大连接数</span></div><div class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> processes = <span class="number">300</span> <span class="keyword">scope</span> = <span class="keyword">spfile</span>;<span class="comment">--修改最大连接数:</span></div></pre></td></tr></table></figure>
<h2 id="高速泵导入导出"><a href="#高速泵导入导出" class="headerlink" title="高速泵导入导出"></a>高速泵导入导出</h2><hr>
<ul>
<li>高速导入导出(<code>E:\Database\XZCF</code>目录是DMP文件存放位置/导出位置)<br><code>create or replace directory exp_dir as &#39;E:\Database\XZCF&#39;;--PL/SQL中执行</code></li>
<li>授权目录相关用户<br><code>grant read,write on directory exp_dir to public;--PL/SQL中执行</code></li>
<li>查询地址<br><code>select * from dba_directories;</code></li>
<li>执行导出(在CMD中执行)<br><code>expdp U_WSYS/U_WSYS@TEST directory=exp_dir dumpfile=WRJPGZ20140703.DMP logfile=WRJPGZ_20140703.log;</code></li>
<li>执行导入(在CMD中执行)<br><code>impdp U_WSYS/U_WSYS@ORCL directory=exp_dir dumpfile=U_WSYSS.DMP logfile=U_WSYSS.log;</code><h2 id="oracle时间查询相关"><a href="#oracle时间查询相关" class="headerlink" title="oracle时间查询相关"></a>oracle时间查询相关</h2></li>
</ul>
<hr>
<p>当前月份所有日期<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> TRUNC(<span class="keyword">SYSDATE</span>, <span class="string">'MM'</span>) + <span class="keyword">ROWNUM</span> - <span class="number">1</span> <span class="keyword">AS</span> MONTHDAY <span class="keyword">FROM</span> DUAL</div><div class="line">     <span class="keyword">CONNECT</span> <span class="keyword">BY</span> <span class="keyword">ROWNUM</span> &lt;= TO_NUMBER(TO_CHAR(<span class="keyword">LAST_DAY</span>(<span class="keyword">SYSDATE</span>), <span class="string">'dd'</span>))</div></pre></td></tr></table></figure></p>
<p>查询上季度所有月份<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> TO_CHAR(ADD_MONTHS(ADD_MONTHS(TRUNC(<span class="keyword">SYSDATE</span>, <span class="string">'YYYY'</span>),A * <span class="number">3</span>),-<span class="keyword">ROWNUM</span>),<span class="string">'YYYYMM'</span>)  LAST_Q  </div><div class="line">    <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> TO_CHAR(<span class="keyword">SYSDATE</span>,<span class="string">'Q'</span>)<span class="number">-1</span> A <span class="keyword">FROM</span> DUAL)  </div><div class="line">    <span class="keyword">CONNECT</span> <span class="keyword">BY</span> <span class="keyword">ROWNUM</span> &lt;= <span class="number">3</span>  </div><div class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">1</span>; </div><div class="line">``` </div><div class="line">查询当前季度所有月份</div><div class="line">```sql</div><div class="line"><span class="keyword">SELECT</span> TO_CHAR(ADD_MONTHS(ADD_MONTHS(TRUNC(<span class="keyword">SYSDATE</span>, <span class="string">'YYYY'</span>),A * <span class="number">3</span>),-<span class="keyword">ROWNUM</span>),<span class="string">'YYYYMM'</span>)  LAST_Q  </div><div class="line">    <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> TO_CHAR(<span class="keyword">SYSDATE</span>,<span class="string">'Q'</span>) A <span class="keyword">FROM</span> DUAL)  </div><div class="line">    <span class="keyword">CONNECT</span> <span class="keyword">BY</span> <span class="keyword">ROWNUM</span> &lt;= <span class="number">3</span>  </div><div class="line">    <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="number">1</span>;</div></pre></td></tr></table></figure></p>
<p>构造一年12个月<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> to_char(<span class="keyword">to_date</span>(<span class="string">'201106'</span>,<span class="string">'yyyymm'</span>),<span class="string">'yyyy'</span>) || <span class="keyword">LPAD</span>(<span class="keyword">LEVEL</span>,<span class="number">2</span>,<span class="number">0</span>)</div><div class="line"><span class="keyword">FROM</span> dual</div><div class="line"><span class="keyword">CONNECT</span> <span class="keyword">BY</span> <span class="keyword">LEVEL</span>&lt;<span class="number">13</span></div></pre></td></tr></table></figure></p>
<h2 id="Oracle根据汉字返回拼音的包"><a href="#Oracle根据汉字返回拼音的包" class="headerlink" title="Oracle根据汉字返回拼音的包"></a>Oracle根据汉字返回拼音的包</h2><hr>
<p><strong>由于篇幅过大，这里不贴代码。</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用Hexo搭建博客]]></title>
      <url>https://heji1993.github.io/2016/08/17/%E4%BD%BF%E7%94%A8Hexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><hr>
<ul>
<li>安装<a href="http://nodejs.org/" title="NodeJS" target="_blank" rel="external">NodeJS</a></li>
<li>安装<a href="https://git-scm.com/" title="Git" target="_blank" rel="external">Git</a></li>
<li>安装Hexo<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="新建博客"><a href="#新建博客" class="headerlink" title="新建博客"></a>新建博客</h2><hr>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">hexo init myB<span class="built_in">log</span></div><div class="line"><span class="built_in">cd</span>  myB<span class="built_in">log</span></div><div class="line">npm install</div><div class="line">hexo g <span class="comment"># 或者hexo generate</span></div><div class="line">hexo s <span class="comment"># 或者hexo server，可以在http://localhost:4000/ 查看</span></div></pre></td></tr></table></figure>
<p>这里有必要提下Hexo常用的几个命令：<br><code>hexo generate (hexo g)</code> 生成静态文件，会在当前目录下生成一个新的叫做public的文件夹<br><code>hexo server (hexo s)</code> 启动本地web服务，用于博客的预览<br><code>hexo deploy (hexo d)</code>部署播客到远端（比如github, heroku等平台）<br><code>hexo new &quot;postName&quot;</code>#新建文章<br>现在我们打开<code>http://localhost:4000/</code> 已经可以看到一篇内置的blog了。</p>
<h2 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h2><hr>
<p>这里以主题yilia为例进行说明(以下命令在博客目录执行)。</p>
<ul>
<li><p>安装主题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ hexo clean</div><div class="line">$ git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia</div></pre></td></tr></table></figure>
</li>
<li><p>启用主题<br>修改Hexo目录下的_config.yml配置文件中的theme属性，将其设置为yilia。</p>
</li>
<li>更新主题<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cd themes/yilia</div><div class="line">$ git pull</div><div class="line">$ hexo g # 生成</div><div class="line">$ hexo s # 启动本地web服务器</div></pre></td></tr></table></figure>
</li>
</ul>
<p>现在打开<code>http://localhost:4000/</code> ，会看到我们已经应用了一个新的主题。</p>
<h2 id="部署博客到Github-Pages"><a href="#部署博客到Github-Pages" class="headerlink" title="部署博客到Github Pages"></a>部署博客到Github Pages</h2><hr>
<p><a href="https://pages.github.com/" title="Github Pages" target="_blank" rel="external">Github Pages</a>本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。<br>每个帐号只能有一个仓库来存放个人主页，而且仓库的名字必须是username/username.github.io，这是特殊的命名约定。你可以通过<code>http://username.github.io</code> 来访问你的个人主页。<br><strong>注意：个人主页的网站内容是在master分支下的。</strong></p>
<h4 id="创建自己的Github-Pages"><a href="#创建自己的Github-Pages" class="headerlink" title="创建自己的Github Pages"></a>创建自己的Github Pages</h4><ul>
<li>创建github仓库，注意命名</li>
<li>在settings开启github pages</li>
<li>现在可以通过<code>http://username.github.io</code>访问github主页</li>
</ul>
<h4 id="部署Hexo到Github-Pages"><a href="#部署Hexo到Github-Pages" class="headerlink" title="部署Hexo到Github Pages"></a>部署Hexo到Github Pages</h4><p>这一步恐怕是最关键的一步了，让我们把在本地web环境下预览到的博客部署到github上，然后就可以直接通过<code>http://heji1993.github.io/</code>访问了。不过很多教程文章对这个步骤语焉不详，这里着重说下。<br>首先需要明白所谓部署到github的原理。<br>1、之前步骤中在Github上创建的那个特别的repo（heji1993.github.io）一个最大的特点就是其master中的html静态文件，可以通过链接<code>http://heji1993.github.io</code>来直接访问。<br>2、Hexo -g 会生成一个静态网站（第一次会生成一个public目录），这个静态文件可以直接访问。<br>3、需要将hexo生成的静态网站，提交(git commit)到github上。<br><strong>注意：部署到github需要配置SSH key，请参考github学习笔记</strong></p>
<ul>
<li><p><strong>使用hexo deploy部署</strong><br>  hexo deploy可以部署到很多平台，具体可以参考<a href="https://hexo.io/docs/deployment.html" title="部署指南" target="_blank" rel="external"> 这个链接 </a>. 如果部署到github，需要在配置文件_config.xml中作如下修改：</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">   type: git</div><div class="line">   repo: git@github.com:heji1993/heji1993.github.io.git</div><div class="line">   branch: master</div></pre></td></tr></table></figure>
<p>  然后在命令行中执行</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">hexo d</div></pre></td></tr></table></figure>
<p>  即可完成部署。<br>  注意需要提前安装一个扩展：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure>
</li>
<li><p><strong>使用git命令行部署</strong><br>  克隆github仓库</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> e:/myB<span class="built_in">log</span></div><div class="line">$ git <span class="built_in">clone</span> https://github.com/heji1993/heji1993.github.io.git .deploy/heji1993.github.io</div></pre></td></tr></table></figure>
<p>  创建一个deploy脚本文件</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">hexo generate</div><div class="line">cp -R public/* .deploy/heji1993.github.io</div><div class="line"><span class="built_in">cd</span> .deploy/heji1993.github.io</div><div class="line">git add .</div><div class="line">git commit -m “update”</div><div class="line">git push origin master</div></pre></td></tr></table></figure>
<p>  需要部署的时候，执行这段脚本就可以了（比如可以将其保存为deploy.sh）。执行过程中可能需要让你输入Github账户的用户名及密码，按照提示操作即可。</p>
</li>
</ul>
<h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><hr>
<p>新建markdown文件，放在<code>source\_posts</code>目录下，当执行<code>hexo g</code>命令时，会生成public目录并把markdown文件转换为HTML文件放入其中用于发布站点。markdown文件头需要包含以下信息：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">---</div><div class="line">title: Gulp</div><div class="line">categories: Web前端</div><div class="line">tags: [Gulp,自动化]</div><div class="line">---</div></pre></td></tr></table></figure></p>
<h3 id="NexT主题的使用"><a href="#NexT主题的使用" class="headerlink" title="NexT主题的使用"></a>NexT主题的使用</h3><hr>
<p><strong> 在 Hexo 中有两份主要的配置文件，其名称都是<code>_config.yml</code>。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。 为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 </strong></p>
<ul>
<li><p>下载主题</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"> $ <span class="built_in">cd</span> your-hexo-site</div><div class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</div></pre></td></tr></table></figure>
</li>
<li><p>启用主题、验证主题<br>  与所有 Hexo 主题启用的模式一样。 当 克隆/下载 完成后，打开<code>_config.xml</code>， 找到 <code>theme</code> 字段，并将其值更改为 <code>next</code>。</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">theme: next</div></pre></td></tr></table></figure>
<p>  运行以下命令：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean </div><div class="line">hexo g</div><div class="line">hexo d</div></pre></td></tr></table></figure>
<p>  打开博客首页查看效果</p>
</li>
</ul>
<h4 id="自定义设置-修改主题配置文件"><a href="#自定义设置-修改主题配置文件" class="headerlink" title="自定义设置(修改主题配置文件)"></a>自定义设置(修改主题配置文件)</h4><ul>
<li>选择 Scheme（不同的外观）</li>
<li><p>设置语言<br>编辑 站点配置文件， 将 <code>language</code> 设置成你所需要的语言。建议明确设置你所需要的语言，例如选用简体中文，配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">language: zh-Hans</div></pre></td></tr></table></figure>
</li>
<li><p>设置菜单<br>1、设置菜单内容</p>
   <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">          home: /</div><div class="line">        archives: /archives</div><div class="line">        #about: /about</div><div class="line">         #categories: /categories</div><div class="line">         tags: /tags</div><div class="line">         #commonweal: /404.html</div></pre></td></tr></table></figure>
<p>2、 以简体中文为例，若你需要添加一个菜单项，比如 something。那么就需要修改简体中文对应的翻译文件 <code>languages/zh-Hans.yml</code>，在 menu 字段下添加一项：</p>
   <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">     home: 首页</div><div class="line">      archives: 归档</div><div class="line">      categories: 分类</div><div class="line">      tags: 标签</div><div class="line">     about: 关于</div><div class="line">     search: 搜索</div><div class="line">     commonweal: 公益404</div><div class="line">     something: 有料</div></pre></td></tr></table></figure>
<p>3、 设定菜单项的图标，对应的字段是 menu_icons。 此设定格式是 item name: icon name，其中 item name 与上一步所配置的菜单名字对应，icon name 是 Font Awesome 图标的 名字。而 enable 可用于控制是否显示图标，你可以设置成 false 来去掉图标。</p>
   <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">menu_icons:</div><div class="line">      enable: true</div><div class="line">       # Icon Mapping.</div><div class="line">      home: home</div><div class="line">      about: user</div><div class="line">       categories: th</div><div class="line">       tags: tags</div><div class="line">      archives: archive</div><div class="line">      commonweal: heartbeat</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>设置RSS<br>  NexT 中 RSS 有三个设置选项，满足特定的使用场景。 更改 <code>主题配置文件</code>，设定 rss 字段的值：<ul>
<li><code>false</code>：禁用RSS，不在页面上显示RSS连接</li>
<li>留空：使用hexo生成的Feed标签。你需要先安装<a href="https://github.com/hexojs/hexo-generator-feed" title="hexo-generator-feed " target="_blank" rel="external">hexo-generator-feed </a>插件</li>
<li>具体的链接地址：适用于已经烧制过 Feed 的情形。</li>
</ul>
</li>
</ul>
<ul>
<li><p>添加<code>标签</code>页面<br>  1、在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 tags ：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> your-hexo-site</div><div class="line">$ hexo new page tags</div></pre></td></tr></table></figure>
<p>  2、编辑刚新建的页面，将页面的类型设置为 tags ，主题将自动为这个页面显示标签云。页面内容如下：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">title: 标签</div><div class="line">date: 2014-12-22 12:39:04</div><div class="line"><span class="built_in">type</span>: <span class="string">"tags"</span></div><div class="line">---</div></pre></td></tr></table></figure>
<p>  3、在菜单中添加链接。编辑 <code>主题配置文件</code> ， 添加 tags 到 menu 中，如下:</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">   home: /</div><div class="line">   archives: /archives</div><div class="line">   tags: /tags</div></pre></td></tr></table></figure>
</li>
<li><p>添加<code>分类</code>页面<br>  1、在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 categories ：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ <span class="built_in">cd</span> your-hexo-site</div><div class="line">$ hexo new page categories</div></pre></td></tr></table></figure>
<p>  2、编辑刚新建的页面，将页面的类型设置为 categories ，主题将自动为这个页面显示分类。页面内容如下：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">title: 标签</div><div class="line">date: 2014-12-22 12:39:04</div><div class="line"><span class="built_in">type</span>: <span class="string">"categories"</span></div><div class="line">---</div></pre></td></tr></table></figure>
<p>  3、在菜单中添加链接。编辑 <code>主题配置文件</code> ， 添加 categories 到 menu 中，如下:</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">menu:</div><div class="line">   home: /</div><div class="line">   archives: /archives</div><div class="line">   categories : /categories</div></pre></td></tr></table></figure>
</li>
<li><p>设置代码高亮</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"># Code Highlight theme</div><div class="line"># Available value: normal | night | night eighties | night blue | night bright</div><div class="line"># https://github.com/chriskempson/tomorrow-theme</div><div class="line">highlight_theme: normal</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>设置侧栏<br>默认情况下，侧栏仅在文章页面（拥有目录列表）时才显示，并放置于右侧位置。 可以通过修改 主题配置文件 中的 sidebar 字段来控制侧栏的行为。侧栏的设置包括两个部分，其一是侧栏的位置， 其二是侧栏显示的时机。<br>1、设置侧栏的位置，修改 <code>sidebar.position</code>的值，支持的选项有：<ul>
<li>left：靠左放</li>
<li>right：靠右放置<br>2、设置侧栏显示时机，修改 <code>sidebar.display</code>的值</li>
</ul>
</li>
<li>设置头像<br>编辑 站点配置文件， 新增字段<code>avatar</code>， 值设置成头像的链接地址。其中，头像的链接地址可以是：</li>
</ul>
<h3 id="集成第三方服务"><a href="#集成第三方服务" class="headerlink" title="集成第三方服务"></a>集成第三方服务</h3><hr>
<ul>
<li><p>多说评论<br>  使用多说前需要先在 多说 创建一个站点。具体步骤如下：<br>  1、登录后在首页选择 “我要安装”。<br>  2、创建站点，填写站点相关信息。 多说域名 这一栏填写的即是你的 <code>duoshuo_shortname</code><br>  3、创建站点完成后在 站点配置文件 中新增 <code>duoshuo_shortname</code> 字段，值设置成上一步中的值。</p>
</li>
<li><p>百度统计<br>  1、登录 <a href="http://tongji.baidu.com/  百度统计" target="_blank" rel="external">百度统计</a>， 定位到站点的代码获取页面<br>  2、复制 <code>hm.js?</code> 后面那串统计脚本 id<br>  3、编辑 站点配置文件， 新增字段 <code>baidu_analytics</code> 字段，值设置成你的百度统计脚本 id</p>
</li>
<li><p>Local Search<br>  1、安装 <code>hexo-generator-search</code>，在站点的根目录下执行以下命令：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install hexo-generator-search --save</div></pre></td></tr></table></figure>
<p>  2、编辑 站点配置文件，新增以下内容到任意位置：</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">search:</div><div class="line">   path: search.xml</div><div class="line">   field: post</div></pre></td></tr></table></figure>
</li>
<li><p>打赏功能<br>   Next主题最新版默认集成打赏功能，在站点配置文件开启即可</p>
   <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Donate 文章末尾显示打赏按钮</div><div class="line">reward_comment: 生活不止眼前的苟且，还有远方的诗和田野</div><div class="line">wechatpay: /images/weixin.png</div><div class="line">alipay: /images/zhifubao.jpg</div></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gulp教程]]></title>
      <url>https://heji1993.github.io/2016/08/15/Gulp%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>基于文件流的构建系统。</p>
<a id="more"></a>
<h2 id="为什么使用Gulp"><a href="#为什么使用Gulp" class="headerlink" title="为什么使用Gulp"></a>为什么使用Gulp</h2><hr>
<p>Gulp基于Node.js的前端构建工具，通过Gulp的插件可以实现前端代码的编译（sass、less）、压缩、测试；图片的压缩；浏览器自动刷新，还有许多强大的插件可以在这里查找。比起Grunt不仅配置简单而且更容易阅读和维护</p>
<h2 id="建立Web项目"><a href="#建立Web项目" class="headerlink" title="建立Web项目"></a>建立Web项目</h2><hr>
<p>使用一下命令建立项目，会自动生成一个package.json文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="variable">$mkdir</span> projectName</div><div class="line"><span class="variable">$cd</span> projectName</div><div class="line"><span class="variable">$npm</span> init</div></pre></td></tr></table></figure></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><hr>
<ul>
<li><p>首先我们要全局安装一遍：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install gulp -g</div></pre></td></tr></table></figure>
</li>
<li><p>接着我们要进去到项目的根目录再安装一遍（确保你根目录存在package.json文件）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install gulp --save-dev</div></pre></td></tr></table></figure>
</li>
</ul>
<p>—save-dev这个属性会将条目保存到你package.json的devDependencies里面</p>
<h2 id="安装gulp插件"><a href="#安装gulp插件" class="headerlink" title="安装gulp插件"></a>安装gulp插件</h2><hr>
<p>我们将要使用Gulp插件来完成我们以下任务：</p>
<ul>
<li>sass的编译(<a href="https://github.com/sindresorhus/gulp-ruby-sass" target="_blank" rel="external">gulp-ruby-sass</a>)</li>
<li>自动添加CSS前缀(<a href="http://github.com/Metrime/gulp-autoprefixer" target="_blank" rel="external">gulp-autoprefixer</a>)</li>
<li>压缩CSS(<a href="http://github.com/jonathanepollack/gulp-minify-css" target="_blank" rel="external">gulp-minify-css</a>)</li>
<li>js代码校验(<a href="http://github.com/spenceralger/gulp-jshint" target="_blank" rel="external">gulp-jshint</a>)</li>
<li>合并js文件(<a href="http://github.com/wearefractal/gulp-concat" target="_blank" rel="external">gulp-concat</a>)</li>
<li>压缩js代码(<a href="http://github.com/terinjokes/gulp-uglify" target="_blank" rel="external">gulp-uglify</a>)</li>
<li>压缩图片(<a href="http://github.com/sindresorhus/gulp-imagemin" target="_blank" rel="external">gulp-imagemin</a>)</li>
<li>自动刷新页面(<a href="http://github.com/vohof/gulp-livereload" target="_blank" rel="external">gulp-livereload</a>)</li>
<li>图片缓存，只有图片替换了才压缩(<a href="http://github.com/jgable/gulp-cache" target="_blank" rel="external">gulp-cache</a>)</li>
<li>更改提醒(<a href="http://github.com/mikaelbr/gulp-notify" target="_blank" rel="external">gulp-notify</a>)</li>
<li>清除文件(<a href="http://www.npmjs.org/package/del" target="_blank" rel="external">del</a>)</li>
</ul>
<p>安装这些插件需要运行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install gulp-ruby-sass gulp-autoprefixer gulp-minify-css gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify gulp-rename gulp-livereload gulp-cache del --save-dev</div></pre></td></tr></table></figure></p>
<h2 id="加载插件"><a href="#加载插件" class="headerlink" title="加载插件"></a>加载插件</h2><hr>
<p>我们要在项目的根目录创建一个gulpfile.js文件，然后再里面加载插件:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</div><div class="line">    sass = <span class="built_in">require</span>(<span class="string">'gulp-ruby-sass'</span>),</div><div class="line">    autoprefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>),</div><div class="line">    minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>),</div><div class="line">    jshint = <span class="built_in">require</span>(<span class="string">'gulp-jshint'</span>),</div><div class="line">    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),</div><div class="line">    imagemin = <span class="built_in">require</span>(<span class="string">'gulp-imagemin'</span>),</div><div class="line">    rename = <span class="built_in">require</span>(<span class="string">'gulp-rename'</span>),</div><div class="line">    concat = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>),</div><div class="line">    notify = <span class="built_in">require</span>(<span class="string">'gulp-notify'</span>),</div><div class="line">    cache = <span class="built_in">require</span>(<span class="string">'gulp-cache'</span>),</div><div class="line">    livereload = <span class="built_in">require</span>(<span class="string">'gulp-livereload'</span>),</div><div class="line">    del = <span class="built_in">require</span>(<span class="string">'del'</span>);</div></pre></td></tr></table></figure></p>
<h2 id="建立任务"><a href="#建立任务" class="headerlink" title="建立任务"></a>建立任务</h2><hr>
<ul>
<li><p>编译sass、自动添加css前缀和压缩<br>   首先我们编译sass，添加前缀，保存到我们指定的目录下面，还没结束，我们还要压缩，给文件添加<code>.min</code>后缀再输出压缩文件到指定目录，最后提醒任务完成了：</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'styles'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> gulp.src(<span class="string">'src/styles/main.scss'</span>)</div><div class="line">     .pipe(sass(&#123; style: <span class="string">'expanded'</span> &#125;))</div><div class="line">     .pipe(autoprefixer(<span class="string">'last 2 version'</span>, <span class="string">'safari 5'</span>, <span class="string">'ie 8'</span>, <span class="string">'ie 9'</span>, <span class="string">'opera 12.1'</span>, <span class="string">'ios 6'</span>, <span class="string">'android 4'</span>))</div><div class="line">     .pipe(gulp.dest(<span class="string">'dist/assets/css'</span>))</div><div class="line">     .pipe(rename(&#123;suffix: <span class="string">'.min'</span>&#125;))</div><div class="line">     .pipe(minifycss())</div><div class="line">     .pipe(gulp.dest(<span class="string">'dist/assets/css'</span>))</div><div class="line">     .pipe(notify(&#123; message: <span class="string">'Styles task complete'</span> &#125;));</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
<p>   代码详解：</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'styles'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;...&#125;);</div></pre></td></tr></table></figure>
<p>   <code>gulp.task</code>这个api用来创建任务，在命令行下可以输入<code>gulp styles</code>来执行上面的任务</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> gulp.src(<span class="string">'src/styles/main.scss'</span>)</div></pre></td></tr></table></figure>
</code></pre><p>   <code>gulp.src</code>这个API设置需要处理的文件的路径，可以是多个文件以数组的形式<code>[main.scss, vender.scss]</code>，也可以是正则表达<code>/**/*.scss</code>。</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">. pipe(sass(&#123; style: <span class="string">'expanded'</span> &#125;))</div></pre></td></tr></table></figure>
</code></pre><p>   我们使用<code>.pipe()</code>这个API将需要处理的文件导向sass插件</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">. pipe(gulp.dest(<span class="string">'dist/assets/css'</span>));</div></pre></td></tr></table></figure>
</code></pre><p>   <code>gulp.dest()</code>API设置生成文件的路径，一个任务可以有多个生成路径，一个可以输出未压缩的版本，另一个可以输出压缩后的版本。</p>
</li>
</ul>
<ul>
<li>js代码校验、合并和压缩   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'scripts'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> gulp.src(<span class="string">'src/scripts/**/*.js'</span>)</div><div class="line">     .pipe(jshint(<span class="string">'.jshintrc'</span>))</div><div class="line">     .pipe(jshint.reporter(<span class="string">'default'</span>))</div><div class="line">     .pipe(concat(<span class="string">'main.js'</span>))</div><div class="line">     .pipe(gulp.dest(<span class="string">'dist/assets/js'</span>))</div><div class="line">     .pipe(rename(&#123;suffix: <span class="string">'.min'</span>&#125;))</div><div class="line">     .pipe(uglify())</div><div class="line">     .pipe(gulp.dest(<span class="string">'dist/assets/js'</span>))</div><div class="line">     .pipe(notify(&#123; message: <span class="string">'Scripts task complete'</span> &#125;));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>需要提醒的是我们要设置JSHint的reporter方式，上面使用的是default默认的</p>
<ul>
<li><p>压缩图片</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">      gulp.task(<span class="string">'images'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">         <span class="keyword">return</span> gulp.src(<span class="string">'src/images/**/*'</span>)</div><div class="line">           .pipe(imagemin(&#123; optimizationLevel: <span class="number">3</span>, progressive: <span class="literal">true</span>, interlaced: <span class="literal">true</span> &#125;))</div><div class="line">           .pipe(gulp.dest(<span class="string">'dist/assets/img'</span>))</div><div class="line">.pipe(notify(&#123; message: <span class="string">'Images task complete'</span> &#125;));</div><div class="line">      &#125;);</div></pre></td></tr></table></figure>
<p>   这个任务使用<code>imagemin</code>插件把所有在<code>src/images/</code>目录以及其子目录下的所有图片（文件）进行压缩，我们可以进一步优化，利用缓存保存已经压缩过的图片，使用之前装过的<code>gulp-cache</code>插件，不过要修改一下上面的代码：</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.pipe(imagemin(&#123; optimizationLevel: <span class="number">3</span>, progressive: <span class="literal">true</span>, interlaced: <span class="literal">true</span> &#125;))</div></pre></td></tr></table></figure>
<p>   修改成：</p>
<pre><code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.pipe(cache(imagemin(&#123; optimizationLevel: <span class="number">5</span>, progressive: <span class="literal">true</span>, interlaced: <span class="literal">true</span> &#125;)))</div></pre></td></tr></table></figure>
</code></pre><p>   现在，只有新建或者修改过的图片才会被压缩了。</p>
</li>
</ul>
<ul>
<li><p>清除文件<br>   在任务执行前，最好先清除之前生成的文件：</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'clean'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</div><div class="line">     del([<span class="string">'dist/assets/css'</span>, <span class="string">'dist/assets/js'</span>, <span class="string">'dist/assets/img'</span>], cb)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>   在这里没有必要使用Gulp插件了(没有gulp前缀)，可以使用NPM提供的插件。我们用一个回调函数（<code>cb</code>）确保在退出前完成任务。</p>
</li>
</ul>
<ul>
<li><p>设置默认任务<br>   我们在命令行下输入<code>$ gulp</code>执行的就是默认任务，现在我们为默认任务指定执行上面写好的三个任务：</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'clean'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">     gulp.start(<span class="string">'styles'</span>, <span class="string">'scripts'</span>, <span class="string">'images'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>   在这个例子里面，clean任务执行完成了才会去运行其他的任务，在<code>gulp.start()</code>里的任务执行的顺序是不确定的，所以将要在它们之前执行的任务写在数组里面。</p>
</li>
</ul>
<ul>
<li><p>监听文件<br>   为了监听文件的是否修改以便执行相应的任务，我们需要创建一个新的任务，然后利用<code>gulp.watch</code>API实现:</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="comment">// Watch .scss files</span></div><div class="line">   gulp.watch(<span class="string">'src/styles/**/*.scss'</span>, [<span class="string">'styles'</span>]);</div><div class="line">   <span class="comment">// Watch .js files</span></div><div class="line">   gulp.watch(<span class="string">'src/scripts/**/*.js'</span>, [<span class="string">'scripts'</span>]);</div><div class="line">   <span class="comment">// Watch image files</span></div><div class="line">   gulp.watch(<span class="string">'src/images/**/*'</span>, [<span class="string">'images'</span>]);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>   我们将不同类型的文件分开处理，执行对应的数组里的任务。现在我们可以在命令行输入<code>$ gulp watch</code>执行监听任务，当<code>.sass</code>、<code>.js</code>和图片修改时将执行对应的任务。</p>
</li>
</ul>
<ul>
<li><p>自动刷新页面<br>   Gulp也可以实现当文件修改时自动刷新页面，我们要修改<code>watch</code>任务，配置LiveReload：</p>
   <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   <span class="comment">// Create LiveReload server</span></div><div class="line">   livereload.listen();</div><div class="line">   <span class="comment">// Watch any files in dist/, reload on change</span></div><div class="line">   gulp.watch([<span class="string">'dist/**'</span>]).on(<span class="string">'change'</span>, livereload.changed);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>   要使这个能够工作，还需要在浏览器上安装LiveReload插件</p>
</li>
</ul>
<ul>
<li>所有任务放在一起<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*!</span></div><div class="line">*gulp</div><div class="line">*$ npm install gulp-ruby-sass gulp-autoprefixer gulp-minify-css gulp-jshint gulp-concat gulp-uglify gulp-imagemin gulp-notify         gulp-rename gulp-livereload gulp-cache del --save-dev</div><div class="line">*/</div><div class="line"><span class="comment">// Load plugins</span></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>),</div><div class="line">    sass = <span class="built_in">require</span>(<span class="string">'gulp-ruby-sass'</span>),</div><div class="line">    autoprefixer = <span class="built_in">require</span>(<span class="string">'gulp-autoprefixer'</span>),</div><div class="line">    minifycss = <span class="built_in">require</span>(<span class="string">'gulp-minify-css'</span>),</div><div class="line">    jshint = <span class="built_in">require</span>(<span class="string">'gulp-jshint'</span>),</div><div class="line">    uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>),</div><div class="line">    imagemin = <span class="built_in">require</span>(<span class="string">'gulp-imagemin'</span>),</div><div class="line">    rename = <span class="built_in">require</span>(<span class="string">'gulp-rename'</span>),</div><div class="line">    concat = <span class="built_in">require</span>(<span class="string">'gulp-concat'</span>),</div><div class="line">    notify = <span class="built_in">require</span>(<span class="string">'gulp-notify'</span>),</div><div class="line">    cache = <span class="built_in">require</span>(<span class="string">'gulp-cache'</span>),</div><div class="line">    livereload = <span class="built_in">require</span>(<span class="string">'gulp-livereload'</span>),</div><div class="line">    del = <span class="built_in">require</span>(<span class="string">'del'</span>);</div><div class="line"><span class="comment">// Styles</span></div><div class="line">gulp.task(<span class="string">'styles'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'src/styles/main.scss'</span>)</div><div class="line">    .pipe(sass(&#123; style: <span class="string">'expanded'</span>, &#125;))</div><div class="line">    .pipe(autoprefixer(<span class="string">'last 2 version'</span>, <span class="string">'safari 5'</span>, <span class="string">'ie 8'</span>, <span class="string">'ie 9'</span>, <span class="string">'opera 12.1'</span>, <span class="string">'ios 6'</span>, <span class="string">'android 4'</span>))</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist/styles'</span>))</div><div class="line">    .pipe(rename(&#123; suffix: <span class="string">'.min'</span> &#125;))</div><div class="line">    .pipe(minifycss())</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist/styles'</span>))</div><div class="line">    .pipe(notify(&#123; message: <span class="string">'Styles task complete'</span> &#125;));</div><div class="line">&#125;);</div><div class="line"><span class="comment">// Scripts</span></div><div class="line">gulp.task(<span class="string">'scripts'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'src/scripts/**/*.js'</span>)</div><div class="line">    .pipe(jshint(<span class="string">'.jshintrc'</span>))</div><div class="line">    .pipe(jshint.reporter(<span class="string">'default'</span>))</div><div class="line">    .pipe(concat(<span class="string">'main.js'</span>))</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist/scripts'</span>))</div><div class="line">    .pipe(rename(&#123; suffix: <span class="string">'.min'</span> &#125;))</div><div class="line">    .pipe(uglify())</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist/scripts'</span>))</div><div class="line">    .pipe(notify(&#123; message: <span class="string">'Scripts task complete'</span> &#125;));</div><div class="line">&#125;);</div><div class="line"><span class="comment">// Images</span></div><div class="line">gulp.task(<span class="string">'images'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'src/images/**/*'</span>)</div><div class="line">    .pipe(cache(imagemin(&#123; optimizationLevel: <span class="number">3</span>, progressive: <span class="literal">true</span>, interlaced: <span class="literal">true</span> &#125;)))</div><div class="line">    .pipe(gulp.dest(<span class="string">'dist/images'</span>))</div><div class="line">    .pipe(notify(&#123; message: <span class="string">'Images task complete'</span> &#125;));</div><div class="line">&#125;);</div><div class="line"><span class="comment">// Clean</span></div><div class="line">gulp.task(<span class="string">'clean'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;</div><div class="line">    del([<span class="string">'dist/assets/css'</span>, <span class="string">'dist/assets/js'</span>, <span class="string">'dist/assets/img'</span>], cb())</div><div class="line">&#125;);</div><div class="line"><span class="comment">// Default task</span></div><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'clean'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    gulp.start(<span class="string">'styles'</span>, <span class="string">'scripts'</span>, <span class="string">'images'</span>);</div><div class="line">&#125;);</div><div class="line"><span class="comment">// Watch</span></div><div class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// Watch .scss files</span></div><div class="line">  gulp.watch(<span class="string">'src/styles/**/*.scss'</span>, [<span class="string">'styles'</span>]);</div><div class="line">  <span class="comment">// Watch .js files</span></div><div class="line">  gulp.watch(<span class="string">'src/scripts/**/*.js'</span>, [<span class="string">'scripts'</span>]);</div><div class="line">  <span class="comment">// Watch image files</span></div><div class="line">  gulp.watch(<span class="string">'src/images/**/*'</span>, [<span class="string">'images'</span>]);</div><div class="line">  <span class="comment">// Create LiveReload server</span></div><div class="line">  livereload.listen();</div><div class="line">  <span class="comment">// Watch any files in dist/, reload on change</span></div><div class="line">  gulp.watch([<span class="string">'dist/**'</span>]).on(<span class="string">'change'</span>, livereload.changed);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></li>
</ul>
]]></content>
    </entry>
    
  
  
</search>
